{"meta":{"title":"PANJU's Note","subtitle":"故不积跬步，无以至千里；不积小流，无以成江海。","description":"笔记——记录工作和学习中的点点滴滴","author":"PANJU","url":"https://panzeyong.github.io"},"pages":[{"title":"categories","date":"2016-08-21T08:12:28.000Z","updated":"2016-08-21T08:12:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://panzeyong.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"about","date":"2017-03-11T15:18:09.000Z","updated":"2017-03-11T15:18:09.000Z","comments":true,"path":"about/index.html","permalink":"https://panzeyong.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2016-08-28T09:22:19.000Z","updated":"2016-08-28T09:22:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://panzeyong.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"第二章 在 HTML 中使用 JavaScript","slug":"第二章-在-HTML-中使用-JavaScript","date":"2017-05-03T23:40:59.000Z","updated":"2017-05-03T23:57:07.000Z","comments":true,"path":"2017/05/04/第二章-在-HTML-中使用-JavaScript/","link":"","permalink":"https://panzeyong.github.io/2017/05/04/第二章-在-HTML-中使用-JavaScript/","excerpt":"","text":"标签script：表示向 HTML 页面插入 JavaScript。该元素定义 6 个属性： async：可选。表示应该立即下载脚本，但不应妨碍页面中的其它内容加载。只对外部脚本文件有效。标记为 async 的脚本并不能保证按照指定的的先后顺序执行，一定会在页面的 load 事件前执行，但是对于 DOMContentLoaded 事件就不一定了。建议异步脚本不要在加载期间修改 DOM。 charset：可选。表示通过 src 属性指定的代码的字符集。 defer：可选。表示所要加载的脚本可以延迟到文档完全被解析和显示之后再执行，即遇到 html 标签之后才执行；只对外部脚本文件有效。HTML 5 规范要求延迟脚本是按照出现的顺序执行的，并且先于 DOMContentLoaded 事件，但是现实是不一定的，因此最好只包含一个延迟脚本。 language：已经废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME 类型）。通常的默认值为 text/javascript。 noscript：在不支持 JavaScript 的浏览器中显示替代的内容。 123&lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript&lt;/p&gt;&lt;/noscript&gt; 注意点 解释器对 script 元素内代码的解析是从上往下，在该元素内的代码被解析完之前，页面其它内容是不会被浏览器加载或者显示的。（外部文件也一样） 通过 src 属性引入外部文件必须要包含开始的 script 和结束的 script，只是 HTML 规范。 1&lt;script type=\"text/javasript\" src=\"example.js\"&gt;&lt;/script&gt; 带有 src 属性的 script 元素不应该在其元素之间包含额外的 JavaScritp 代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 JavaScript 代码建议放在 body 元素中页面内容之后 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第二章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/categories/《JavaScript-高级程序设计》学习笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/tags/JavaScript/"}]},{"title":"AsnycTask 用法及源码解析","slug":"AsnycTask-用法及源码解析","date":"2017-05-01T09:49:39.000Z","updated":"2017-05-03T23:52:53.000Z","comments":true,"path":"2017/05/01/AsnycTask-用法及源码解析/","link":"","permalink":"https://panzeyong.github.io/2017/05/01/AsnycTask-用法及源码解析/","excerpt":"","text":"AsyncTask 是一种轻量级异步任务类，可以在线程池执行后台任务，获取到的结果传递给主线程并且在主线程中更新 UI。AsyncTask 比较适合执行短时间任务，对于长时间任务推荐使用 Executor，ThreadPoolExecutor 和 FutureTask。 AsyncTask 是一个抽象类，提供三个泛型参数，分别是 Params，Progress 和 Result；以及 4 个步骤：onPreExecute，doInBackground，onProgressUpdate 和 onPostExecute。 AsyncTask 三个泛型参数 Params：发送给执行任务的参数类型。 Progress：执行后台任务进度的类型。 Result：执行完后台任务返回的结果类型。 AsyncTask 四个核心方法 onPreExecute()：在任务执行之前调用，主线程执行；主要做一些初始化工作，比如在用户界面展示进度条。 doInBackground(Params…)：onPreExecute() 执行完成后被调用，在线程池执行；所有的异步操作都在这个方法执行，执行结果被返回时，onPostExecute(Result) 会被调用。如果在该方法中调用 publishProgress(Progress…)，那么方法 onProgressUpdate(Progress…) 也会被调用，主要用于更新后台任务进度。 onProgressUpdate(Progress…)：publishProgress(Progress…) 执行完之后被调用，在主线程执行；主要在用户界面显示后台任务执行进度。 onPostExecute(Result)：doInBackground(Params…) 执行完之后调用，在主线程执行；参数 Result 是 doInBackground(Params…) 的返回值。 一个异步任务可以通过调用 cancel(boolean) 随时取消，此时 isCancelled() 被调用，这就导致 doInBackground(Params…) 执行完后 onPostExecute(Result) 不会被调用。 在使用 AsyncTask 的过程中，要注意以下几点： AsyncTask 类必须在 UI 线程加载，Android 4.1 已经自动绑定了。 AsyncTask 实例必须在 UI 线程创建。 execute(Params…) 必须在 UI 线程调用。 不要手动调用 onPreExecute()、onPostExecute(Result)、doInBackground(Params…)、onProgressUpdate(Progress…)。 一个 AsyncTask 对象只能被执行一次；否则会抛异常。 以上是 AsnycTask 基本知识点，掌握知识点后就要学会如何使用它。那么接下来就来学习 AsyncTask 用法。 AsyncTask 用法AsyncTask 是抽象类，不能直接实例化，必须创建新类并继承它，抽象方法 doInBackground(Params…) 是一定要重写的，其它三个方法根据自己的需求确定。以下通过 URL 获取数据为例子来讲解 AsyncTask 的用法。代码如下： 12345678910111213141516171819public class AsyncTaskExample extends AsyncTask&lt;String, Integer, String&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); mLoad.setVisibility(View.VISIBLE); &#125; @Override protected String doInBackground(String... params) &#123; return getUrlResponse(params[0]); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); mLoad.setVisibility(View.GONE); mText.setText(s); &#125;&#125; 从代码中可以很清晰地看出，第 5 行是显示加载进度条，表示正在获取数据；第 10 行是核心代码，异步操作，网络请求数据并将结果返回；第 16 - 17 行代码主要操作是隐藏进度条，表示数据加载完毕，并将获取到的结果显示出来。这里主要给出核心代码，至于其它代码也就调用而已。 那么该如何调用呢？很简单，一行代码就搞定 1new AsyncTaskExample().execute(url); AsyncTask 源码解析知其然必知其所以然。对于新知识点，学会使用之后，就应该探究其原理。由于个人倾向于通过画图来理解知识点的流程，因此先简单地给出 AsyncTask 任务执行的流程图，再根据流程图和源码进行讲解。流程图如下： 对于源码的理解，一般是以最终调用的方法为入口，一步一步地理解整个流程。那么对于 AsyncTask 该从哪里入手呢？当然是从方法 execute(Params… params) 入手了，代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 对于 AsyncTask 不同版本，execute(Params… params) 方法的执行方式是不一样的。Android 1.6 以前，AsyncTask 是单线程串行执行任务的；Android 1.6，AsyncTask 是线程池多线程并行执行任务；但是到 Android 3.0，AsyncTask 又改为单线程串行执行任务的。该方法的逻辑很简单，直接调用方法 executeOnExecutor(Executor exec, Params… params)，将我们传入的参数 params 和 sDefaultExecutor 传到该方法里，并将的返回值返回。那么来看下该方法的具体实现，代码如下： 12345678910111213141516public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; executeOnExecutor(Executor exec, Params… params) 方法是在线程池 THREAD_POOL_EXECUTOR 执行，允许多任务并发执行，但是不推荐采用多任务并发执行；在主线程执行。该方法实现的主要功能是： 检查任务状态，并记录任务当前状态； 调用 onPreExecute() 方法，根据我们自己的需求可以重写该方法； 将我们传入的参数 params 赋值给 WorkRunnable 中字段 mParams(稍后解释)； 调用 SerialExecutor 中方法 execute(Runnable r) 执行任务。 mWorker 是 WorkerRunnable 实例，而 WorkerRunnable 是抽象类，实现 Callable 接口，并且该接口有一个回调方法 call()；同时抽象类有一个字段 Params []，第 13 行代码就是把我们传进来的参数 params 赋值给它的。mWorker 是在创建 AsyncTask 实例时被初始化的，即 AsyncTask 构造方法里，并重写回调方法 call()，那么接下来看回调方法 call() 的具体实现。 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 该回调方法实现的主要功能： 将 mTaskInvoked 设置为 true，表示任务已经被调用过； 设置线程优先级为后台线程； 调用 doInBackground(mParams) 方法，异步执行，后台执行的逻辑都写在这个方法里面，一定要被重写；如果任务执行抛出异常时，取消任务； 调用 postResult(result) 方法； postResult(result) 的具体实现如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 从代码里可以看出，将执行结果通过 sHandler 发送 MESSAGE_POST_RESULT 的消息，然后 handleMessage() 方法收到消息后进行相应的处理。sHandler 是 InternalHandler 实例，主要作用是将任务执行的环境从线程切换到主线程中，从 InternalHandler 的具体实现就可以看出了。代码如下： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 从构造函数 InternalHandler() 就可以看出了，获取主线程 Looper，而 Handler 必须与 Looper 进行绑定，因此可以断定是在主线程里。handleMessage() 函数对两种消息进行处理：MESSAGE_POST_RESULT 和 MESSAGE_POST_PROGRESS；而我们刚刚发送的消息是 MESSAGE_POST_RESULT，那就先来看该消息收到后会做什么处理吧？很显然，调用 finish(Result result)，具体实现如下： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 如果任务被取消了，直接调用 onCancelled(result) 方法，onPostExecute(result) 方法不会被调用；否则就调用 onPostExecute(result) 方法，该方法需要被重写，在主线程执行，根据返回的结果进行相应的处理；最后修改任务的状态。那么对于消息 MESSAGE_POST_PROGRESS 是从哪里发出来的呢？还记得在前面的知识点讲解中有提到过如果在 doInBackground(mParams) 方法中调用 publishProgress(Progress…) 方法时，方法 onProgressUpdate(Progress…) 也会被调用，用于后台任务进度更新。没错，消息 MESSAGE_POST_PROGRESS 就是用来处理进度更新的。先看下 publishProgress(Progress…) 具体实现： 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 很显然，如果任务没有被取消的话，就会发送消息 MESSAGE_POST_PROGRESS，那么来看下收到该消息后的处理逻辑，即调用 onProgressUpdate(Progress… values) 方法，该方法需要我们根据自己的需求进行重写。 再回到 executeOnExecutor(Executor exec, Params… params) 方法，第 14 行代码开始执行任务，在理解如何执行任务之前，先来理解参数 mFuture 和 sDefaultExecutor 的含义。 mFuture 是 FutureTask 实例，在 AsyncTask 构造方法中初始化。将 mWorker 作为参数传入 FutureTask 构造函数，个人认为传入该参数的作用是由于 FutureTask 中 run() 方法会被调用，而在该方法里会通过传入参数 mWorker 调用 call() 方法，进而使任务得到执行。FutureTask 是一个并发执行任务类，可以执行任务、取消任务、查询结果、获取结果；提交到线程池执行。实现的接口有 Future、Runnable。 对于传入的参数 sDefaultExecutor，究竟是什么啥玩意呢？让我们来探个究竟吧。sDefaultExecutor 是 SerialExecutor 的实例，而 SerialExecutor 实际上是一个串行的线程池，主要的功能是一个进程中所有的 AsyncTask 任务都在这个串行的线程池中排队执行。看到这里，是不是还不知道任务真正在哪里被开始执行？其实以上都只是铺垫，下面才真正拉开序幕。真正开始执行任务的逻辑是在 SerialExecutor 中 execute(Runnable r) 方法里，具体实现如下： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 首先将 AsyncTask 通过线程池 SerialExecutor 添加到队列里（从这里可以看出 SerialExecutor 的作用），然后重写 run() 方法，并判断 mActive 是否为 null，即当前是否有任务在执行，如果有任务执行的话就等待该任务执行完后再执行其他任务，否则就执行任务，即调用 scheduleNext() 方法，该方法的主要功能是从队列 mTasks 获取任务，任务不为空的话就直接提交到线程池 THREAD_POOL_EXECUTOR 里执行（任务真正开始执行），即启动任务，根据个人的理解，任务被启动后，会调用第 6 行代码，即 run() 方法，进而调用 FutureTask 中 run() 方法，从而会调用 WorkerRunnable 中 call() 方法，因此任务被执行，我们重写的方法也会被调用。结合以上流程图应该能更清晰地理解 AsyncTask 执行流程。 以上是自己在学习 《Android 开发艺术探索》 这本书第十一章关于 AsyncTask 这个主题的学习笔记，由于自己能力有限，有错误的地方欢迎指出。 参考资料https://developer.android.com/reference/android/os/AsyncTask.html 《Android 开发艺术探索》》中 第 11 章 Android 的线程和线程池","raw":null,"content":null,"categories":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/categories/《Android-开发艺术探索》学习笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/tags/Android/"}]},{"title":"Python 学习笔记：字符串","slug":"Python-学习笔记：字符串","date":"2017-04-17T14:27:28.000Z","updated":"2017-04-21T23:52:32.000Z","comments":true,"path":"2017/04/17/Python-学习笔记：字符串/","link":"","permalink":"https://panzeyong.github.io/2017/04/17/Python-学习笔记：字符串/","excerpt":"","text":"定义：Python 的字符串是一种对象类型，这种类型用 str 表示，通常用双引号 “” 或者单引号 ‘’ 表示。 拼接字符串Python 的字符串是可以拼接，用符号 + 表示；但是与 Java 语言有一点不同的是拼接的两个对象必须是同类型，否则会报错。例子如下： 两个相同类型 str 拼接（正确） 12&gt;&gt;&gt; \"Hello \" + \"Python\"'Hello Python' 两个相同类型 int 拼接（正确） 12&gt;&gt;&gt; 5 + 38 两个不同类型 str 和 int 拼接（错误） 1234&gt;&gt;&gt; \"Python \" + 5Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 很显然，对于类型都是 str 将多个对象拼接起来；对于类型都是 int 则执行相加操作；对于不同类型则报错。那么对于不同类型的操作该如何转换呢？解决办法如下： str() 函数 12&gt;&gt;&gt; \"Python \" + str(3)'Python 3' repr() 函数（反引号的替代品） 12&gt;&gt;&gt; \"Python \" + repr(3)'Python 3' str() 与 repr() 区别 str() 将对象转化为可读性好的字符串，适合于 print 输出到终端，其返回值无法用于内建函数 eval。 repr() 返回对象的规范字符串表示形式；对于大多数对象而言，eval（repr（obj））== obj，也就是说，大多数情况下可以通过内建函数 eval 重新获取该对象。 大部分情况下 str() 用于终端输出，eval() 主要用于调试。 字符串格式化输出用于指定输出参数的格式与相对位置的字符串参数。通俗地讲，先定制模板，预留占位符，用对应类型的值填充；常用的占位符有 %s（字符串）、%d（整数）、%f（浮点数）。 以下通过例子说明 12&gt;&gt;&gt; \"I love my %s\" % \"job\" 'I love my job' 在这个字符串中，%s 是一个占位符，可以被其它字符串替换，这里替换的是 “job”。 12&gt;&gt;&gt; \"I'm %d years old\" % 20\"I'm 20 years old\" 不同占位符也可以混合使用，例子如下： 12&gt;&gt;&gt; \"What's your name ? My name is %s and I'm %d years old.\" % (\"John\", 15)\"What's your name ? My name is John and I'm 15 years old.\" 字符串常用方法index(…)：子字符串在整个字符串中的索引，即子字符串中第一个字符的位置。 123&gt;&gt;&gt; string = \"The programming language Python\"&gt;&gt;&gt; string.index(\"Python\")25 isalnum(…)：字符串中所有字符都是字母数字时返回 True，否则 False。 12345678910111213141516&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"199993\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalnum()True# 包含空格，并非全是字母数字，所以返回 False&gt;&gt;&gt; string = \"Python 3\"&gt;&gt;&gt; string.isalnum()False isalpha(…)：字符串中所有字符都是字母时返回 True，否则 False。 12345678910111213&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalpha()True# 包含数字&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalpha()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.isalpha()False isdecimal(…)：字符串中只有十进制字符时返回 True，否则返回 False。 12345678910111213141516171819202122232425262728293031# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdecimal()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isdecimal()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isdecimal'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdecimal()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdecimal()False# 包含字母&gt;&gt;&gt; string = \"Python1993\"&gt;&gt;&gt; string.isdecimal()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"1993 1993\"&gt;&gt;&gt; string.isdecimal()False isdigit(…)：字符串中所有字符都是数字 True，否则返回 False。 1234567891011121314151617181920212223# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdigit()True# byte数字（单字节）&gt;&gt;&gt; string =b\"1\"&gt;&gt;&gt; string.isdigit()True# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isdigit()False isnumeric(…)：字符串中只有数字字符时返回 True，否则返回 False。 123456789101112131415161718192021# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isnumeric()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isnumeric()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isnumeric'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isnumeric()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isnumeric()True 提示：isdecimal()、isdigit()、isnumeric() 三个函数区别如上。 islower(…)：字符串中所有字符都是小写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"python\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.islower()False isupper(…)：字符串中所有字符都是大写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"PYTHON\"&gt;&gt;&gt; string.isupper()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isupper()False join(…)：将序列中的元素以指定的字符连接成生成新的字符串。 123456789&gt;&gt;&gt; string = \"-\" # 指定的字符&gt;&gt;&gt; seq = \"Hello,Python\" # 序列&gt;&gt;&gt; string.join(seq)'H-e-l-l-o-,-P-y-t-h-o-n'&gt;&gt;&gt; string = \"-\"&gt;&gt;&gt; seq = ['Python', 'PHP']&gt;&gt;&gt; string.join(seq)'Python-PHP' lower(…)：返回字符串的副本并将其转换为小写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.lower()'welcome to python world !' upper(…)：返回字符串的副本并将其转换为大写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.upper()'WELCOME TO PYTHON WORLD !' capitalize(…)：字符串中首字母大写，其它都是小写。 123&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.capitalize()'Hello python' istitle(…)：字符串中所有单词的首字母大写，其它小写时返回 True，否则返回 False。 123456789101112131415&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"hello python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"HELLO PYTHON\"&gt;&gt;&gt; string.istitle()False split(…）：根据分隔符对字符串进行分割，返回列表。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string.split()['I', 'love', 'Python', '!'] strip(…)：去掉字符串左右空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.strip()'I love Python !' lstrip(…)：去掉字符串左边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.lstrip()'I love Python ! ' rstrip(…)：去掉字符串右边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.rstrip()&gt;&gt;&gt; ' I love Python !' len(…)：返回序列（字符串）的长度。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; len(string)15 in：判断字符串是否包含某个字符或子字符串，包含的话返回 True；否则返回 False。（区分大小写） 1234567&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"python\" in stringFalse&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"Python\" in stringTrue max：根据 ASCII 编码，求出字符串中最大值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; max(string)'y' min：根据 ASCII 编码，求出字符串中最小值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; min(string)' ' 索引与切片与其它编程一样，在 Python 中的字符串也可以通过索引获取相应的字符，唯一的区别是获取的方式不一样。在 Python 中，字符串是一种序列，以一种数组的形式存在，可以通过下标获取。最直接的方式还是通过例子来说明吧。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[7]'P' 这种形式很类似 Java 语言中数组，但是 Java 语言中通过索引获取字符串中某个字符是通过调用 charAt(index) 方法获取到；获取子字符串是通过调用 subString(start, end) 方法，但是在 Python 获取子字符串称为切片，获取方式跟字符类似。例子如下： 1234# 得到从字符串索引为 2 到 7 的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:8]'love P' 1234得到从字符串索引为 2 到末尾的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:]'love Python !' 1234# 获取全部字符&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:]'I love Python !' 1234# 获取从第一个字符到 9 之前的字符串&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:9]'I love Py' 从以上例子可以看出字符串切片的使用用法，以下做下简单的总结： [a : b]：表示从索引为 a 起到索引 b 之前字符串。 [:a]：从第一个字符到索引 a 之前的所有字符串。 [a : ]：表示从索引为 a 到末尾字符串。 [:]：表示原始字符串，但不是复制一份，只是两个变量指向同一个对象。 以上只是最近在学 Python 中字符串的小结，也可以说是学习笔记，方便以后查找。（基于 Python3） 参考资料http://docs.pythontab.com/learnpython/106/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"https://panzeyong.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://panzeyong.github.io/tags/python/"}]},{"title":"第一章 Activity 的生命周期和启动模式","slug":"第一章-Activity-的生命周期和启动模式","date":"2017-03-26T08:41:15.000Z","updated":"2017-03-26T15:00:27.000Z","comments":true,"path":"2017/03/26/第一章-Activity-的生命周期和启动模式/","link":"","permalink":"https://panzeyong.github.io/2017/03/26/第一章-Activity-的生命周期和启动模式/","excerpt":"","text":"Activity 正常情况下生命周期 生命周期方法分析 onCreate()：Activity 创建时调用，可以做一些初始化工作。 onRestart()：Activity 正在重新启动，由不可见状态变为可见状态。 onStart()：Activity 正在被启动，这时已经处于可见状态，但是还没出现在前台，而是在后台，无法与用户交互。 onResume()：Activity 已经处于可见状态，并且出现在前台。 onPause()：Activity 暂停，位于后台，可以做一些存储数据、停止动画等工作，但是不能太耗时。 onStop()：Activity 停止，不可见状态，可以做一些资源回收工作，但不能太耗时。 onDestroy()：Activity 销毁，可以做一些回收工作和资源释放。 Activity 生命周期方法不同情况下调用 Activity 第一次启动：onCreate() —&gt; onStart() —&gt; onResume()。 打开新的 Activity 或者切换到桌面：onPause() —&gt; onStop()。 回到原来 Activity：onRestart() —&gt; onStart() —&gt; onResume()。 按 back 键：onPause() —&gt; onStop() —&gt; onDestroy()。 注意（提示、问题） onCreate() 与 onDestroy() 是配对的，表示 Activity 的创建和销毁,并且只有可能一次调用。 onStart() 与 onStop() 是配对的，从是否可见这个角度来回调。 onResume() 与 onPause() 是配对的，从是否位于前台这个角度来回调。 如果新 Activity 采用了透明主题，那么当前 Activity 不会回到 onStop()（原因：处于可见状态，但是失去焦点，无法与用户进行交互）。 假设当前 Activity A，用户打开新的 Activity B，此时 A 的 onPause() 先调用，再调用 B 的 onResume()。 Activity异常情况下生命周期 系统配置发生改变导致 Activity 被杀死并重新创建 系统配置文件发生改变时，Activity 会被重新创建，生命周期方法调用顺序 onPause() —&gt; onSaveInstanceState() —&gt; onStop() —&gt; onDestroy() —&gt; onCreate() —&gt; onStart() —&gt; onRestoreInstanceState() —&gt; onResume()。 Activity 被异常终止情况下，onSaveInstanceState() 方法才会被调用，正常情况下是不会的；该方法调用时机是在 onStop() 之前，至于在 onPause() 之前或者之后并不确定。 Activity 被异常终止情况下，Activity 会被重建，此时 onRestoreInstanceState() 会被调用，调用时机在 onStart() 之后。 onCreate() 与 onRestoreInstanceState() 区别：onRestoreInstanceState() 一旦被调用，其参数 savedInstanceState 一定是有值的，不用判断是否为空；但 onCreate() 不一样，如果是正常启动时，其参数 savedInstanceState 为 null，所以需要额外判空。 可以通过设置android:configChanges属性让屏幕旋转时不重新创建。 资源内存不足导致低优先级的 Activity 被杀死 前台 Activity：正在和用户交互的 Activity，优先级最高。 可见但非前台 Activity：可见但是位于后台无法与用户进行交互，优先级次之。 后台 Activity：优先级最低。 Activity四种启动模式 启动模式 standard：标准模式，这也是系统默认模式。每当启动一个 Activity 创建一个实例，谁启动谁就在谁任务栈。 singleTop：栈顶复用模式。如果新 Activity 已经位于任务栈栈顶，那么此 Activity 不会被创建，同时 onNewIntent() 方法被调用，随后 onResume() 方法也被调用；反之则会重新创建 Activity。 singleTask：栈内复用模式，这是一种实例模式。 singleInstance：单实例模式，singleTask 加强版。Activity 启动时，系统会单独为其创建任务栈，然后此 Activity 就在这个任务栈中，后续跟 singleTask 相同。 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 启动模式。 FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 启动模式。 FLAG_ACTIVITY_CLEAR_TOP：与 singleTask 启动模式异同出现，作用相同。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有该标记的 Activity 不会出现在历史 Activity 列表中。 注意点 TaskAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用才起作用，其它情况下没用。 TaskAffinity 与 singleTask 启动模式配对使用时，此时 Activity 运行 TaskAffinity 属性所指定的任务栈。 TaskAffinity 与 allowTaskReparenting 配对使用时，情况比较复杂，会产生特殊效果。 IntentFilter 匹配规则 action 的匹配规则 匹配规则：Intent 中的 action 必须能够和过滤规则中的任何一个action 匹配。 区分大小写。 注意与 category 匹配规则不一样。 category 的匹配规则 匹配规则：Intent 所包含的 category 必须与过滤规则中的任何一个 category 相同（可理解为一对一关系）。 特殊情况是 Intent 可以没有 category，但是系统默认会加上android.intent.category.DEFAULT，这也是隐式调用所要求的。 data 匹配规则 data 的结构 android:scheme：URI 模式，比如 http、file、content 等。 android:port：URI 中的端口号，需要指定 scheme 和 host 才有作用。 android:host：URI 主机名。 android:path：完整的路径。 android:pathPattern：完整的路径信息，也可以包含通配符 *。 android:pathPrefix：路径的前缀信息。 android:mimeType：媒体类型。 匹配规则：Intent 包含的 data 数据必须与过滤规则中某一个匹配（Intent 是过滤规则的子集），与 action 类似。 过滤规则有默认URI值：content 和 file。 注意点 判断是否能匹配隐式 Intent 方法 调用 PackageManager 的 resolveActivity 方法。 Intent 的 resolveActivity 方法。 PackageManager 中 queryIntentActivies 方法。","raw":null,"content":null,"categories":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/categories/《Android-开发艺术探索》学习笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/tags/Android/"}]}]}