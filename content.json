{"meta":{"title":"PANJU's Note","subtitle":"故不积跬步，无以至千里；不积小流，无以成江海。","description":"笔记——记录工作和学习中的点点滴滴","author":"PANJU","url":"https://panzeyong.github.io"},"pages":[{"title":"about","date":"2017-03-11T15:18:09.000Z","updated":"2017-03-11T15:18:09.000Z","comments":true,"path":"about/index.html","permalink":"https://panzeyong.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2016-08-21T08:12:28.000Z","updated":"2016-08-21T08:12:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://panzeyong.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2016-08-28T09:22:19.000Z","updated":"2016-08-28T09:22:19.000Z","comments":true,"path":"tags/index.html","permalink":"https://panzeyong.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Python 学习笔记：字符串","slug":"Python-学习笔记：字符串","date":"2017-04-17T14:27:28.000Z","updated":"2017-04-21T14:19:03.000Z","comments":true,"path":"2017/04/17/Python-学习笔记：字符串/","link":"","permalink":"https://panzeyong.github.io/2017/04/17/Python-学习笔记：字符串/","excerpt":"","text":"定义：Python 的字符串是一种对象类型，这种类型用 str 表示，通常用双引号 “” 或者单引号 ‘’ 表示。 拼接字符串Python 的字符串是可以拼接，用符号 + 表示；但是与 Java 语言有一点不同的是拼接的两个对象必须是同类型，否则会报错。例子如下： 两个相同类型 str 拼接（正确） 12&gt;&gt;&gt; \"Hello \" + \"Python\"'Hello Python' 两个相同类型 int 拼接（正确） 12&gt;&gt;&gt; 5 + 38 两个不同类型 str 和 int 拼接（错误） 1234&gt;&gt;&gt; \"Python \" + 5Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 很显然，对于类型都是 str 将多个对象拼接起来；对于类型都是 int 则执行相加操作；对于不同类型则报错。那么对于不同类型的操作该如何转换呢？解决办法如下： str() 函数 12&gt;&gt;&gt; \"Python \" + str(3)'Python 3' repr() 函数（反引号的替代品） 12&gt;&gt;&gt; \"Python \" + repr(3)'Python 3' str() 与 repr() 区别 str() 将对象转化为可读性好的字符串，适合于 print 输出到终端，其返回值无法用于内建函数 eval。 repr() 返回对象的规范字符串表示形式；对于大多数对象而言，eval（repr（obj））== obj，也就是说，大多数情况下可以通过内建函数 eval 重新获取该对象。 大部分情况下 str() 用于终端输出，eval() 主要用于调试。 字符串格式化输出用于指定输出参数的格式与相对位置的字符串参数。通俗地讲，先定制模板，预留占位符，用字符串填充；常用的占位符有 %s（字符串）、%d（整数）、%f（浮点数）。 以下通过例子说明 12&gt;&gt;&gt; \"I love my %s\" % \"job\" 'I love my job' 在这个字符串中，%s 是一个占位符，可以被其它字符串替换，这里替换的是 “job”。 12&gt;&gt;&gt; \"I'm %d years old\" % 20\"I'm 20 years old\" 不同占位符也可以混合使用，例子如下： 12&gt;&gt;&gt; \"What's your name ? My name is %s and I'm %d years old.\" % (\"John\", 15)\"What's your name ? My name is John and I'm 15 years old.\" 字符串常用方法index(…)：子字符串在整个字符串中的索引，即字符串第一个字符的位置。 123&gt;&gt;&gt; string = \"The programming language Python\"&gt;&gt;&gt; string.index(\"Python\")25 isalnum(…)：字符串中所有字符都是字母数字时返回 True，否则 False。 12345678910111213141516&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"199993\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalnum()True# 包含空格，并非全是字母数字，所以返回 False&gt;&gt;&gt; string = \"Python 3\"&gt;&gt;&gt; string.isalnum()False isalpha(…)：字符串中所有字符都是字母时返回 True，否则 False。 12345678910111213&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalpha()True# 包含数字&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalpha()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.isalpha()False isdecimal(…)：字符串中只有十进制字符时返回 True，否则返回 False。 12345678910111213141516171819202122232425262728293031# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdecimal()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isdecimal()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isdecimal'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdecimal()False# 包含字母&gt;&gt;&gt; string = \"Python1993\"&gt;&gt;&gt; string.isdecimal()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"1993 1993\"&gt;&gt;&gt; string.isdecimal()False isdigit(…)：字符串中所有字符都是数字 True，否则返回 False。 1234567891011121314151617181920212223# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdigit()True# byte数字（单字节）&gt;&gt;&gt; string =b\"1\"&gt;&gt;&gt; string.isdigit()True# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isdigit()False isnumeric(…)：字符串中只有数字字符时返回 True，否则返回 False。 123456789101112131415161718192021# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isnumeric()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isnumeric()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isnumeric'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isnumeric()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isnumeric()True 提示：isdecimal()、isdigit()、isnumeric() 三个函数区别如上。 islower(…)：字符串中所有字符都是小写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"python\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.islower()False isupper(…)：字符串中所有字符都是大写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"PYTHON\"&gt;&gt;&gt; string.isupper()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isupper()False join(…)：将序列中的元素以指定的字符连接成生成新的字符串。 123456789&gt;&gt;&gt; string = \"-\" # 指定的字符&gt;&gt;&gt; seq = \"Hello,Python\" # 序列&gt;&gt;&gt; string.join(seq)'H-e-l-l-o-,-P-y-t-h-o-n'&gt;&gt;&gt; string = \"-\"&gt;&gt;&gt; seq = ['Python', 'PHP']&gt;&gt;&gt; string.join(seq)'Python-PHP' lower(…)：返回字符串的副本并将其转换为小写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.lower()'welcome to python world !' upper(…)：返回字符串的副本并将其转换为大写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.upper()'WELCOME TO PYTHON WORLD !' capitalize(…)：字符串中首字母大写，其它都是小写。 123&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.capitalize()'Hello python' istitle(…)：字符串中所有单词的首字母大写，其它小写时返回 True，否则返回 False。 123456789101112131415&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"hello python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"HELLO PYTHON\"&gt;&gt;&gt; string.istitle()False split(…：根据分隔符对字符串进行分割，返回列表。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string.split()['I', 'love', 'Python', '!'] strip(…)：去掉字符串左右空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.strip()'I love Python !' lstrip(…)：去掉字符串左边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.lstrip()'I love Python ! ' rstrip(…)：去掉字符串右边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.rstrip()&gt;&gt;&gt; ' I love Python !' len(…)：返回序列（字符串）的长度。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; len(string)15 in：判断字符串是否包含某个字符或子字符串，包含的话返回 True；否则返回 False。（区分大小写） 1234567&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"python\" in stringFalse&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"Python\" in stringTrue max：根据 ASCII 编码，求出字符串中最大值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; max(string)'y' min：根据 ASCII 编码，求出字符串中最小值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; min(string)' ' 索引与切片与其它编程一样，在 Python 中的字符串也可以通过索引获取相应的字符，唯一的区别是获取的方式不一样。在 Python 中，字符串是一种序列，以一种数组的形式存在，可以通过下标获取。最直接的方式还是通过例子来说明吧。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[7]'P' 这种形式很类似 Java 语言中数组，但是 Java 语言中通过索引获取字符串中某个字符是通过调用 charAt(index) 方法获取到；获取子字符串是通过调用 subString(start, end) 方法，但是在 Python 获取子字符串成为切片，跟获取字符类似。例子如下： 1234# 得到从字符串索引为 2 到 7 的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:8]'love P' 1234得到从字符串索引为 2 到末尾的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:]'love Python !' 1234# 获取全部字符&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:]'I love Python !' -1234# 获取从第一个字符到 9 之前的字符串&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:9]'I love Py' 从以上例子可以看出字符串切片的使用用法，以下做下简单的总结： [a : b]：表示从索引为 a 起到索引 b 之前字符串。 [:a]：从第一个字符到索引 a 之前的所有字符串。 [a : ]：表示从索引为 a 到末尾字符串。 [:]：表示原始字符串，但不是复制一份，只是两个变量指向同一个对象。 以上只是最近在学 Python 中字符串的小结，也可以说是学习笔记，方便以后查找。 参考资料http://docs.pythontab.com/learnpython/106/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"https://panzeyong.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://panzeyong.github.io/tags/python/"}]},{"title":"第一章 Activity 的生命周期和启动模式","slug":"第一章-Activity-的生命周期和启动模式","date":"2017-03-26T08:41:15.000Z","updated":"2017-03-26T15:00:27.000Z","comments":true,"path":"2017/03/26/第一章-Activity-的生命周期和启动模式/","link":"","permalink":"https://panzeyong.github.io/2017/03/26/第一章-Activity-的生命周期和启动模式/","excerpt":"","text":"Activity 正常情况下生命周期 生命周期方法分析 onCreate()：Activity 创建时调用，可以做一些初始化工作。 onRestart()：Activity 正在重新启动，由不可见状态变为可见状态。 onStart()：Activity 正在被启动，这时已经处于可见状态，但是还没出现在前台，而是在后台，无法与用户交互。 onResume()：Activity 已经处于可见状态，并且出现在前台。 onPause()：Activity 暂停，位于后台，可以做一些存储数据、停止动画等工作，但是不能太耗时。 onStop()：Activity 停止，不可见状态，可以做一些资源回收工作，但不能太耗时。 onDestroy()：Activity 销毁，可以做一些回收工作和资源释放。 Activity 生命周期方法不同情况下调用 Activity 第一次启动：onCreate() —&gt; onStart() —&gt; onResume()。 打开新的 Activity 或者切换到桌面：onPause() —&gt; onStop()。 回到原来 Activity：onRestart() —&gt; onStart() —&gt; onResume()。 按 back 键：onPause() —&gt; onStop() —&gt; onDestroy()。 注意（提示、问题） onCreate() 与 onDestroy() 是配对的，表示 Activity 的创建和销毁,并且只有可能一次调用。 onStart() 与 onStop() 是配对的，从是否可见这个角度来回调。 onResume() 与 onPause() 是配对的，从是否位于前台这个角度来回调。 如果新 Activity 采用了透明主题，那么当前 Activity 不会回到 onStop()（原因：处于可见状态，但是失去焦点，无法与用户进行交互）。 假设当前 Activity A，用户打开新的 Activity B，此时 A 的 onPause() 先调用，再调用 B 的 onResume()。 Activity异常情况下生命周期 系统配置发生改变导致 Activity 被杀死并重新创建 系统配置文件发生改变时，Activity 会被重新创建，生命周期方法调用顺序 onPause() —&gt; onSaveInstanceState() —&gt; onStop() —&gt; onDestroy() —&gt; onCreate() —&gt; onStart() —&gt; onRestoreInstanceState() —&gt; onResume()。 Activity 被异常终止情况下，onSaveInstanceState() 方法才会被调用，正常情况下是不会的；该方法调用时机是在 onStop() 之前，至于在 onPause() 之前或者之后并不确定。 Activity 被异常终止情况下，Activity 会被重建，此时 onRestoreInstanceState() 会被调用，调用时机在 onStart() 之后。 onCreate() 与 onRestoreInstanceState() 区别：onRestoreInstanceState() 一旦被调用，其参数 savedInstanceState 一定是有值的，不用判断是否为空；但 onCreate() 不一样，如果是正常启动时，其参数 savedInstanceState 为 null，所以需要额外判空。 可以通过设置android:configChanges属性让屏幕旋转时不重新创建。 资源内存不足导致低优先级的 Activity 被杀死 前台 Activity：正在和用户交互的 Activity，优先级最高。 可见但非前台 Activity：可见但是位于后台无法与用户进行交互，优先级次之。 后台 Activity：优先级最低。 Activity四种启动模式 启动模式 standard：标准模式，这也是系统默认模式。每当启动一个 Activity 创建一个实例，谁启动谁就在谁任务栈。 singleTop：栈顶复用模式。如果新 Activity 已经位于任务栈栈顶，那么此 Activity 不会被创建，同时 onNewIntent() 方法被调用，随后 onResume() 方法也被调用；反之则会重新创建 Activity。 singleTask：栈内复用模式，这是一种实例模式。 singleInstance：单实例模式，singleTask 加强版。Activity 启动时，系统会单独为其创建任务栈，然后此 Activity 就在这个任务栈中，后续跟 singleTask 相同。 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 启动模式。 FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 启动模式。 FLAG_ACTIVITY_CLEAR_TOP：与 singleTask 启动模式异同出现，作用相同。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有该标记的 Activity 不会出现在历史 Activity 列表中。 注意点 TaskAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用才起作用，其它情况下没用。 TaskAffinity 与 singleTask 启动模式配对使用时，此时 Activity 运行 TaskAffinity 属性所指定的任务栈。 TaskAffinity 与 allowTaskReparenting 配对使用时，情况比较复杂，会产生特殊效果。 IntentFilter 匹配规则 action 的匹配规则 匹配规则：Intent 中的 action 必须能够和过滤规则中的任何一个action 匹配。 区分大小写。 注意与 category 匹配规则不一样。 category 的匹配规则 匹配规则：Intent 所包含的 category 必须与过滤规则中的任何一个 category 相同（可理解为一对一关系）。 特殊情况是 Intent 可以没有 category，但是系统默认会加上android.intent.category.DEFAULT，这也是隐式调用所要求的。 data 匹配规则 data 的结构 android:scheme：URI 模式，比如 http、file、content 等。 android:port：URI 中的端口号，需要指定 scheme 和 host 才有作用。 android:host：URI 主机名。 android:path：完整的路径。 android:pathPattern：完整的路径信息，也可以包含通配符 *。 android:pathPrefix：路径的前缀信息。 android:mimeType：媒体类型。 匹配规则：Intent 包含的 data 数据必须与过滤规则中某一个匹配（Intent 是过滤规则的子集），与 action 类似。 过滤规则有默认URI值：content 和 file。 注意点 判断是否能匹配隐式 Intent 方法 调用 PackageManager 的 resolveActivity 方法。 Intent 的 resolveActivity 方法。 PackageManager 中 queryIntentActivies 方法。","raw":null,"content":null,"categories":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/categories/《Android-开发艺术探索》学习笔记/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/tags/Android/"}]}]}