{"meta":{"title":"PANJU's Note","subtitle":"故不积跬步，无以至千里；不积小流，无以成江海。","description":"笔记——记录工作和学习中的点点滴滴","author":"PANJU","url":"http://panzeyong.com"},"pages":[{"title":"","date":"2017-09-09T09:49:47.000Z","updated":"2017-09-09T09:49:47.000Z","comments":true,"path":"google4d3daea4561f646d.html","permalink":"http://panzeyong.com/google4d3daea4561f646d.html","excerpt":"","text":"google-site-verification: google4d3daea4561f646d.html","raw":null,"content":null},{"title":"about","date":"2017-03-11T15:18:09.000Z","updated":"2017-03-11T15:18:09.000Z","comments":true,"path":"about/index.html","permalink":"http://panzeyong.com/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-06-19T04:52:59.000Z","updated":"2017-06-19T04:52:59.000Z","comments":true,"path":"categories/index.html","permalink":"http://panzeyong.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-06-19T04:52:00.000Z","updated":"2017-06-19T04:52:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://panzeyong.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Javascript 之原型及原型链","slug":"Javascript-之原型及原型链","date":"2019-11-18T23:53:16.000Z","updated":"2019-11-23T09:29:09.852Z","comments":true,"path":"2019/11/19/Javascript-之原型及原型链/","link":"","permalink":"http://panzeyong.com/2019/11/19/Javascript-之原型及原型链/","excerpt":"","text":"概述Javascript 函数有一个 prototype 属性，该属性是一个指针，指向一个对象，该对象包含特定类型的所有实例共享的属性和方法，称为实例对象的原型对象。 简单来说，在 JavaScript 中创建一个新函数，就会自动获取 prototype 属性，通过 new 命令创建实例对象，实例对象会获取 prototype 属性所指向的原型对象的属性和方法。打个比方，在 Java 中有类和继承的概念，prototype 所指向的原型对象就好比 Java 中的基类，而新函数好比是 Java 中的新类，继承基类中的属性和方法，那么创建实例后，除了能访问到本身的属性和方法外，还能访问到基类中的属性和方法。 构造函数与原型对象之间的关系12345function Person() &#123;&#125;let person = new Person();person.age = 12;console.log(person.age); // 12 以上例子，Person 是一个构造函数，通过 new 命令实例化对象。通过构造函数实例化对象的方式，如果多个实例对象都拥有属性 age 时，则需要在每个实例对象本身设置该属性，这样的操作显得有点冗余。那么有没有一种方式可以把属性 age 设置为公有，实例化对象时就自动拥有公共的属性呢，而对于实例对象本身只需要添加自己需要的属性即可。答案是有的。 这里就需要引出 prototype 属性，那么 prototype 属性是什么呢？除了bind 函数、箭头函数以及 Function.prototype 外，每个函数都有一个属性 prototype，该属性是一个指针，指向一个对象，该对象是函数的原型对象，原型对象包含了公共的属性和方法，实例化的所有对象都共享原型对象的属性和方法。需要注意的是 *prototype 属性是函数才拥有的。 1234567891011121314151617181920Person.prototype.age = 12;Person.prototype.name = \"Jack\";Person.prototype.say = () =&gt; &#123; console.log(\"Hello World !\");&#125;;let person1 = new Person();let person2 = new Person();console.log(person1.age); // 12console.log(person1.name); // Jackconsole.log(person2.age); // 12console.log(person2.name); // Jackconsole.log(person1.say()); // Hello Worldconsole.log(person2.say()); // Hello Worldperson1.job = \"test\";console.log(person1.job); // testconsole.log(person2.job); // undefined 从以上例子可以得知，通过 prototype 属性添加 age 和 name 属性，然后实例化两个对象，分别打印出两个属性是有值的，说明实例对象拥有了原型对象的属性和方法。 现在我们已经知道构造函数与原型对象的单向关系，即构造函数通过 prototype 属性指向原型对象。那么原型对象能反过来通过某种方式指向原先的构造函数吗？答案是可以的，这时就需要 constructor 派上场了。 每个原型对象都会有一个 constructor 属性，而 constructor 属性包含一个指向 prototype 属性所在函数的指针。以上面例子为例，即 Person.prototype.constructor === Person（true）。 至此，我们理清了构造函数与原型对象之间的关系，关系图如下： 实例对象与原型对象之间的关系当读取实例对象属性时，首先会在实例对象本身查找该属性是否存在，不存在的话，就会往实例对象与之关联的原型对象查找，再查找不到时，直向原型的原型查找，查找到最上层为止。 例子如下： 1234567function Person () &#123;&#125;Person.prototype.name = \"Jack\";Person.prototype.desc = \"desc\";let person = new Person();console.log(person.name); // Jack 可见，实例对象 person 本身没有属性 name，但是还能查找到该属性，这是通过原型对象找到的。那么实例对象是通过什么方式与原型对象关联呢？其实实例对象有一个属性 __proto__，指向原型对象，即 person.__proto__ === Person.prototype（true）。 原型对象的原型对象从上面我们已经理清了构造函数与原型对象、实例对象与原型对象之间的关系，那么我们会不会产生一个疑惑：原型对象的原型对象是什么，即 Person.prototype 的原型对象是什么？ JavaScript 中的所有对象都来自 Object，并且所有对象都从 Object.prototype 继承属性和方法，尽管它们可能被覆盖。因此可以推出： Person.prototype.__proto__ === Object.prototype（true）。 图中画虚线的表示通过 __prototype__ 形成原型链；至此，已经把原型对象及原型链的知识讲完。最后放一张网上对原型的理解画得比较全面的关系图，如下： 注：以上只是自己整理的学习笔记，由于水平有限难免有错误，欢迎指出。随着自己对原型的深入理解，笔记也会做相应的修改，最后放上资料参考来源。 https://github.com/mqyqingfeng/Blog/issues/2 《JavaScript 高级程序设计》（第 3 版）","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://panzeyong.com/tags/知识点整理/"}]},{"title":"Vue.js 源码目录结构","slug":"Vue-js-源码目录结构","date":"2018-12-19T14:33:04.000Z","updated":"2020-08-29T08:23:35.144Z","comments":true,"path":"2018/12/19/Vue-js-源码目录结构/","link":"","permalink":"http://panzeyong.com/2018/12/19/Vue-js-源码目录结构/","excerpt":"","text":"今年 4 月份开始使用 Vue.js，到现在差不多有 8 个月了，参与了两三个项目，对 Vue.js 的用法有了一定的了解。但是我觉得会使用是学习框架的第一步，第二步是研究框架是怎么实现的，学习其设计思想。所以给自己制定了计划来学习 Vue.js 框架源码，打算把自己学习到的知识作为一个系列记录下来。 在学习源码之前，先来学习下 Vue.js 目录结构设计，从整体上了解 Vue.js 的结构。 注：Vue.js 的版本为 2.6.11 目录结构 .circleci：Vue.js 使用了持续集成工具 CircleCI，要在项目中使用该工具，需要在项目根目录创建文件夹 .circleci，并在其目录下创建文件 config.yml 编写构建脚本。 config.yml：编写 CircleCI 构建脚本。 .github：项目相关说明文档，比如开发者参与项目的规则、要求之类的。 CODE_OF_CONDUCT.md：贡献代码的行为准则。 COMMIT_CONVENTION.md：git 提交代码时添加提交信息的约定。 CONTRIBUTING.md：参与项目指南。 ISSUE_TEMPLATE.md：提交 issue 的模板。 PULL_REQUEST_TEMPLATE.md：拉取代码指南。 benchmarks：性能测试相关文件。 dist：包含不同分发版本的构建文件。要注意的是，这个目录只有在发布新版本时才会更新，开发分支更新的新特性不会影响到该目录。 example：官方提供的示例。 flow：包含使用Flow（静态类型检查工具）声明的类型，供全局使用。 compiler.js：编译相关。 component.js：组件数据结构。 global-api.js：Global API 结构。 modules.js：第三方库定义。 options.js：选项相关。 ssr.js：服务端渲染相关。 vnode.js：虚拟 node 相关。 weex.js：weex 平台相关。 packages：包含服务端渲染和模板编译器两种不同 NPM 包，供不同场景使用。 vue-server-render：服务端渲染。 vue-template-compiler：vue 模板编译器。 weex-template-compiler：weex 模板编译器。 weex-vue-framework：weex vue 框架。 scripts：包含构建相关脚本和配置文件，大多数情况下不需要关注该目录。 alias.js：所有源代码和测试中使用的模块导入别名。 config：包含 dist 目录下所有文件的配置信息。 src：vue.js 源代码，代码用 ES6 实现的并采用 JavaScript 静态类型检查工具。 compiler：该目录包含 Vue.js 编译的相关代码，包括将模板字符串解析成 AST 语法树的解析器、检测用于 vdom 渲染优化的静态树的优化器和将 AST 语法树生成渲染函数的代码生成器。 core：Vue.js 核心代码，包含通用、跨平台的代码。主要有观察者、虚拟 dom、vue 实例化、全局 api 和内置组件。 server：包含与服务端渲染相关的代码。 platform：Vue.js 是一个跨平台的 MVVM 框架，可以在 web 上运行，也可以配合 weex 在 native 客户端上运行。每个平台都有一个入口，都位于该目录下。 sfc：包含将 .vue 单文件解析为 JavaScript 对象的代码，用于 vue-template-compiler 包。 shared：包含通用的工具方法，用于浏览器端的 vue.js 和服务器端的 vue.js。 tests：所有测试代码，单元测试代码是用 Jasmine 实现并与 Karma 一起运行。e2e 测试是为 Nightwatch.js 编写并与之一起运行。 types：使用 TypeScript 类型注释，并且包含了测试代码。 参考资料https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#project-structure https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html#compiler https://segmentfault.com/a/1190000016426470","raw":null,"content":null,"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://panzeyong.com/categories/Vue-js/"}],"tags":[{"name":"Vue.js 源码解析","slug":"Vue-js-源码解析","permalink":"http://panzeyong.com/tags/Vue-js-源码解析/"}]},{"title":"JavaScript 静态类型检查工具：Flow","slug":"JavaScript-静态类型检查工具：Flow","date":"2018-12-04T15:01:32.000Z","updated":"2018-12-11T15:01:24.234Z","comments":true,"path":"2018/12/04/JavaScript-静态类型检查工具：Flow/","link":"","permalink":"http://panzeyong.com/2018/12/04/JavaScript-静态类型检查工具：Flow/","excerpt":"","text":"Flow 是 Facebook 开源的 JavaScript 静态类型检查工具，它可以帮助提高我们的工作效率，使我们的代码更快、更智能、更自信和更大规模。 在学习 Flow 的用法之前，我们先来学习如何在项目中使用 Flow。 一、安装1、安装编译器在 Flow 官方文档可以了解到，安装 Flow 的方式多种，主要取决于项目使用什么工具。Flow 可以通过包管理器来安装，即 npm 或 yarn，而在安装 Flow 时，需要设置编译器，有两种编译器：Babel 和 flow-remove-types，所以总共有 4 种安装方式。这里包管理器为 npm 和 编译器为 Babel 为例子来说。 设置编译器 1npm install --save-dev babel-cli babel-preset-flow 在项目根目录创建 .babelrc 文件，并添加以下代码 123&#123; \"presets\": [\"flow\"]&#125; 如果所有源文件都存储在 src 目录下，那么可以通过运行以下命令，把它们编译到另外一个目录 1./node_modules/.bin/babel src/ -d lib/ 在 package.json 文件 script 添加代码 12345678 &#123; \"name\": \"my-project\", \"main\": \"lib/index.js\", \"scripts\": &#123; \"build\": \"babel src/ -d lib/\", \"prepublish\": \"npm run build\" &#125;&#125; 2、安装 Flow 安装 flow-bin 12345678910111213141516 npm install --save-dev flow-bin ``` - 在 `package.json` 文件 `script` 添加 Flow ```json &#123; &quot;name&quot;: &quot;my-flow-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;devDependencies&quot;: &#123; &quot;flow-bin&quot;: &quot;^0.87.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;flow&quot;: &quot;flow&quot; &#125;&#125; 初始化 Flow，会生成文件 .flowconfig 1npm run flow init 运行 Flow 1npm run flow 二、Flow 的工作方式Flow 类型检查有两种方式： 类型推断：结合变量的上下文语境推断出变量的数据类型，然后根据推断出的数据类型进行类型检查。 类型注释：在定义变量时声明其数据类型，Flow 会基于声明的数据类型作出判断。 1、类型推断类型推断这种类型检查方式对于开发者来说工作量几乎为零，基本不需要对代码作任何改造，Flow 会根据变量的上下文推断出类型，进而作出判断。 123456// @flowfunction square(n) &#123; return n * n; &#125;square(\"2\"); // Error Flow 检查上述代码会报错，因为函数 square 期待输入的参数是整型，而我们输入的是字符串。 2、类型注释在某些场景下，通过类型推断是检查不出类型错误的，这时就需要通过其它方式来检查类型，也就是这部分要说的类型注释。类型注释是说在定义变量时声明其数据类型，有点类似静态语言，比如 Java，Flow 会基于此作出判断。 先来看一个通过类型推断检查不出错误的例子： 1234567/*@flow*/function add(x, y)&#123; return x + y&#125;add('Hello', 222) 以上代码，从语法上看没有错误，+ 既可以用在字符串上，也可以用在整型上，而且我们并没有指出函数 add 参数必须为整型，其实我们期望的是两个整型相加，为了达到这目的，我们可以指定变量的类型，如下： 12345function add(x: number, y: number)&#123; return x + y&#125;add('Hello', 222) // Error 此时，我们指定变量 x 和 y 的数据类型为整型，而我们传递的参数中有一个是字符串，那么 Flow 检查类型就会报错。 参考资料 https://flow.org/en/docs/getting-started/ https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"http://panzeyong.com/tags/plugin/"}]},{"title":"《Python3 网络爬虫开发实战》问题汇总（持续更新......）","slug":"《Python3-网络爬虫开发实战》问题汇总","date":"2018-12-04T14:52:32.000Z","updated":"2018-12-04T14:57:14.049Z","comments":true,"path":"2018/12/04/《Python3-网络爬虫开发实战》问题汇总/","link":"","permalink":"http://panzeyong.com/2018/12/04/《Python3-网络爬虫开发实战》问题汇总/","excerpt":"","text":"mac 系统版本信息： macOS High Sierra Version 10.13.4 1、安装 ChromeDrivermv: rename chromedriver to /usr/bin/chromedriver: Operation not permitted 解决方案 2、安装 GeckodriverPermission denied: ‘geckodriver.log’ while running selenium webdriver in python [解决方案(https://stackoverflow.com/questions/40466809/permission-denied-geckodriver-log-while-running-selenium-webdriver-in-python)","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://panzeyong.com/categories/Python/"}],"tags":[{"name":"question","slug":"question","permalink":"http://panzeyong.com/tags/question/"}]},{"title":"JavaScript 问题","slug":"JavaScript-问题","date":"2018-03-08T09:25:35.000Z","updated":"2018-03-09T05:38:51.000Z","comments":true,"path":"2018/03/08/JavaScript-问题/","link":"","permalink":"http://panzeyong.com/2018/03/08/JavaScript-问题/","excerpt":"","text":"一、JavaScript 数组（包括元素和对象）去重1、for 循环1234567891011121314151617function unique(array) &#123; var result = [array[0]]; for (var i = 1, len = array.length; i &lt; len; i++) &#123; for (var j = 0, resultLen = result.length; j &lt; resultLen; j++) &#123; if (array[i] === result[j]) &#123; break; &#125; &#125; if (j === resultLen) &#123; result.push(array[i]); &#125; &#125; return result;&#125; 2、indexOf1234567891011function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current); &#125; &#125; return res;&#125; 3、排序后去重12345678910111213function unique(array) &#123; var res = []; var sortedArray = array.concat().sort(); var seen; for (var i = 0, len = sortedArray.length; i &lt; len; i++) &#123; // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) &#123; res.push(sortedArray[i]) &#125; seen = sortedArray[i]; &#125; return res;&#125; 4、ES6 Set123function unique(array) &#123; return Array.from(new Set(array));&#125; 5、根据对象属性的唯一值（针对数组元素是对象）123456789unique(score: Score) &#123; this.changedScore.some((item, index) =&gt; &#123; if (item.questionId === score.questionId) &#123; this.changedScore.splice(index, 1); return true; &#125; &#125;); this.changedScore = this.changedScore.concat(score); &#125; 二、如何防止频繁操作1、防抖动 原理：当触发事件时，事件必须在 n 秒后才执行，但是当在这 n 秒内又触发事件，事件执行是以最新触发事件的事件为起点，直到这 n 秒内不再触发事件为止，事件才在 n 秒后被执行。 代码实现 12345678910111213 function debounce(func, wait) &#123; var timeout; return function () &#123; var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125;&#125; 2、节流允许一个函数在规定的时间内只执行一次。 实现方法： 时间戳 定时器","raw":null,"content":null,"categories":[],"tags":[]},{"title":"插入排序：直接插入排序","slug":"插入排序：直接插入排序","date":"2018-01-22T14:23:30.000Z","updated":"2018-01-22T15:04:02.000Z","comments":true,"path":"2018/01/22/插入排序：直接插入排序/","link":"","permalink":"http://panzeyong.com/2018/01/22/插入排序：直接插入排序/","excerpt":"","text":"在日常开发工作中，不管是前端开发还是后端开发，在处理数据时，有时根据业务需求需要对数据进行排序，这就涉及到排序算法的选择。然而排序算法有很多种，对于算法的选择需要根据业务的需求，除此之外，还需要扎实的基本功。最近刚好在学习排序算法，把它记录下来，当作学习笔记。这篇文章要讲的是插入排序中一种：直接插入排序。 一、引言排序，简单来说就是把一组无序的元素以正序或者逆序的方式排序，那么至于采取什么方式排序，即是接下来要讲的。插入排序的主要思想是将一组元素的第一个元素看作是有序序列，从第二个元素起将待排序的元素插入到有序序列中，使有序序列逐渐扩大，直至所有元素都插入到有序序列中。直接插入排序是插入排序的一种，也是比较简单的一种排序方法，以下通过类比的例子来说明直接插入排序的思想。 这里小学上体育课为例子。回想下我们当时上第一节体育课的情景，老师会说：“同学们，先排好队伍，我们再开始上课”。那么此时老师会根据同学们的身高来排队伍，先按身高从低到高排成一排（从左到右站队），再分成 n 行 n 列。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"第五章 初始化与清理","slug":"第五章-初始化与清理","date":"2017-12-18T13:34:19.000Z","updated":"2018-01-02T23:28:42.000Z","comments":true,"path":"2017/12/18/第五章-初始化与清理/","link":"","permalink":"http://panzeyong.com/2017/12/18/第五章-初始化与清理/","excerpt":"","text":"一、构造器1、要点 构造器的名称必须与类名完全相同； 构造器是一种特殊类型的方法，没有返回值； 构造器可以重载； 若无构造器则会默认创建无参构造器；否则不会； 构造器有助于减少错误，并使代码更易于阅读。 2、构造器中调用构造器 必须将构造器调用置于最起始处，否则编译器会报错； 使用 this 调用构造器时，不能调用多次； 除构造器外，编译器禁止在其它任何方法中调用构造器。 二、方法重载 方法名相同 必须有独一无二的参数类型列表 参数顺序不同也能区分（不推荐） 传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升；反之，如果传入的数据类型（实际参数类型）大于方法中声明的形式参数类型，实际数据类型就得通过类型转换执行窄化操作，否则编译器会报错。 不能通过方法返回值区分 三、关键字1、this 对当前对象的引用； 只能在方法内部使用 2、static static 方法里不能使用关键字 this； static 方法内部不能调用非静态方法； 非静态方法内部可以调用静态方法； 成员初始化 类的数据成员（即字段）若未初始化，系统则会指定默认值；局部变量若未初始化，编译器则会报错； 无法阻止自动初始化的进行，它将在构造器被调用之前发生； 初始化顺序 在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化；（变量优先于构造器和方法初始化） 静态变量优先于非静态变量初始化； 创建一个类的多个实例时，静态变量只初始化一次，非静态变量每次被初始化； 对于静态块，首次创建该类对象或首次访问静态块成员才会被初始化； 数组初始化 编译器不允许指定数组的大小","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"《Java Thinking》学习笔记","slug":"《Java-Thinking》学习笔记","permalink":"http://panzeyong.com/tags/《Java-Thinking》学习笔记/"}]},{"title":"Java 集合框架：Vector（JDK 8）","slug":"Java-集合框架：Vector（JDK-8）","date":"2017-12-15T00:54:05.000Z","updated":"2017-12-23T08:23:23.000Z","comments":true,"path":"2017/12/15/Java-集合框架：Vector（JDK-8）/","link":"","permalink":"http://panzeyong.com/2017/12/15/Java-集合框架：Vector（JDK-8）/","excerpt":"","text":"一、概述Vector 底层是由数组实现，是一个动态数组，其容量能自动增长或者减少。Vector 继承 AbstractList 抽象类，实现 List、RandomAccess、Clone、java.io.Serializable 接口。其实现原理与 ArrayList 类似。 Vector 继承 AbstractList 抽象类，实现 List 接口。它是一个数组队列，提供了增删改查以及遍历等功能。 Vector 实现 RandomAccess 接口，提供快速随机访问功能。RandomAccess 接口被 List 实现主要用来支持快速随机访问，通过数组下标随机访问元素。 Vector 实现 Clone 接口，重写 Object clone() 方法可以克隆对象。 Vector 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据在网络进行传输。 Vector 允许添加所有元素，包括 null 元素。 与 ArrayList 一样，Vector 支持容量自动增长，但是增长方式与 ArrayList 略有不同。Vector 通过维护 capacity 和 capacityIncrement 这两个属性来优化其内存管理，而 capacityIncrement 是容量增长的系数，当 Vector 容量不足时，如果 capacityIncrement 为 0 的话，那么 Vector 容量扩容为原先的 2 倍（newCapacity = 2 * oldCapacity）；如果 capacityIncrement 大于 0，那么扩容后的容量为 oldCapacity + capacityIncrement。扩容的原理其实是对数组进行复制，对需要移动的元素进行移动，相当消耗性能的。如果可能的话，在实例化 Vector 的时候指定其容量。 与 ArrayList 不一样的是，Vector 是线程安全，方法实现加上 synchronized 关键字。正因为其线程安全，这就导致其在单线程下性能不如 ArrayList。如果不在多线程下使用，推荐使用 ArrayList。 Vector 是在 Java 1.2 实现 List 接口，使其成为 Java 集合框架的一员，而并不是一开始就存在的。 二、Vector 继承关系图 三、Vector 源码分析1、属性从源码可以看出，Vector 提供的属性如下： 1234567891011// 存储 Vector 包含所有元素的数组protected Object[] elementData;// Vector 所包含的元素个数protected int capacityIncrement;// Vector 容量自动增长的增量，如果小于等于 0，那么增量为原先容量的一倍protected int capacityIncrement;// 序列号版本号private static final long serialVersionUID = -2767605614048989439L; Vector 底层是由数组实现，所有元素都存储在 elementData 数组中，当 Vector 容量大于 elementData 的容量时，则需要扩容；那么到底如何扩容取决于属性 capacityIncrement 的值，如果 capacityIncrement 不为 0，那么扩容的增量就是它，即 oldCapacity + capacityIncrement；如果 capacityIncrement 小于等于 0，那么扩容的增量即为原先的一倍，即 oldCapacity + oldCapacity。至于 capacityIncrement 这个属性，则是 Vector 所包含元素的个数。 2、构造函数Vector 提供 4 个不同版本的构造函数，它们之间有着一定的联系，具体实现看下面的分析。 无参构造函数 123456/** * 构造空的 Vector，默认大小为 10，容量的增量系数为 0 */public Vector() &#123; this(10);&#125; 在无参构造函数里，调用了传一个参数的构造函数 123456789/** * 用指定的初始容量和容量增量系数为 0 构造空 Vector * * @initialCapacity vector 初始容量 * @throws 如果 initialCapacity 为负数，则抛出异常 java.lang.IllegalArgumentException */public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125; 紧接着调用带两个参数的构造函数 123456789public Vector(int initialCapacity, int capacityIncrement) &#123; super(); // 检查 initialCapacity 是否小于 0，是的话则抛出异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); // 实例化数组对象，数组大小为 initialCapacity this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125; 到这里，才真正创建初始容量为 initialCapacity 的数组对象以及指定容量增长系统 this.capacityIncrement。 构造包含指定集合所有元素的 Vector 的构造函数 12345678910111213141516/** * 构造一个包含指定集合元素的 Vector * * @param c 集合 c 中的元素添加到 Vector * @throws NullPointerException 如果指定集合为 null ，则抛出空指针 */public Vector(Collection&lt;? extends E&gt; c) &#123; // 集合 c 转换为数组赋值给数组 elementData elementData = c.toArray(); // 数组的长度 elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 转换数组返回值可能不是 Object[]，如果是这样的话，则执行下面的语句 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125; 如果看过 ArrayList 这篇文章对 ArrayList 的分析的话，那么对该方法的逻辑实现应该不陌生，而且基本一模一样，所以这里就不再做分析了。 3、添加元素Vector 提供多个添加元素版本，有将元素添加到 Vector，也有将元素添加到 Vector 指定位置，至于是怎么实现的，见下面分析。 （1）、add(Object)12345678910111213/** * 把指定元素添加到 Vector 末尾 * * @params e 添加到 Vector 元素 * @returns true */public synchronized void addElement(E e) &#123; modCount++; // 在添加元素到数组 elementData 之前检测 elementData 容量是否满足 ensureCapacityHelper(elementCount + 1); // 将元素 e 添加到数组 elementData elementData[elementCount++] = e;&#125; 看第 10 行代码方法 ensureCapacityHelper(elementCount + 1) 的具体实现 12345678910/** * 这实现了 ensureCapacity 的非同步语义。此类中的同步方法可以在内部调用 * 此方法来确保容量，而不会产生额外同步的代价。 */private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;&#125; 这里假设数组 elementData 已经添加了 10 个元素，容量等于初始容量，现在要再添加 1 一个新元素，也就是说，传给方法 ensureCapacityHelper(int minCapacity) 的参数 minCapacity 值为 11，那么来第 3 行代码，显示条件是成立的，第 4 行代码被执行，看下具体实现 12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code // 保存扩容前数组的容量 int oldCapacity = elementData.length; // 根据 capacityIncrement 的值来决定扩容。这里假设 capacityIncrement 为 0，那么增加的容量是原来的一倍，即 newCapacity = 2 * oldCapacity int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 复制源数组到目标数组，实现扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 到这里，应该终于知道前面为何一直扩容取决于属性 capacityIncrement，答案在第 6 行代码。第 12 行代码实现扩容操作，最终调用 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));，而该方法是 native 方法，在底层实现对数组复制操作，对需要移动的元素进行移动，从而实现了扩容操作。 （2）、add(int index, E element)12345678910/** * 在 Vector 指定的位置插入指定的元素，将当前位置的元素（如果有的话）和任何随后的元素移动到右侧（在其索引中增加 1） * * @params index 指定的元素将被插入的索引 * @params element 将被插入的元素 * @throws 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException */public void add(int index, E element) &#123; insertElementAt(element, index);&#125; 看第 9 行代码的具体实现 12345678910111213141516171819202122232425262728293031/** * 将指定的对象作为 Vector 的组件插入到 Vector 指定的索引；此 Vector * 每个具有大于或者等于指定索引的索引的组件都需要向右移动，以使其大于先前 * 的索引值。 * * 索引必须是大于 0 并且小于或等于当前 Vector 的大小（如果索引等于当前 * Vector 的大小，那么则将新元素插入到 Vector 尾）。 * * 此方法与 add(int，E) 方法（它是 List 接口的一部分）的功能相同。 * 请注意，add 方法颠倒了参数的顺序，以更贴近地匹配数组的用法。 * * @params obj 插入组件 * @params index 插入新组件的索引 * @throws 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized void insertElementAt(E obj, int index) &#123; // Vector 结构发生改变，插入属性 modCount 会加 1 modCount++; // 检查 index 是否越界 if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; // 在添加元素之前检查容量，不满足的话则扩容 ensureCapacityHelper(elementCount + 1); // 将源数组需要移动的元素移到目标数组 System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); // 在指定索引插入元素 elementData[index] = obj; // 数组大小加 1 elementCount++;&#125; 实现逻辑不是很复杂，将指定的对象作为 Vector 的组件插入到 Vector 指定的索引。第 20 ~ 22 行代码检查数组是否越界；第 24 行代码检查容量是否满足，具体分析上面已经分析过；第 25 行代码实现对数组的复制，换句话说，即对需要的移动的元素进行移动。那么至于是如何移动元素的，看下面图解 （3）、addAll(Collection)1234567891011121314151617181920/** * 将指定集合中包含的所有元素插入到 Vector 尾 * * @params 插入到 Vector 的元素 * @returns true * @throws 如果指定的集合 c 是 null，则抛出异常 java.lang.NullPointerException */public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; // 指定集合转换为数组 Object[] a = c.toArray(); int numNew = a.length; // 在插入元素之前检查容量是否满足 ensureCapacityHelper(elementCount + numNew); // 把指定集合 c 包含的元素插入到 Vector 尾 System.arraycopy(a, 0, elementData, elementCount, numNew); // 更新 elementData 数组的大小 elementCount += numNew; return numNew != 0;&#125; 该方法实现逻辑与 add(Object) 类似，区别只在于 allAll(Collection) 往 Vector 添加多个元素，而 add(Object) 值添加一个元素。至于具体分析细节可参考 add(Object) 方法。 （4）、addAll(int, Collection)1234567891011121314151617181920212223242526272829/** * 将指定集合中的所有元素插入到指定位置 Vector 中。将当前位置的元素（如果有的话）和随后的元素移动到右侧（增加它们的索引） * * @params index 在 index 插入指定集合的第一个元素 * @params c 插入到 Vector 的元素 * @returns true * @throws 如果指定的集合 c 是 null，则抛出异常 java.lang.NullPointerException * @throws 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; // 检查 index 是否越界 if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); // 指定集合转换为数组 Object[] a = c.toArray(); int numNew = a.length; // 在插入元素之前检查容量是否满足 ensureCapacityHelper(elementCount + numNew); // 需要移动元素个数 int numMoved = elementCount - index; // 对需要移动的元素进行移动，即复制到目标数组 if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将指定集合包含的元素插入到 Vector System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0;&#125; 该方法的功能是在 Vector 指定位置插入指定集合包含的所有元素，这就需要对元素进行移动，即将源数组的元素复制到目标数组，那么至于是怎么移动的呢，来看下图解 （5）、addElement(E obj)12345678910/** * 将指定组件添加到 Vector 尾，其大小增加 1。如果 Vector 的大小大于其容量，那么它的容量就会增加。 * * @params obj 添加组件 */public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 该方法等价于方法 add(Object)，实现逻辑基本相同，可参考以上分析。 4、删除元素同样，Vector 也提供多个版本删除元素，开发者可以根据自己的需求调用不同的 API，那么来看下它们的具体实现。 (1)、remove(Object)1234567891011/** * 删除 Vector 第一个与指定元素 o 相同的元素，如果 Vector 不包含指定元 * 素 o，则不发生改变。换句话说，移除最小索引 i 的元素 * (o==null ? get(i)==null : o.equals(get(i)))（指定元素存在的情况下） * * @params 从 Vector 移除的元素（指定元素存在的情况下） * @returns 如果 Vector 包含指定元素的话，则返回 true */public boolean remove(Object o) &#123; return removeElement(o);&#125; 看第 10 行代码的源码实现 123456789101112131415161718/** * 从 Vector 移除与参数匹配的第一个元素，如果 Vector 包含该对象， * 则 Vector 索引大于或等于该对象索引的元素都需要向左移动， * 使其索引比之前小。该方法等价于 remove(Object) * * @params obj 被移除组件 * @returns 如果 Vector 包含指定组件，返回 true；否则返回 false */public synchronized boolean removeElement(Object obj) &#123; modCount++; // 搜索指定元素在 Vector 出现的索引，存在的返回大于等于 0 的数；否则返回 -1 int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125; 首先调用方法 indexOf(Object) 遍历指定元素在 Vector 中第一次出现的索引，如果存在的话的返回指定元素在 Vector 的索引，否则返回 -1；那么接下来看下是如何遍历的 1234567891011/** * 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素， * 则返回 -1。更通常地来说，返回最低索引 i，使得 (o==null ? * get(i)==null : o.equals(get(i)))，如果不存在的话则返回 -1。 * * @params o 搜索的元素 * @returns 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，则返回 -1。 */public int indexOf(Object o) &#123; return indexOf(o, 0);&#125; 紧接着又调用方法 indexOf(Object, int)，源码实现如下： 123456789101112131415161718192021222324/** * 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素， * 则返回 -1。更通常地来说，返回最低索引 i，使得 (i &gt;= index &amp;&amp; * (o==null ? get(i)==null : o.equals(get(i))))， * 如果不存在的话则返回 -1。 * * @params o 搜索的元素 * @params index 从 Vector 开始搜索的索引 * @returns 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，则返回 -1。 * * @throws 如果指定索引是负数的话，则抛出 java.lang.IndexOutOfBoundsException */public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 首先判断指定搜索元素 o 是否为 null，如果为 null 的话，则执行第 14 - 16 行代码，即遍历数组 elementData 是否存在 null 元素，存在的话返回其索引，否则返回 -1；如果 o 不为 null 的话，则执行第 18 - 20 行代码，即遍历数组 elementData 是否存在该元素，存在的话则返回其索引，否则返回 -1。 回到方法 removeElement(Object)，假设 Vector 包含指定元素，调用方法 indexOf(Object) 的索引大于等于 0，那么将会执行第 13 - 16 行，即执行移除指定元素操作，真正执行该操作的方法是 removeElementAt(int)，具体实现如下： 1234567891011121314151617181920212223242526272829/** * 删除指定索引的组件。此时 Vector 中每个大于或等于指定索引的索引的组件 * 需要向左移动，以使其索引小于先前的值。Vector 的大小减 1。 * 索引值必须是大于等于 0，并且小于当前 Vector 的大小。 * 该方法功能与 remvoe(int) 一样，但是需要注意的一点是 remove(int) 返回存储在指定位置的旧值。 * * @params index 删除对象的索引 * @throws 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized void removeElementAt(int index) &#123; modCount++; // 检查 index 是否越界 if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; // 需要移动元素的个数 int j = elementCount - index - 1; // 对需要移动的元素进行移动，即从源数组复制到指定位置的目标数组 if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; // elementData 大小减少 1 elementCount--; // 将被移除元素腾出来的空间置 null，释放资源 elementData[elementCount] = null; /* to let gc do its work */&#125; 理解了如何在 Vector 指定位置添加元素后，再来理解如何在 Vector 指定位置删除元素应该很容易的，同样是需要对部分元素进行移动的，其实就是从源数组复制到指定位置的目标数组，通过图解加深理解 (2)、remove(int)123456789101112131415161718192021222324/** * 删除 Vector 指定位置的元素，将指定元素随后的元素向左移动， * 返回从 Vector 删除的元素。 * * @params index 删除元素索引 * @returns 被删除的元素 * @throws 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;&#125; 该方法基本与 removeElementAt(int) 等价，但是有点区别的是该方法有返回值，即返回被删除的元素；而 removeElementAt(int) 没有返回值。 （3）、removeAllElements()123456789101112/** * 移除 Vector 所有组件以及设置其 size 为 0。 * 功能等价于方法 clear() */public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0;&#125; 实现逻辑很简单，就不再分析了。 （4）、removeRange(int fromIndex, int toIndex)123456789101112131415161718/** * 从 Vector 删除所用介于 fromIndex（包括）和 toIndex（不包括）之间的所有元素。 * 将任何后续的元素向左移动（索引减 1）。通过调用 （toIndex - fromIndex）来缩短 Vector（如果 toIndex == fromIndex），此操作无效。 */protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; // 需要移动元素个数 int numMoved = elementCount - toIndex; // 将源数组复制到指定位置的目标数组 System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work // 释放资源 int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125;&#125; 相信理解了以上方法之后，对该方法也不难理解。在这里只是列出来而已，让大家知道有这个方法。 5、修改元素对于修改元素，Vector 提供两个版本，区别在于是否有返回值。 （1）、set(int, E)1234567891011121314151617/** * 用指定的元素替换 Vector 指定位置的元素 * * @params index 要替换元素的索引 * @params element 元素存储在指定的位置 * @returns 之前在指定位置的元素 * @throws 如果索引越界（index &lt; 0 || index &gt; size）， * 则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 首先检查 index 是否越界，是的话就抛出异常；否则继续执行。保存 Vector 指定位置元素的值作为返回值返回，接着修改指定位置 index 的值。 (2)、setElementAt(E obj, int index)1234567891011121314151617/** * 将 Vector 指定索引的组件设置为指定的对象，该位置原先的组件被丢弃。 * 索引必须是大于或等于0的值，并且小于矢量的当前大小。 * 此方法功能与 set(int, E) 相同。注意 set 方法颠倒参数顺序，以更接近数组的使用。还有一点区别的是 set 方法返回存储在指定位置的旧值。 * * @params obj 替换 Vector 指定位置的新值 * @params index 指定索引 * @throws 如果索引越界（index &lt; 0 || index &gt; size）， * 则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; elementData[index] = obj;&#125; 6、查询元素对于查询元素，Vector 提供多个版本，由于实现 RandomAccess 接口，因此具有随机快速访问元素功能，即通过索引快速访问元素，Vector 查询元素都是通过索引访问元素实现的。 （1）、elementAt(int)12345678910111213141516/** * 返回指定索引的组件。 * 该方法功能与 get(int) 相同 * * @params index Vector 索引 * @returns 指定索引的组件 * @throws 如果索引越界（index &lt; 0 || index &gt; size）， * 则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; return elementData(index);&#125; (2)、elementData(int)1234@SuppressWarnings(\"unchecked\")E elementData(int index) &#123; return (E) elementData[index];&#125; (3)、get(int)12345678910111213/** * 返回 Vector 指定位置的元素 * * @params index 返回元素的索引 * @returns 指定索引的对象 * @throws 如果索引越界（index &lt; 0 || index &gt; size）， * 则抛出 java.lang.ArrayIndexOutOfBoundsException */public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; （4）、firstElement()12345678910111213/** * 返回 Vector 第一个组件 * * @returns 返回 Vector 第一个组件 * @thorws 如果 Vector 没有组件，则抛出异常 NoSuchElementException */public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0);&#125; （5）、lastElement()123456789101112/** * 返回 Vector 最后一个组件 * * @returns Vector 最后一个组件 * @thorws 如果 Vector 没有组件，则抛出异常 NoSuchElementException */public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1);&#125; 7、遍历元素对于遍历元素，Vector 提供多个版本，每个版本执行的效率有所差别。我们先来理解源码实现，然后再通过例子加以说明。 (1)、elements()123456789101112131415161718192021222324/** * 返回 Vector 中所有组件对应的 Enumeration。被返回的 Enumeration 生成 Vector 中所有的组件。 * * @returns Vector 中组件的枚举 */public Enumeration&lt;E&gt; elements() &#123; return new Enumeration&lt;E&gt;() &#123; int count = 0; public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(\"Vector Enumeration\"); &#125; &#125;;&#125; elements() 方法返回一个 Enumeration 对象，而 Enumeration 是一个接口，在方法 elements() 实现 Enumeration 两个方法：hasMoreElements() 和 nextElement()。对于方法 hasMoreElements() 是判断是否还有下一个元素；而 nextElement() 遍历整个 Vector，返回下一个元素。 （2）、iterator()1234567/** * 以合适的顺序返回 Vector 中元素的迭代器。 * 返回的迭代器是 fail-fast（“快速失败”机制）。 */public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 创建类 Itr 对象并返回，即返回 Iterator 对象，类 Itr 实现 Iterator 接口，并实现该接口中的方法 hasNext()、next()、remove()、forEachRemaining(Consumer)，以下给出该类的源码，以供理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; // 判断是否还有下一个元素 public boolean hasNext() &#123; // Racy but within spec, since modifications are checked // within or after synchronization in next/previous return cursor != elementCount; &#125; // 返回下一个元素 public E next() &#123; synchronized (Vector.this) &#123; checkForComodification(); int i = cursor; if (i &gt;= elementCount) throw new NoSuchElementException(); cursor = i + 1; return elementData(lastRet = i); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); synchronized (Vector.this) &#123; checkForComodification(); Vector.this.remove(lastRet); expectedModCount = modCount; &#125; cursor = lastRet; lastRet = -1; &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); synchronized (Vector.this) &#123; final int size = elementCount; int i = cursor; if (i &gt;= size) &#123; return; &#125; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) Vector.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; action.accept(elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; （3）、通过索引随机快速访问（4）、foreach 增强循环遍历访问（5）、例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.Enumeration;import java.util.Iterator;import java.util.Vector;public class VectorTraverseDemo &#123; private static Vector&lt;Integer&gt; vector; private static int MAX = 999; private static void init () &#123; vector = new Vector(); for (int i = 0; i &lt; MAX; i++) &#123; vector.add(i); &#125; &#125; /** * 调用方法 elements() 遍历 Vector 元素 */ private static void elementsAccess() &#123; long startTime = System.currentTimeMillis(); Enumeration enumeration = vector.elements(); while(enumeration.hasMoreElements()) &#123; enumeration.nextElement(); &#125; long endTime = System.currentTimeMillis(); long time = endTime - startTime; System.out.println(\"Elements() Method Access Time: \" + time + \"ms\"); &#125; /** * 调用 iterator() 方法遍历 Vector 元素 */ private static void iteratorAccess() &#123; long startTime = System.currentTimeMillis(); Iterator iterator = vector.iterator(); while(iterator.hasNext()) &#123; iterator.next(); &#125; long endTime = System.currentTimeMillis(); long time = endTime - startTime; System.out.println(\"Iterator() Method Access Time: \" + time + \"ms\"); &#125; /** * foreach 增强循环遍历 Vector 元素 */ private static void foreachAccess() &#123; long startTime = System.currentTimeMillis(); for (int item : vector) &#123; int i = item; &#125; long endTime = System.currentTimeMillis(); long time = endTime - startTime; System.out.println(\"Foreach Access Time: \" + time + \"ms\"); &#125; private static void randomAccess() &#123; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; long endTime = System.currentTimeMillis(); long time = endTime - startTime; System.out.println(\"Random Access Time: \" + time + \"ms\"); &#125; public static void main(String[] args) &#123; init(); elementsAccess(); iteratorAccess(); foreachAccess(); randomAccess(); &#125; &#125; 运行结果 123456789101112131415161718192021222324252627282930313233MAX = 999Elements() Method Access Time: 0 msIterator() Method Access Time: 0 msForeach Access Time: 0 msRandom Access Time: 1 ms-----------------------------------MAX = 9999Elements() Method Access Time: 1 msIterator() Method Access Time: 1 msForeach Access Time: 1 msRandom Access Time: 0 ms-----------------------------------MAX = 99999Elements() Method Access Time: 5 msIterator() Method Access Time: 6 msForeach Access Time: 7 msRandom Access Time: 7 ms-----------------------------------MAX = 999999Elements() Method Access Time: 28 msIterator() Method Access Time: 29 msForeach Access Time: 31 msRandom Access Time: 50 ms-----------------------------------MAX = 9999999Elements() Method Access Time: 270 msIterator() Method Access Time: 266 msForeach Access Time: 265 msRandom Access Time: 513 ms 从运行结果可以看出，随着数据量不断递增，不同的遍历方式的效率渐趋明显；而对于数量小的话，遍历效率基本相同。 8、判断 Vector 是否包含指定元素12345678910/** * 如果 Vector 包含指定元素，那么返回 true。换句话说， * 当且仅当 Vector 至少包含一个元素 e，使得 (o==null ? e==null : o.equals(e))。 * * @params o 搜索的元素 * @returns 如果 Vector 包含指定元素，那么返回 true。 */public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0;&#125; 看到第 9 行代码，应该很熟悉吧，见上面分析。 9、判断 Vector 的大小是否 012345678/** * 判断 Vector 是否不包含任何组件。 * * @returns 有且仅当 Vector 不包含任何组件时返回 true，换句话说，size 为 0；否则返回 false。 */public synchronized boolean isEmpty() &#123; return elementCount == 0;&#125; 10、获取 Vector 大小12345678/** * 返回 Vector 包含组件的数量 * * @returns 返回 Vector 包含组件的数量 */public synchronized int size() &#123; return elementCount;&#125; 11、改变 Vector 大小1234567891011121314151617/** * 设置 Vector 的大小。如果新的大小比当前大小大的话，那么将创建 null 添加到 Vector 末尾；如果新的大小比当前大小小的话，那么 Vector 索引为 newSize 以及之后的索引将被置为 null。 * * @params newSize Vector 新大小 * @throws 如果 newSize 是负数，那么抛出异常 java.lang.ArrayIndexOutOfBoundsException */public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125; 如果 newSize 当前数组 elementData 容量大的话，那么执行第 10 行代码，很眼熟吧，即对 Vector 进行扩容，在Vector 尾添加 （newSize - elementCount） null 元素；如果小的话，那么执行第 12 - 14 行代码，即将Vector 索引为 newSize 及之后索引的元素置 null。 12、获取 Vector 容量12345678/** * 返回 Vector 当前容量 * * @returns 当前容量（内部数组 elementData 的长度） */public synchronized int capacity() &#123; return elementData.length;&#125; 四、小结 Vector 底层是基于数组实现的，是一个动态数组； Vector 允许添加所有元素，包括 null 元素； Vector 是线程安全； Vector 实现 RandomAccess 接口，支持通过索引随机快速访问元素； Vector 支持容量自增长，通过 capacity 和 capacityIncrement 这两个属性来维护。容量增长的机制如下：当增长系数 capacityIncrement 大于 0 时，那么 Vector 增加的容量为增长系数 capacityIncrement，扩容后的容量为 oldCapacity + capacityIncrement；如果增长系数 capacityIncrement 等于 0，那么 Vector 增加的容量为原来的一倍，扩容后的容量为 oldCapacity * 2。 五、Vector 与 ArrayList 区别不同点相同点Vector同步、线程安全1、底层基于数组实现，是一个动态数组； 2、继承抽象类 AbstractList，实现 List 接口，提供增删改查以及遍历功能；3、实现 RandomAccess 接口，支持随机快速访问元素功能； 4、实现接口 java.io.Serializable，支持序列化和反序列化； 5、实现接口 Clone，支持克隆对象； 6、允许添加任何元素，包括 null 元素容量扩容根据增长系数 capacityIncrement 支持 Enumeration、foreach、iterator、for 遍历需要额外开销来维护同步锁，性能慢ArrayList异步、线程不安全容量扩容为旧容量的 1.5 倍支持 foreach、iterator、for 遍历不需要额外开销来维护同步锁，性能快 以上是自己对 Vector 的初始，由于水平有限，如果文中有错误的，欢迎指出！","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"Java 集合框架","slug":"Java-集合框架","permalink":"http://panzeyong.com/tags/Java-集合框架/"}]},{"title":"Java 集合框架：LinkedList（JDK 8）","slug":"Java-集合框架：LinkedList","date":"2017-12-06T00:41:35.000Z","updated":"2017-12-12T01:12:52.000Z","comments":true,"path":"2017/12/06/Java-集合框架：LinkedList/","link":"","permalink":"http://panzeyong.com/2017/12/06/Java-集合框架：LinkedList/","excerpt":"","text":"一、概述LinkedList 底层实现基于双向链表，除了可以当作链表使用外，LinkedList 还可以当作栈、队列和双端队列使用，其原因是实现 List 和 Deque 接口。LinkedList 继承于抽象类 AbstractSequentialList，实现 List、Deque、Cloneable、java.io.Serializable 接口。 LinkedList 继承于抽象类 AbstractSequentialList，实现 List 接口，可以对队列进行基本操作，提供了增删改查以及遍历等功能。 LinkedList 实现 Clone 接口，重写 Object clone() 方法可以克隆对象。 LinkedList 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据传输。 LinkedList 实现 Deque 接口，而 Deque 接口是一个线性集合，支持元素在两端进行插入和移除，它有个名称叫作双端队列。Deque 实现既支持限制容量又支持不限制容量；提供的方法都可以从两端对元素进行操作，被提供的方法主要用于 insert、remove 和 examine 元素。这些方法存在两种形式：一种是操作失败时抛出异常；一种是返回一个特定值（null 或者 false，取决于具体操作）。对于这些操作，Deque 提供 12 个方法，具体如下表： First Element (Head)Last Element (Tail)Throws exceptionSpecial ValueThrows exceptionSpecial ValueInsertaddFirst(e)offerFirst(e)addLast(e)offerLast(e)RemoveremoveFirst()pollFirst()removeLast()pollLastExaminegetFirst()peekFirst()getLast()peekLast() Deque 接口继承 Queue，可以当作队列使用，而队列是一种先进先出（FIFO）的数据结构，即元素可以从队列的一端插入，从另一端移除。从 Queue 继承的方法与 Deque 实现的方法完全等价，如下表： Queue MethodEquivalent Deque Methodadd(e)addLast(e)offer(e)offerLast(e)remove()removeFirst()poll()pollFirst()element()getFirst()peek()peekFirst() Deque 也可以当作栈使用，而栈是一种后进先出（LIFO）的数据结构，即元素只能从 Deque 一端插入，并且从这端移除。从 Stack 继承的方法与 Deque 实现的方法完全等价，如下表： Stack MethodEquivalent Deque Methodpush(e)addFirst(e)pop()removeFirst()peek()peekFirst() LinkedList 允许添加所有元素，包括 null 元素。 LinkedList 是线程不安全，只能在单线程环境下工作；如果要在多线程环境下工作，则可以使用 Collections.synchronizedList 创建 List，返回线程安全 LinkedList 实例 1List list = Collections.synchronizedList(new LinkedList(...)); 从上面对 LinkedList 的介绍可知，LinkedList 的底层实现涉及到双向链表、栈、队列、双端队列这四种数据结构；为了能更好地理解其原理，简单来介绍链表、栈、队列、双端队列这四种数据结构。 二、链表、栈、队列和双端队列（补充知识点）1、链表（来源）链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。 链表有很多种不同类型：单向链表、单向循环链表、双向链表、双向循环链表。下面通过图解加深理解。 单向链表：单向链表是链表中最简单的一种。链表是由各个节点串起来而组成的，不同种类型链表的节点所包含的域不同。对于单向链表而言，每个节点包含两个域：数据域和指针域。数据域所要存放的是这个节点的内容，比如基本数据类型、引用类型以及自定义类型；而指针域存放的是下一个节点的内存地址。一般来说，在一个固定的位置保存着指向第一个节点的指针；最后一个节点的指针域保存着一个特殊的标记。 单向循环链表：单向循环链表是在单向链表的基础上，将最后一个节点的指针域指向第一个节点，就构成了单向循环链表。 双向链表：与单向链表相比，双向链表更复杂些。双向链表包含三个域：两个指针域和一个数据域。在这两个指针域中，一个指针域（pre）存放的是前一个节点的内存地址，被指向的节点称为前驱节点；另一个指针域（next）存放的是后一个节点的内存地址，被指向的节点称为后继节点；而数据域存放的是该节点的内容。一般来说，第一个节点的 pre 指针指向 null，最后一个节点的 next 指针指向 null。 双向循环链表：双向循环链表是在双向链表的基础上，将第一个节点的 pre 指针指向最后一个节点，最后一个节点的 next 指向第一个节点，形成一个环，构成双向循环链表。 2、栈栈是一种简单的数据结构，在计算机科学中有着广泛的应用。栈（stack）是限定仅在表尾进行插入和删除操作的线性表。因此，对于栈来说，表尾端有其特殊含义，称为栈顶（top）；相应地，表头端称为栈底（bottom）。不含元素的空表称为空栈。 由于栈只局限于在一端进行操作，因此使它具有后进先出（Last In First Out）的特点。这特点在生活中是很常见的，比如往一个箱子装书，当把箱子装满时，这时如果要取最后一本书或者倒数第二本书，都必须得把前面的书拿出来，才能拿到自己想要的书。除此之外，除了头尾节点外，每一个节点都有一个前驱节点和一个后继节点。 3、队列（来源）队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（队尾，称为 rear）进行插入操作，在前端（队头，称为 front）进行删除操作。 4、双端队列双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称作端点 1 和端点 2。 基础知识简单介绍完了，可以开始源码分析之旅了。 三、LinkedList 继承关系图 四、LinkedList 源码分析由于 LinkedList 底层实现的灵活性，既可以当作双向链表使用，也可以当作栈、队列和双端队列使用，因此对于源码的分析将分开讲解。 （一）、LinkedList 基于双向链表实现1、属性从 LinkedList 源码实现来看，就提供 3 个属性，分别如下： 12345transient int size = 0;transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; 很明显可以注意到，这三个属性前面都有 transient 修饰，那么 transient 是什么呢？有什么作用呢？其实 transient 是 Java 中的一个关键字，只能用来修饰变量，不能修饰类和方法；作用是被修饰的变量不是对象持久化的一部分，换句话说，被 transient 修饰的变量不能被序列化。由于 LinkedList 实现 java.io.Serializable 接口，对象可以被序列化，但是对于属性 size、first、last 不想被序列化，就在前面加了关键字 transient。 接下来简单说下这三个属性的具体作用。属性 size 表示 list 的长度，即节点的个数；属性 first 表示指向链表第一个节点；last 表示指向链表最后一个节点。 2、构造函数LinkedList 提供两个构造函数，一个无参构造函数和一个有参构造函数，分别如下： 无惨构造函数 12345/** * 构造空列表 */public LinkedList() &#123;&#125; 有参构造函数 12345678910111213/** * 将包含指定元素的集合 c 添加到 list * * @param c 包含指定元素的集合 * @throws 如果指定的集合是 null，那么将抛出 NullPointerException*/public LinkedList(Collection&lt;? extends E&gt; c) &#123; // 调用无惨构造方法 this(); // 将集合的所有元素添加到 list，具体分析见下面 addAll(c);&#125; 3、静态内部类 Node &lt;E&gt;本来是要直接分析如何添加元素的，但是看了源码后，发现 Node 这个类贯穿 LinkedList 的整个实现，所以有必要先讲下。源码实现如下： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node 是一个静态内部类，采用泛型，表示的是双向链表中每个节点的数据结构。也就是说，每个节点包含三个域，一个数据域和两个指针域，数据域存储的是当前节点的内容（item），而指针域一个存放的是当前节点的前一个节点（前驱节点 prev）的内存地址，另一个指针域存放的是当前节点的后一个节点（后继节点 next）的内存地址。 4、添加元素LinkedList 提供多个版本添加元素，有添加单个元素的，在指定位置添加元素或者添加集合包含的元素。至于具体如何实现，下面一一分析。 (1)、添加单个元素12345678910/** * 将指定元素添加到 list 末尾 * * @param 被添加到 list 元素 * @return true*/public boolean add(E e) &#123; linkLast(e); return true;&#125; 接着看 linkLast(e) 的具体实现： 123456789101112131415161718192021/** * 添加元素到链表末尾*/void linkLast(E e) &#123; // 将最后一个节点 last 保存到变量 l final Node&lt;E&gt; l = last; // 创建新节点 newNode，l 作为新节点的前驱节点（前一个节点） final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // last 指向新节点 newNode，即新节点 newNode 作为最后一个节点 last last = newNode; if (l == null) &#123; // 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点 first = newNode; &#125; else &#123; // 链表不为空表，将新节点 newNode 插入到链表末尾，l 的下一个节点指向新节点 newNode l.next = newNode; &#125; // 链表节点数加 1 size++; modCount++;&#125; 以上给出了详细的注释，其余就不多说了。接下来通过图解来理解链表不为空表时是如何将指定元素添加到链表末尾，如下图： （2）、在双向链表指定位置添加新元素123456789101112public void add(int index, E element) &#123; // 检查 index 是否越界，注意 index 是从 0 开始的 checkPositionIndex(index); if (index == size) &#123; // 双向链表是空表或者在双向链表末尾添加新元素，linkLast(element) 方法分析见上 linkLast(element); &#125; else &#123; // 在双向链表指定的位置添加新元素 linkBefore(element, node(index)); &#125; &#125; 第 10 行代码将指定的元素添加到双向链表指定的位置，在添加新元素之前必须找到index 所指向的节点，即方法 node(index)。具体实现如下： 123456789101112131415161718Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 采用一次二分法查找元素，size &gt;&gt; 1 相当于 size / 2 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) &#123; x = x.next; &#125; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) &#123; x = x.prev; &#125; return x; &#125;&#125; 从方法 node(int) 源代码可以看出，LinkedList 通过索引 index 访问元素是遍历整个链表，不像 ArrayList 可以随机访问元素。在这里采用一次二分法查找元素，同样也要遍历元素，只不过是遍历元素的个数为原先的一半。如果 index 在前半部分，则从头开始遍历；如果 index 在后半部分，则从尾开始遍历；最后将查找的节点返回。 回到方法 add(int, E)，再看第 10 行代码，将参数 index 和调用方法 node(int) 返回的节点传给方法 linkBefore(int, Node)，该方法的具体实现如下： 1234567891011121314151617181920void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 将通过 index 遍历查找到的节点 succ 的前驱节点（前一个节点）prev 赋值给 pred final Node&lt;E&gt; pred = succ.prev; // 创建新节点 newNode，pred 作为 newNode 前驱节点，succ 作为 newNode 的后继节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // succ 的 prev 指向新节点 newNode succ.prev = newNode; if (pred == null) &#123; // 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点 first = newNode; &#125; else &#123; // pred 的 next 指向新节点 newNode pred.next = newNode; &#125; // 双向链表的个数加 1 size++; modCount++;&#125; 通过注释不难理解该方法的实现逻辑，下面通过图解加深对该方法的理解，如下图： (3)、将集合包含的元素添加到双向列表中12345678910/** * 将集合包含指定的所有元素添加到双向列表末尾 * * @param c 包含指定元素的集合 * @return 添加成功返回 true * @throws c 为 null 抛出异常 NullPointerException */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; 就一行代码，调用 add(int, Collection&lt;? extends E&gt;)，看下具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 将指定集合中的所有元素插入到列表中，从指定的位置开始。将当前在该位置的 * 元素（如果有的话）和随后的元素移到右侧（增加它们的索引）。新元素将按照 * 指定集合的​​迭代器返回的顺序出现在列表中。 * * @param index 插入到列表起始位置 * @return 成功插入时返回 true * @throws IndexOutOfBoundsException * @throws c 为 null 抛出异常 NullPointerException */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查 index 是否越界 checkPositionIndex(index); // 将集合 c 转换为数组 Object[] a = c.toArray(); // 集合元素的个数 int numNew = a.length; // 集合元素个数为 0，返回 false if (numNew == 0) return false; // 定义前驱节点 pred 和后继节点 succ Node&lt;E&gt; pred, succ; // 判断是从列表的末尾插入还是某个位置 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; // 遍历数组中元素，创建新节点，并指定新节点的前驱节点和后继节点，然后插入到列表 for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 相信通过以上注释不难理解该方法的实现逻辑。该方法实现逻辑将集合中指定的元素插入到列表有种情况：一种是从列表的末尾插入，另一种是从列表的某个位置插入，这与上面所讲解两个添加元素的方法的原理是一样的，区别只在于是添加单个元素还是添加多个元素，如何插入到链表中参考以上两个方法的图解。 5、删除元素LinkedList 也提供好多个版本删除元素，下面一一来看具体实现。 （1）、删除元素123456789/** * 检索和删除列表第一个元素 * * @return 返回 list 第一个元素 * @throws 如果列表是空的抛出 NoSuchElementException */public E remove() &#123; return removeFirst();&#125; 接着看 removeFirst() 具体实现 12345678910111213/** * 移除并返回列表第一个元素 * * @return 从列表返回的第一个元素 * @throws 如果列表是空的抛出 NoSuchElementException */public E removeFirst() &#123; // 保存 list 第一个节点到变量 f，并作为参数传给 unlinkFirst(Node&lt;E&gt;) final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; 再看方法 unlinkFirst(Node) 具体实现 1234567891011121314151617181920212223private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; // 保存 f 的 item 到变量 element，并作为返回值返回 final E element = f.item; // 保存 f 的下一个节点到变量 next final Node&lt;E&gt; next = f.next; // 释放资源，f 的 item 和 next 置 null f.item = null; f.next = null; // help GC // first 指针指向被删除第一个节点的下一个节点 next first = next; if (next == null) &#123; // 列表只有一个元素的情况下 last = null; &#125; else &#123; // list 第一个节点的 prev 指向 null next.prev = null; &#125; // 列表的节点数加 1 size--; modCount++; return element;&#125; 对于删除 list 第一个节点的实现逻辑也挺简单的。简单来说就是先把第一个节点 first 的数据域和指针域保存起来，然后置空，释放资源；如果列表元素个数大于 1 的话，将 first 指针移动到下一个元素，并重新对 first 节点的 prev 进行设置。 （2）、删除列表中指定位置的元素12345678910111213/** * 删除列表中指定位置的元素，返回从列表被删除的元素 * * @param index 被移除元素的索引 * @return 返回指定位置的元素 * @throws IndexOutOfBoundsException */public E remove(int index) &#123; // 检查 index 是否越界 checkElementIndex(index); // 调用 node(int) 方法查找要删除的元素 return unlink(node(index));&#125; 这个方法的实现也挺简单的，核心实现是第 2 行代码，看方法 unlink(Node) 具体实现： 1234567891011121314151617181920212223242526272829303132E unlink(Node&lt;E&gt; x) &#123; // assert x != null; // 保存被删除元素的数据域 item 和指针域 next、prev final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; // 判断被删除节点是否是第一个节点，然后作出相应的实现 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; // 释放资源，将被删除节点 x 的 prev 置 null x.prev = null; &#125; // 判断被删除节点是否是最后一个节点，然后作出相应的实现 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; // 释放资源，将被删除节点 x 的 next 置 null x.next = null; &#125; // 释放资源，将被删除节点 x 的 item 置 null x.item = null; // 列表的节点数减 1 size--; modCount++; return element;&#125; 该方法的实现同样也先保存被删除节点的数据域和指针域，然后判断该节点时列表的第一个节点还是最后一个节点或者是在列表个数之间的节点，作出相应的处理。对于删除第一个节点或者最后一个节点稍微比较简单，不再作出分析。对于删除位于列表之间的节点，通过图解加深理解，如下图： （3）、检索并删除元素123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 从源码可以看出，首先判断要删除的元素 o 是否为 null，如果为 null 的话，遍历列表是否存在空元素，存在的则调用 unlink(Node) 方法删除元素并返回 true；不为 null 的话也是遍历列表是否存在该元素，存在的话则调用 unlink(Node) 方法删除元素并返回 true。至于 unlink(Node) 是如何实现的看上面分析。 6、修改元素LinkedList 提供修改列表元素的方法，具体实现如下： 12345678910111213141516171819/** * 用指定的元素替换此列表中指定位置的元素。 * * @param index 要替换的元素的索引 * @param element 元素存储子在的指定位置 * @return 返回被替换的元素 * @throws IndexOutOfBoundsException */public E set(int index, E element) &#123; // 检查 index 是否越界 checkElementIndex(index); // 遍历列表查找索引为 index 的节点 Node&lt;E&gt; x = node(index); // 保存被替换元素到变量 oldVal，并作为返回值返回 E oldVal = x.item; // 修改元素的值 x.item = element; return oldVal;&#125; 实现逻辑挺简单的，就不再作分析了。 7、查询元素对于查询列表元素，LinkedList 提供通过索引检索元素的方法。 12345678910111213/** * 返回列表中指定位置的元素 * * @param index 要返回的元素的索引 * @return 返回列表中指定位置的元素 * @throws IndexOutOfBoundsException */public E get(int index) &#123; // 检查 index 是否越界 checkElementIndex(index); // 遍历列表查找索引为 index 的节点并获取其 item 作为返回值返回 return node(index).item;&#125; 8、清空列表1234567891011121314151617public void clear() &#123; // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; 清空整个列表，简单来说就是遍历整个列表，把每个节点的三个域：数据域和两个指针域置 null，并且将 first 和 last 置 null，列表长度 size 为 0。 9、判断列表是否包含指定的元素123456789/** * 如果列表包含指定元素，则返回 true * * @param o 检查元素是否存在于列表 * @return 如果列表包含指定元素，则返回 true */public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125; 如果 indexOf(Object) 方法不返回 -1，则表示要查找的元素存在于列表，那么该方法是怎么实现的，来看下源码实现就知道了。 1234567891011121314151617181920212223/** * 返回此列表中指定元素第一次出现的索引;如果此列表不包含元素，则返回-1。 * * @param o 检索的元素 * @return 返回此列表中指定元素第一次出现的索引;如果此列表不包含元素，则返回-1。 */public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 从源码可以看出，首先判断要查找的元素 o 是否为 null，如果为 null 的话，遍历列表是否存在空元素，存在的则返回该元素在列表的位置 index，否则继续遍历；不为 null 的话也是遍历列表是否存在该元素，存在的则返回该元素在列表的位置 index，否则继续遍历；如果最后搜索不到该元素的话直接返回 -1。 10、从列表末尾开始检索指定元素是否存在列表12345678910111213141516171819202122232425/** * 返回指定元素的最后一次出现的索引在此列表中，如果此列表不包含元素， * 则为-1。 * * @param o 检索的元素 * @return 返回指定元素的最后一次出现的索引在此列表中， * 如果此列表不包含元素，则为-1。 */public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125; lastIndexOf(Object) 方法与 indexOf(Object) 的区别在于该方法是从列表末尾开始查找指定的元素是否存在。 11、获取列表元素个数12345678/** * 返回列表元素个数 * * @return 返回列表元素个数 */public int size() &#123; return size;&#125; （二）、LinkedList 实现 Deque 双端队列LinkedList 实现 Deque 接口，因此可以把它当作双端队列使用。理解了双向链表的原理后，再来理解双端队列的基本操作操作应该很容易了。Deque 实现基本操作可以分为三种：插入元素、删除元素和查询元素。每种操作的实现方法都有两种形式，一种是如果操作失败时抛出异常；一种是如果操作失败返回 null 或者 false。以下对这三种操作分别作出解析。 1、插入元素（1）、在列表的开始处插入指定元素（第一种形式：抛出异常）12345678/** * 在列表的开始处插入指定元素 * * @param 添加的元素 */public void addFirst(E e) &#123; linkFirst(e);&#125; 接着看 linkFirst(E) 的具体实现 123456789101112131415161718192021/** * 链接元素 e，作为列表第一个元素 */private void linkFirst(E e) &#123; // 将第一个节点 first 保存到变量 f final Node&lt;E&gt; f = first; // 创建新节点 newNode，f 作为新节点 newNode 的后继节点（后一个节点） final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // first 指向新节点 newNode，即新节点 newNode 作为第一个节点 first first = newNode; if (f == null) &#123; // 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点 last = newNode; &#125; else &#123; // 链表不为空表，将新节点 newNode 插入到表头，f 的上一个节点指向新节点 newNode f.prev = newNode; &#125; // 链表节点数加 1 size++; modCount++;&#125; 以上给出了详细的注释，其余就不多说了。接下来通过图解来理解链表不为空表时是如何将指定元素插入表头，如下图： （2）、在列表的前面插入指定的元素（第二种形式：返回特定值）12345678910/** * 在列表的前面插入指定的元素 * * @param e 插入元素 * @return true */public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125; 该方法最终是调用 addFirst(E)，并且返回 true，至于方法的分析见上面的分析。 （3）、将指定的元素添加到列表末尾（第一种形式：抛出异常）12345678/** * 将指定的元素添加到列表末尾，该方法与 add(java.lang.Object) 等价 * * @param e 添加的元素 */public void addLast(E e) &#123; linkLast(e);&#125; 看到第 2 行代码很熟悉吧，具体分析看上面。 （4）、在列表的末尾插入指定的元素（第二种形式：返回特定值）12345678910/** * 在列表的末尾插入指定的元素 * * @param e 添加的元素 * @return true */public boolean offerLast(E e) &#123; addLast(e); return true;&#125; 该方法实现逻辑很简单，调用方法 addLast(E) 并返回 true。 2、删除元素（1）、从列表中删除并返回第一个元素（第一种形式：抛出异常）12345678910111213/** * 移除并返回列表第一个元素 * * @return 从列表返回的第一个元素 * @throws 如果列表是空的抛出 NoSuchElementException */public E removeFirst() &#123; // 保存 list 第一个节点到变量 f，并作为参数传给 unlinkFirst(Node&lt;E&gt;) final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; (2)、从列表中删除并返回第一个元素（第二种形式：返回特定值）123456789/** * 检索并删除此列表的第一个元素，如果此列表为空，则返回null。 * * @return 返回列表第一个元素或者如果列表是空，则返回 null */public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; （3）、从列表中删除并返回最后一个元素（第一种形式：抛出异常）12345678910111213/** * 移除并返回列表最后一个元素 * * @return 返回列表最后一个元素 * @throws 如果列表为空抛出异常 NoSuchElementException */public E removeLast() &#123; // 保存 list 最后一个节点到变量 l，并作为参数传给 unlinkLast(Node&lt;E&gt;) final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125; 看方法 unlinkLast(Node) 具体实现 12345678910111213141516171819202122private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; // 保存 l 的 item 到变量 element，并作为返回值返回 final E element = l.item; // 保存 l 的 prev 到变量 prev final Node&lt;E&gt; prev = l.prev; // 释放资源，将 l 的 item 和 prev 置 null l.item = null; l.prev = null; // help GC // 移动 last 指针，指向被删除节点的前驱节点 prev last = prev; if (prev == null) &#123; first = null; &#125; else &#123; // 由于 prev 是列表最后一个节点，因此 prev 的 next 指向 null prev.next = null; &#125; // 列表节点数减 1 size--; modCount++; return element;&#125; 与方法 unlinkFirst(Node) 实现逻辑类似的，只不过一个是删除头节点，一个是删除尾节点。简单来说就是先把最后一个节点 last 的数据域和指针域保存起来，然后置空，释放资源；如果列表元素个数大于 1 的话，将 last 指针移动到上一个节点，并重新对 last 节点的 next 进行设置。 （4）、从列表中删除并返回最后一个元素（第二种形式：返回特定值）123456789/** * 检索并删除此列表的最后一个元素，如果此列表为空，则返回null。 * * @return 返回列表第一个元素或者如果列表是空，则返回 null */public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 3、查询元素（1）、查询列表第一个元素（第一种形式：抛出异常）123456789101112/** * 返回列表第一个元素 * * @return 列表第一个元素 * @throws 如果列表是空的，抛出异常 NoSuchElementException */public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125; （2）、查询列表第一个元素（第二种形式：返回特定值）123456789/** * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。 * * @return 返回列表第一个元素，如果列表为空，则返回 null。 */public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; （3）、查询列表最后一个元素（第一种形式：抛出异常）123456789101112/** * 返回列表最后一个元素 * * @return 列表最后一个元素 * @throws 如果列表是空的，抛出异常 NoSuchElementException */public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; （3）、查询列表最后一个元素（第二种形式：返回特定值）123456789/** * 检索但不移除此列表的最后一个元素，如果此列表为空，则返回null。 * * @return 返回列表最后一个元素，如果列表为空，则返回 null。 */public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125; （三）、LinkedList 实现队列 QueueDeque 接口继承 Queue 接口，可以当作队列使用，那么 LinkedList 也就实现队列的基本操作，具体实现如下。 1、add(E)12345678910/** * 将指定元素添加到 list 末尾 * * @param 被添加到 list 元素 * @return true*/public boolean add(E e) &#123; linkLast(e); return true;&#125; 2、off(E)123456789/** * 添加指定元素到列表尾 * * @param e 添加的元素 * @return true */public boolean offer(E e) &#123; return add(e);&#125; 3、remove()123456789/** * 检索和删除列表第一个元素 * * @return 返回 list 第一个元素 * @throws 如果列表是空的抛出 NoSuchElementException */public E remove() &#123; return removeFirst();&#125; 4、poll()123456789/** * 检索并删除此列表的头（第一个元素）。 * * @return 返回列表的表头，如果列表为空，则返回 null */public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125; 5、element()123456789/** * 返回列表第一个元素 * * @return 列表第一个元素 * @throws 如果列表是空的，抛出异常 NoSuchElementException */public E element() &#123; return getFirst();&#125; 6、peek()123456789/** * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。 * * @return 返回列表第一个元素，如果列表为空，则返回 null。 */public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; （四）、LinkedList 实现栈 Stack由于 Deque 接口可以当作栈（Stack）使用，那么 LinkedList 也实现栈的基本操作，来看下是怎么实现的吧。 1、入栈12345678910/** * 将指定元素压入到列表所表示的栈；换句话说，将元素插入到列表表头。 * * 该方法与 addFirst(E) 等价 * * @param 入栈元素 */public void push(E e) &#123; addFirst(e);&#125; 2、出栈12345678/** * 从列表所表示的栈弹出元素；换句话说，删除并返回此列表的第一个元素。 * * 该方法与 removeFirst() 等价 */public E pop() &#123; return removeFirst();&#125; 3、查询元素123456789/** * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。 * * @return 返回列表第一个元素，如果列表为空，则返回 null。 */public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; 从以上可以看出，不管 LinkedList 是当作双端队列使用，还是当作队列或者栈使用，其底层实现是通过链表实现的。 五、小结 LinkedList 是基于双向链表实现的。 对于插入或者删除元素，如果从列表两端插入或者删除元素的时，执行效率是高效的；如果是在列表指定的位置插入或者删除元素的话，需要先通过索引遍历查找指定的元素，再执行相关操作，效率明显降低了。 LinkedList 不存在容量这个问题，也就不存在扩容之说，这是与 ArrayList 不同的，ArrayList 当容量不满足的话，需要进行扩容的。 LinkedList 是线程不同步的。 由于 LinkedList 实现 Deque 接口，因此 LinkedList 既可以当作双端队列使用，又可以当作队列或者栈，但是底层都是由双向链表实现。 六、LinkedList 与 ArrayList 异同1、LinkedList 与 ArrayList 的区别 LinkedList 是基于双向链表实现；而 ArrayList 是基于数组实现，可以理解为动态数组。 LinkedList 没有实现 RandomAccess 接口，不具有随机访问元素的功能，对于访问元素需要遍历整个列表，效率显然很低；而 ArrayList 实现了RandomAccess 接口，可以通过索引快速随机访问元素，效率高。 LinkedList 是基于双向链表实现的，在插入或删除元素时效率相对较高，只需要记录当前节点的前驱节点和后继节点；而 ArrayList 在插入或者删除元素时，需要移动数组里的元素，即复制数组。 LinkedList 不用预先分配内存空间，不存在容量问题；而 ArrayList 在创建数组时需要指定其容量，存在容量问题。当容量不足时，需要扩容，为原来的 1.5 倍，扩容是很消耗性能的，因此有可能的话在创建数组时预先指定其容量。 2、LinkedList 与 ArrayList 相同点 允许存储所有元素，包括 null 元素； 线程不同步； 存储的元素允许重复。 参考链接Java集合干货系列-（二）LinkedList源码解析","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"Java 集合框架","slug":"Java-集合框架","permalink":"http://panzeyong.com/tags/Java-集合框架/"}]},{"title":"Java 集合框架：ArrayList（JDK 8）","slug":"Java-集合框架：ArrayList","date":"2017-11-07T00:43:33.000Z","updated":"2017-12-12T01:17:09.000Z","comments":true,"path":"2017/11/07/Java-集合框架：ArrayList/","link":"","permalink":"http://panzeyong.com/2017/11/07/Java-集合框架：ArrayList/","excerpt":"","text":"一、概述ArrayList 是数组队列，相当于动态数组，其底层结构是由数组实现。ArrayList 继承 AbstractList 抽象类，实现 List、RandomAccess、Clone、java.io.Serializable 接口。 ArrayList 继承 AbstractList 抽象类，实现 List 接口。它是一个数组队列，提供了增删改查以及遍历等功能。 ArrayList 实现 RandomAccess 接口，提供快速随机访问功能。RandomAccess 接口被 List 实现主要用来支持快速随机访问，通过数组下标随机访问元素。 ArrayList 实现 Clone 接口，重写 Object clone() 方法可以克隆对象。 ArrayList 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据传输。 ArrayList 允许添加所有元素，包括 null 元素。 与 Java 数组相比，ArrayList 实现容量动态增长。简单来说，当向 ArrayList 添加新元素时，会将 ArrayList 实际元素个数加 1（size + 1）与底层数组（elementData）的长度进行比较，如果大于底层数组长度时，则会自动进行扩容（newValue = oldValue + oldValue &gt;&gt; 1，即为原先的 1.5 倍），扩容是对原先数组复制到新数组，相当消耗性能。如果可能的话，提前预估数据规模，调用 ArrayList(init initialCapacity) 构造方法初始化，做到减少扩容，提高效率。 与 Vector 相比，ArrayList 是线程不安全，只能在单线程环境下工作；如果要在多线程环境下工作，则可以使用 Collections.synchronizedList 创建 List，返回线程安全 ArrayList 实例； 1List list = Collections.synchronizedList(new ArrayList(...)); 二、ArrayList 继承关系图 三、ArrayList 源码解析1、构造函数ArrayList 提供三个构造函数，分别如下： 1234567891011121314151617181920212223242526272829303132333435363738/*** 用初始容量构造空列表* * @param initialCapacity 列表初始容量* @throws IllegalArgumentException 如果指定初始容量为负数，则抛出异常 */public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); // 创建数组（elementData 是 ArrayList 底层实现数组，用于存储 ArrayList 列表中所有元素） this.elementData = new Object[initialCapacity];&#125;/** * 构造空数组（默认初始容量 10）*/public ArrayList() &#123; super(); // 把空数组赋值给 elementData（elementData 是 ArrayList 底层实现数组，用于存储 ArrayList 列表中所有元素） this.elementData = EMPTY_ELEMENTDATA;&#125;/** * 构造指定集合元素列表 * * @param c 集合 c 中的元素复制到 ArrayList * @throws NullPointerException 如果指定集合为 null ，则抛出空指针 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 集合 c 转换为数组赋值给数组 elementData elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 转换数组返回值可能不正确，如果是这样的话，则执行下面的语句 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 以上源码已经给出了详细的注释，这里就不再解释了。不过从第 3 个构造函数可以看出，对数组的复制是调用了 Arrays.copyOf(elementData, size, Object[].class) 方法，那么该方法具体是什么呢，先来看下它的源代码： 12345public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength)); return copy;&#125; 该方法采用泛型，T 是方法返回值数组类型，而 U 是原始数组类型；第 2 行代码是根据传入参数 newType 类型创建数组实例。真正对数组执行复制的是第 3 行代码，那么来看它的具体实现： 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 该方法是 native 方法，接收 5 个参数： src：源数组； srcPos：源数组起始位置； dest：目标数组； destPos：目标数组起始位置； length：复制源数组元素个数。 从指定的源数组复制指定位置的数组到目标数组指定的位置。 2、增加元素ArrayList 提供多个添加元素的方法，既有添加单个元素也有添加整个集合，具体方法实现如下： 123456789101112/** * 将指定的元素添加到 ArrayList 末尾 * * @param e 被添加到列表的元素 * @return true */ public boolean add(E e) &#123; // 检查内部数组 elementData 容量是否满足，不满足的话则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 该方法的主要功能是往列表的末尾添加元素，实现逻辑挺简单的，短短的 3 行代码，但是每行代码又包含着相应的逻辑，那么就来看下具体是怎么实现的。这里假设一开始创建 ArrayList 实例是调用无参构造函数创建的，也就是说 elementData 这个内部数组被赋值空数组。第 9 行代码是在添加元素之前对内部数组 elementData 容量进行检查，ensureCapacityInternal() 方法传入的参数是原先数组的长度加 1（size + 1），具体实现如下： 12345678private void ensureCapacityInternal(int minCapacity) &#123; // 判断 elementData 是否为空数组，是的话执行 if 语句里的代码，取 DEFAULT_CAPACITY 与 minCapacity 的最大值作为最小容量 if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 由以上可知，minCapacity 的值为 DEFAULT_CAPACITY，即默认容量 10。再来看 ensureExplicitCapacity(minCapacity) 的逻辑实现： 123456789private void ensureExplicitCapacity(int minCapacity) &#123; // 这个字段主要用于记录列表结构被修改的次数，所谓的列表结构可理解为列表长度的改变 modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;&#125; 第 6 行代码的条件满足，执行 if 语句里的代码，具体实现如下： 12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code // 添加新元素之前 elementData 的容量（旧长度） int oldCapacity = elementData.length; // 新容量为旧容量的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 增加容量，以确保至少能容纳最小容量参数指定的元素数量。第 12 代码主要功能是实现对数组的复制，由以上对构造函数分析可知，真正实现对数组复制的函数是 System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength)); 即将源数组里的元素拷贝到新数组，然后返回赋值给 elementData。可见，扩容是相当于耗性能的。 扩容完成后，就可以往数组添加元素。回到方法 add(E) 第 10 行代码，将要添加的新元素添加到底层数组 elementData 末尾。 123456789101112131415161718/** * 向列表中指定中位置添加指定的元素 * * @param index 指定元素被插入到列表的索引 * @param element 被插入的元素 * @throws IndexOutOfBoundsException 数组越界抛出异常 */public void add(int index, E element) &#123; // 检查数组是否越界 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); // 检查内部数组 elementData 容量是否满足，不满足的话则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 移动数组中元素，目的为了插入新元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 该方法的主要功能是往列表指定位置添加新元素，实现逻辑与上一个方法有所不同。第 10 ~ 11 行代码检查是否数组是否越界；第 13 行代码检查容量是否满足，具体分析上面已经分析过；第 15 行代码实现对数组的复制，那么是如何复制的呢，具体分析见下图： 相信通过上图的讲解可以更好地理解。 1234567891011121314/* * 把集合中所有的元素添加到列表中，添加顺序与元素在集合中的顺序一致 * * @param c 包含被添加到列表中的元素的集合 * @return true * @throws NullPointerException 指定集合为 null 时抛出异常 */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments System.arraycopy(a, 0, elementData, size, numNew); size += numNew;&#125; 该方法的功能是把集合中的所有元素添加到列表末尾，与 add(E) 方法的区别是前者是添加集合所包含的元素；而后者则添加单个元素，其它基本差不多，就不再作分析。 123456789101112131415161718192021222324/** * 把集合中所有的元素添加到列表指定的位置，添加顺序与元素在集合中的顺序一致 * @param index 集合插入到列表的起始位置 * @param c 包含被添加到列表中的元素的集合 * @return true * @throws IndexOutOfBoundsException 数组越界抛出异常 * @throws NullPointerException 指定集合为 null 时抛出异常 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 该方法的功能是向列表指定位置插入多个新元素（集合中所有元素），那么在实现移动源数组元素与 add(int, E) 方法的实现基本相同，同样也通过图进行解析： 3、删除元素Arraylist 提供多个删除元素方法，既有通过索引删除元素，又有通过 Object 以及删除指定集合包含的元素，具体方法实现如下： 1234567891011121314151617181920212223/*** 删除列表指定位置的元素* * @param 被删除元素索引*/public E remove(int index) &#123; // 检查要删除元素索引是否在源数组范围内（数组是否越界） rangeCheck(index); modCount++; // 存储被删除元素作为返回值返回 E oldValue = elementData(index); // 移动元素个数 int numMoved = size - index - 1; // 移动元素 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 该方法的功能是通过索引删除列表指定位置的元素，源码中给出详细的注释，再结合下图加深对该方法的理解： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 从以上源码可以看出，不管 o 是否为 null，都需要遍历整个数组 elementData，看该元素是否存在于数组里，存在的话通过调用 fastRemove(int) 方法移除并返回 true；不存在的话则返回 false。那么方法 fastRemove(int) 是怎么移除元素的呢？具体实现如下： 12345678910111213141516171819private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;``` 该方法的实现逻辑与 **remove(int)** 差不多，具体分析看 **remove(int)** 的图解。```java/* * 从列表中删除指定集合中包含的所有元素*/public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125; 该方法的功能是移除指定集合中包含的所有元素。第 5 行代码是检查集合 c 是否为空，第 6 行代码是批量移除元素，那么来看下具体是如何实现的？ 123456789101112131415161718192021222324252627private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; 该方法的功能是批量移除元素，实现逻辑也不是很复杂。大致是先遍历源数组 elementData 中元素是否被包含在集合 c 中，被包含的话直接跳过；不被包含的话则将元素复制另一个数组（目标数组），最后目标数组空出来的位置置 null，完成移除元素操作。下面通过图解加深对该方法的理解： ArrayList 还提供 removeRange(int fromIndex, int toIndex) 方法，移除指定范围元素，实现思路与 batchRemove(Collection&lt;?&gt; c, boolean complement) 类似，具体分析参考该方法。 4、修改元素在 ArrayList 提供增删改查的方法中，修改元素和查询元素方法实现逻辑算是最简单的了，那么怎么个简单法呢？来看下源码实现就知道了。 1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 从代码上看，逻辑实现确实很简单。一开始检查要修改元素的索引是否越界（第 2 行代码）；接着保存被修改元素的原始值并作为返回值返回，最后修改元素。 5、查询元素由于 ArrayList 实现 RandomAccess 接口，因此具有随机快速访问元素的功能，该方法的实现逻辑也很简单，具体看下面源码： 1234public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 以上就是对 ArrayList 源码的初步认识，有时间的话再研究其它，比如遍历、排序。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"Java 集合框架","slug":"Java-集合框架","permalink":"http://panzeyong.com/tags/Java-集合框架/"}]},{"title":"Activity","slug":"Activity","date":"2017-11-06T23:40:09.000Z","updated":"2017-11-06T23:49:24.000Z","comments":true,"path":"2017/11/07/Activity/","link":"","permalink":"http://panzeyong.com/2017/11/07/Activity/","excerpt":"","text":"一、概述Activity 应用组件，是 Android 程序与用户交互的窗口。通常来说，Activity 呈现给用户的是充满整个窗口，但是也有其它方式，比如悬浮窗口（设置 windowIsFloating）或者嵌套在另一个 Activity 里面（ActivityGroup）。 二、生命周期在 Android 系统中，Android 是由一个叫做任务栈进行管理的；简单来说，当创建新 Activity 时，该 Activity 会压入任务栈里，此时处于前台进程，之前的 Activity 位于新 Activity 下面，直到新 Activity 被 finish 时之前的 Actiivity 才会重新回到前台进程。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"第十三章 事件","slug":"第十三章-事件","date":"2017-11-04T02:40:35.000Z","updated":"2017-12-05T11:47:11.000Z","comments":true,"path":"2017/11/04/第十三章-事件/","link":"","permalink":"http://panzeyong.com/2017/11/04/第十三章-事件/","excerpt":"","text":"一、事件流事件流描述的是在页面上点击元素时，从页面中接收事件的顺序。对于事件流的概念有两种说发，一种是事件冒泡流（IE 团队），一种是事件捕获流（Netscape Communicator 团队）。 1、事件冒泡IE 的 事件流叫做事件冒泡，即事件开始时由最具体的元素（元素中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。简单来说就是从下往上进行传播。以下面的 HTML 页面为例： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Event Bubbling Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"myDiv\"&gt;Click me&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 点击元素 &lt;div&gt; 后事件冒泡的过程如下图： 注：IE5.5 及更早版本中的事件冒泡会跳过 &lt;html&gt; 元素（从 &t;body&gt;直接跳转到 document）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。 2、事件捕获Netscape Communicator 的事件流叫做事件捕获，思想是不太具体的节点应该更早地接收到事件，而最具体的节点应该是最后接收到事件。仍以前面 HTML 页面为例子，点击元素 &lt;div&gt; 后事件捕获的过程如下图： 3、DOM 事件流“DOM2 级事件” 规定的事件流包括三个阶段： 事件捕获阶段 处于目标阶段； 事件冒泡阶段。 仍以上面 HTML 页面为例子，单击 &lt;div&gt; 元素事件触发顺序如下图： 二、事件处理程序响应某个事件的函数就叫做事件处理程序（或事件侦听器）。 1、HTML 事件处理程序某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。 1&lt;input type=\"button\" value=\"Click me\" onclick=\"alert('Clicked')\" /&gt; 使用这种方式缺点： 时差问题。用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件； 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果； HTML 与 JavaScript 代码紧密耦合。 2、DOM0 级事件处理程序通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 12345var click = document.getElementById(\"click\"); click.onclick = function() &#123; alert(this.id); &#125;&#125; 使用这种方式的优点： 简单； 具有跨浏览器的优势。 3、DOM2 级事件处理程序用于处理指定和删除事件处理程序的操作：addEventListener() 和 removeEventListener()。这两个方法都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后一个参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。 12345678var click = document.getElementById(\"click\");var handler = function() &#123; alert(this.id);&#125;;click.addEventListener(\"click\", handler, false);click.removeEventListener(\"click\", handler, false); 4、IE 事件处理程序IE 实现了与 DOM 中类似的两个方法：attachEvent() 和 detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称和事件处理程序函数，事件被添加到冒泡阶段。 123456var click = document.getElementById(\"click\");var handler = function() &#123; alert(this.id);&#125;;click.addachEvent(\"onclick\", handler); 这两个方法的使用与 DOM0 级方法使用的区别在于事件处理程序的作用域： 在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行； 在使用 attachEvent() 方法的情况下，事件处理程序会在全局作用域中运行，此时 this 等于 window。 5、跨浏览器的事件处理程序1234567891011121314151617181920212223var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; console.log(\"addEventListener\"); element.addEventListener(type, handler, false); &#125; else if (element.addachEvent) &#123; console.log(\"addachEvent\"); element.addachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] + handler; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent(\"on\" + type, handler); &#125; else &#123; element[\"on\" + type] = null; &#125; &#125;&#125;; 三、事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他特定事件相关信息。 1、DOM 中的事件对象DOM 事件对象 event 包含着相关的属性和方法，如下表格： 属性/方法类型读/写说明bubblesBoolean只读表示事件是否冒泡cancelableBoolean只读表明是否可以取消事件的默认行为currentTargetElement只读其事件处理程序当前正在处理事件的那个元素defaultPreventedBoolean只读为 true 表示已经调用了 preventDefault() （DOM3 级事件中新增）detailInteger只读与事件相关的细节信息eventPhaseInteger只读调用事件处理程序的阶段：1 表示捕获阶段，2 表示 “处于目标”， 3 表示冒泡阶段preventDefault()Function只读取消事件的默认行为。如果是 cancelable 是 true，则可以使用这个方法stopImmediatePropagation()Function只读取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3 级事件中新增）stopPropagation()Function只读/td&gt;取消事件的进一步捕获或冒泡。如果 bubbles 为 true，则可以使用这个方法targetElement只读事件的目标trustedBoolean只读为 true 表示事件时浏览器生产的。为 false 表示事件时由开发人员通过 JavaScript 创建的（DOM3 级事件新增）typeString只读被触发的事件的类型viewAbstractView只读与事件关联的抽象视图。等同于发送事件的 window 对象 2、IE 中的事件对象IE 的 event 对象同样也包含着与创建它的事件相关属性和方法，如下表： 属性/方法类型读/写说明cancelBubbleBoolean读/写默认值为 false，但将其设置为 true 就可以取消事件冒泡（与 DOM 中的 stopPropagation() 方法的作用相同）returnValueBoolean读/写默认值为 true，当将其设置为 false 就可以取消事件的默认行为（与 DOM 中的 preventDefault() 方法的作用相同）srcElementElement只读事件的目标（与 DOM 中的 target 属性相同）typeString只读被触发的事件类型 3、跨浏览器的事件对象12345678910111213141516171819202122232425var EventUtil = &#123; getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, priventDefault: function(event) &#123; if (event.priventDefault) &#123; event.priventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 四、事件类型DOM3 级事件规定了以下几类事件： UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发； 焦点事件，当元素获得或失去焦点时触发； 鼠标事件，当用户通过鼠标在页面上执行操作时触发； 滚轮事件，当使用鼠标滚轮（或类似设备）时触发； 文本事件，当在文档中输入文本时触发； 键盘事件，当用户通过键盘在页面上执行操作时触发； 合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发； 变动（mutation）事件，当底层 DOM 结构发生变化时触发。 1、UI 事件 load：当页面完全加载后在 window 上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕时在 &lt;img&gt; 元素上面触发，或者当嵌入内容加载完毕时在 &lt;object&gt; 元素上面触发。 123EventUtil.addHandler(window, \"load\", function(event) &#123; alert(\"Loaded!\");&#125;); unload：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在 &lt;object&gt; 元素上面发。 123EventUtil.addHandler(window, \"unload\", function(event) &#123; alert(\"Unloaded\");&#125;); abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在 &lt;object&gt; 元素上面触发。 error：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在 &lt;img&gt; 元素上面触发，当无法加载嵌入内容时在 &lt;object&gt; 元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。 select：当用户选择文本框（&lt;input&gt; 或 &lt;texterea&gt;）中的一或多个字符时触发。 resize：当窗口或框架的大小变化时在 window 或框架上面触发。 123EventUtil.addHandler(window, \"resize\", function(event) &#123; alert(\"Resized\");&#125;); scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt; 元素中包含所加载页面的滚动条。 1234567EventUtil.addHandler(window, \"scroll\", function(event) &#123; if (document.compatMode == \"CSS1Compat\") &#123; alert(document.documentElement.scrollTop); &#125; else &#123; alert(document.body.scrollTop); &#125;&#125;); 2、焦点事件焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFeature() 方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪。有以下 6 个焦点事件： blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 DOMFocusIn：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。只有 Opera支持这个事件。DOM3 级事件废弃了 DOMFocusIn，选择了 focusin。 DOMFocusOut：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版。只有 Opera支持这个事件。DOM3 级事件废弃了 DOMFocusOut，选择了 focusout。 focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。 focusin：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它冒泡。 focusout：在元素失去焦点时触发。这个事件时 HTML 事件 blur 的通用版本。 当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件： focusout 在失去焦点的元素上触发； focusin 在获得焦点的元素上触发； blur 在失去焦点的元素上触发； DOMFocusOut 在失去焦点的元素上触发； focus 子啊获得焦点的元素上触发； DOMFocusIn 在获得焦点的元素上触发。 3、鼠标与滚轮事件DOM3 级事件中定义了 9 个鼠标事件，如下： click：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。 dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发。 mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mousemove：当鼠标指针在元素内部移动时重复第触发。不能通过键盘触发这个事件。 mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。 mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。 事件触发顺序： mousedown mouseup click mousedown mouseup click dblclick 相关细节如下： 客户区坐标位置：事件发生时鼠标指针子啊视口中的水平和垂直坐标。这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。 1234EventUtil.addHandler(btn, \"click\", function(event) &#123; event = EventUtil.getEvent(event); alert(\"Client coordinates: \" + event.clientX + \",\" + event.clientY);&#125;); 页面坐标位置：表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。在页面没有滚动的情况下，pageX 和 pageY 的值与 clientX 和 clientY 的值相等。 1234EventUtil.addHandler(btn, \"click\", function(event) &#123; event = EventUtil.getEvent(event); alert(\"Page coordinates: \" + event.pageX + \",\" + event.pageY);&#125;); 屏幕坐标位置：鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。 1234EventUtil.addHandler(btn, \"click\", function(event) &#123; event = EventUtil.getEvent(event); alert(\"Screen coordinates: \" + event.screenX + \",\" + event.screenY);&#125;); 修改键：DOM 规定了 4 个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey 和 metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为 true，否则值为 false。 12345678910111213141516171819202122EventUtil.addHandler(btn, \"click\", function(event) &#123; event = EventUtil.getEvent(event); var keys = new Array(); if (event.shiftKey) &#123; keys.push(\"shift\"); &#125; if (event.ctrlKey) &#123; keys.push(\"ctrl\"); &#125; if (event.altKey) &#123; keys.push(\"alt\"); &#125; if (event.metaKey) &#123; keys.push(\"meta\"); &#125; alert(\"Keys: \" + keys.join(\",\"));&#125;); 相关元素：DOM 通过 event 对象的 relatedTarget 属性提供了相关元素信息。这个属性只对 mouseover 和 mouseout 事件才包含值；对于其它事件，这个属性的值是 null。IE8 及之前版本不支持 relatedTarget 属性，但是提供了保存着同样信息的不同属性。在 mouseover 事件触发时，IE 的 fromElement 属性中保存了相关元素；在 mouseout 事件触发时，IE 的 toElement 属性中保存着相关元素。那么跨浏览器取得相关元素的方法实现如下： 12345678910111213var EventUtil = &#123; getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromElement) &#123; return event.fromElement; &#125; else &#123; return null; &#125; &#125;&#125; 鼠标按钮：对于 mousedown 和 mosueup 事件来说，则在其 event 对象存在一个 button 属性，表示按下或释放的按钮。DOM 的 button 属性可能有如下 3 个值： 0 表示主鼠标按钮；（鼠标左键） 1 表示中间的鼠标按钮（鼠标滚轮按钮）； 2 表示次鼠标按钮。（鼠标右键） IE8 及之前版本也提供了 button 属性，但这个属性的值与 DOM 的 button 属性有很大差异。 0：表示没有按下按钮。 1：表示按下了主鼠标按钮。 2：表示按下了次鼠标按钮。 3：表示同时按下主、次鼠标按钮。 4：表示按下了中间的鼠标按钮。 5：表示同时按下了主鼠标按钮和中间的鼠标按钮。 6：表示同时按下了次鼠标按钮和中间的鼠标按钮。 7：表示同时按下了三个鼠标按钮。 跨浏览器鼠标按钮属性实现方法： 1234567891011121314151617181920212223var EventUtil = &#123; getButton: function(event) &#123; if (document.implementation.hasFeature(\"MouseEvents\", \"2.0\")) &#123; return event.button; &#125; else &#123; switch(event.button) &#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125; &#125;&#125; 更多的事件信息：”DOM2级事件” 规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。 鼠标滚轮事件 触摸设备 无障碍性问题 4、键盘与文本事件","raw":null,"content":null,"categories":[],"tags":[]},{"title":"第十二章DOM2 和 DOM3","slug":"第十二章DOM2-和-DOM3","date":"2017-10-16T23:30:31.000Z","updated":"2017-10-31T11:10:10.000Z","comments":true,"path":"2017/10/17/第十二章DOM2-和-DOM3/","link":"","permalink":"http://panzeyong.com/2017/10/17/第十二章DOM2-和-DOM3/","excerpt":"","text":"一、DOM 发展史1、DOM 1：支持 XML 1.02、DOM 2 DOM 2 级核心（DOM Level 2 Core）：在 DOM 1 基础上构建，为节点添加了更多方法和属性。支持 XML 1.0 和命名空间。 DOM 2 级 HTML（DOM Level 2 HTML）：在 DOM 1 级基础上构建，添加了更多属性、方法和新接口。 DOM 2 级视图（DOM Level 2 Views）：为文档定义了基于样式信息的不同视图。 DOM 2 级样式（DOM Level 2 Style）：定义了如何以编程方式来访问和改变 CSS 样式信息。 DOM 2 级事件（DOM Level 2 Events）：说明如何使用事件与 DOM 文档交互。 DOM 2 级遍历和范围（DOM Level 2 Traversal and Range）：引入了遍历 DOM 文档和选择其特定部分的新接口。 3、DOM 3 DOM 3 级核心（DOM Level 3 Core） DOM 3 级加载与保存（DOM Level 3 Load and Save） DOM 3 级验证（DOM Level 3 Validation） 二、DOM 变化（一）、XML 命名空间变化使用 xmlns 来指定命名空间特性 （二）、Node 类型变化1、在 DOM2 级中，Node 类型包含下列特定于命名空间的属性 localName：不带命名空间前缀的节点名称。 namespaceURI：命名空间 URI 或者（在未指定的情况下是）null. prefix：命名空间前缀或者（在未指定的情况下是）null。 2、DOM3 isDefaultNamespace(namespaceURI)：在指定的 namespaceURI 是当前节点的默认命名空间的情况下返回 true； lookupNamespaceURI(prefix)：返回给定 prefix 的命名空间。 lookupPrefix(namespaceURI)：返回给定 namespaceURI 的前缀。 (三)、Document 类型的变化 createElementNS(namespaceURI, tagName)：使用给定的 tagName 创建一个属性命名空间 namespaceURI 新元素。 createAttributeNS(namespaceURI, attributeName)：使用给定的 attributeName 创建一个属于命名空间 namespaceURI 的新特性。 getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList. （四）、Element 类型的变化 getAttributeNS(namespaceURI, localName)：取得属于命名空间 namespaceURI 且名为 localName 的特性。 getAttributeNodeNS(namespaceURI, localName)：取得属于命名空间 namespaceURI 且名为 localName 的特性节点。 getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList。 hasAttributeNS(namespaceURI, localName)：确定当前元素是否有一个名为 localName 的特性，而且该特性的命名空间是 namespaceURI。 removeAttributeNS(namespaceURI, localName)：删除属于命名空间 namespaceURI 且名为 localName 的特性。 setAttributeNS(namespaceURI, qualifiedName, value)：设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value。 setAttributeNodeNS(attNode)：设置属于命名空间 namespaceURI 的特性节点。 （五）、NamedNodeMap 类型变化 getNamedItemNS(namespaceURI, localName)：取得属于命名空间 namespaceURI 且名为 localName 的项。 removeNamedItemNS(namespaceURI, localName)：移除属于命名空间 namespaceURI 且名为 localName 的项。 setNamedItemNS(node)：添加 node，这个节点已经事先指定了命名空间信息。 （六）、DocumentType 类型变化 publicId、systemId：文档类型声明中的信息段。 internalSubset：用于访问包含在文档类型声明中的额外定义。 （七）、Document 类型变化 importNode()：从一个文档中取得一个节点，然后将其导入到另外一个文档，使其成为这个文档结构的一部分。接收两个参数：要复制的节点和一个表示是否复制子节点的布尔值。 document.implementation 新方法 createDocumentType()：创建新的 DocumentType 节点。接收 3 个参数：文档类型名称、publicId、systemId。（DOM 级核心） createDocument()：创建新文档。接收 3 个参数：文档元素中的 namespaceURI、文档元素的标签名、新文档的文档类型。（DOM 级核心） createHTMLDocument()：创建一个完整的 HTML 文档，包括 、、 和 元素。接收一个参数：新创建文档的标题。返回新的 HTML 文档。（DOM 级 HTML ）。 defaultView：保存着一个指针，指向拥有给定文档的窗口（或框架）。（DOM 级视图） 1var parentWindow = document.defaultView || document.parentWindow; （八）、Node 类型的变化 isSupported()：用于确定当前节点具有的能力。接收两个参数：特性名和特性版本号。 isSameNode()：接收一个节点参数，并在传入节点与引用节点相同时返回 true。所谓相同，是指两个节点引用的是同一个对象。 isEqualNode()：接收一个节点参数，并在传入节点与引用的节点相等时返回 true。所谓相等，指的是两个节点是相同的类型,具有相同的属性，而且它们的 attributes 和 childNodes 属性也相等。 setUserData()：将数据指定给节点，接收 3 个参数：要设置的键、实际的数据（可以是任何数据）和处理函数。函数作用：在带有数据的节点被复制、删除、重命名或者引入一个文档时调用。接收 5 个参数：表示操作类型的数值（1 数据键、数据值、源节点和目标节点。在删除节点时，源节点是 null；除在复制节点时，目标节点均为 null。 123456var div = document.createElement(\"div\");div.setUserData(\"name\", \"Nicholas\", function(operation,key, value, src, dest) &#123; if (operation == 1) &#123; dest.setUserData(key, value, function() &#123;&#125;); &#125;&#125;); contentDocument:表示框架内容的文档对象。 三、DOM2 级样式1、定义样式三种方法： 通过 &lt;link/&gt; 元素包含外部样式表文件； 使用 &lt;style/&gt; 元素定义嵌入式样式； 使用 style 特性定义针对特定元素的样式。 2、style（CSSStyleDeclaration）对象属性和方法 cssText：可以访问到 style 特性中的 CSS 代码。 length：元素设置 CSS 属性的数量。 parentRule：表示 CSS 信息的 CSSRule 对象。 getPropertyCSSValue(propertyName)：返回包含给定值的 CSSValue 对象。 CSSValue：cssText 和 cssValueType。cssText 表示属性值；cssValueType 表示类型值：0 表示继承值；1 表示基本的值；2 表示值列表；3 表示自定义的值。 getPropertyPriority(propertyName)：如果给定的属性使用了 !important 设置，则返回 “important”；否则，返回空字符串。 getPropertyValue(propertyName)：返回给定属性的字符串值。 item(index)：返回给定位置的 CSS 属性的名称。 removeProperty(propertyName)：从样式中删除给定属性。 setProperty(propertyName, value, priority)：将给定属性设置为相应的值，并加上优先权标志（“important” 或者一个空字符串） document.defaultView 提供方法 getComputedStyle()：接收两个参数：取得技术样式的元素和一个伪元素字符串。返回 CSSStyleDeclaration 对象。IE 不支持该方法，与之类似的是 currentStyle 属性，用法类似。 123456789var sheet = document.styleSheets[1];var rules = sheet.cssRules || sheet.rules;var rule = rules[0];alert(rule.cssText);alert(rule.parentRule);alert(rule.parentStyleSheet);alert(rule.selectorText);alert(rule.style.cssText);alert(rule.type); 3、操作样式表CSSStyleSheet，表示样式表，继承 StyleSheet， document.styleSheets。CSSStyleSheet 对象属性是 sheet（IE 则是 styleSheet）。 StyleSheet 接口继承属性 disabled：表示样式表是否被禁用；这个属性是可读/可写。true 表示禁用样式表。 href：如果样式表是通过 包含的，则是样式表的 URL；否则，是 null。 media：当前样式表支持的所有媒体类型的集合。（MediaList） ownerNode：指向拥有当前样式表的节点的指针。如果当前样式表是其他样式表通过 @import 导入的，则这个属性值为 null。IE 不支持这个属性。(HTMLLinkElement 和 HTMLStyleElement) parentStyleSheet：在当前样式表是通过 @import 导入的情况下，这是属性是一个指向导入它的样式表的指针。 title：ownerNode 中 title 属性的值。 type：表示样式表类型的字符串。 CSSStyleSheet 支持属性 cssRules：样式表中包含的样式规则的集合。IE 不支持这个属性，但是有一个类似的属性 rules。类型是 CSSRuleList。 ownerRule：如果样式表是通过 @import 导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为 null。IE 不支持这个属性。 deleteRule(index)：删除 cssRules 集合中指定位置的规则。IE 不支持这个方法，但是支持 removeRule() 方法。 insertRule(index)：向 cssRules 集合中指定的位置插入 rule 字符串。IE 不支持这个方法，但是支持一个类似 addRule() 方法。 CSS 规则 cssText：返回整条规则对应的文本。IE 不支持这个属性。 parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为 null。IE 不支持这个属性。 parentStyleSheet：当前规则所属的样式表。IE 不支持这个属性。 selectorText：返回当前规则的选择符文本。只有 Opera 浏览器可读可写。 style：一个 CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。 type：表示规则类型的常量值。IE 不支持这个属性。 1234567function insertRule(sheet, selectorText, cssText, position) &#123; if (sheet.insertRule) &#123; sheet.insertRule(selectorText + \"&#123;\" + cssText + \"&#125;\", position); &#125; else if (sheet.addRule) &#123; sheet.addRule(selectorText, cssText, position); &#125;&#125; 1234567function deleteRule(sheet, index) &#123; if (sheet.deleteRule) &#123; sheet.deleteRule(index); &#125; else if (sheet.removeRule) &#123; sheet.removeRule(index); &#125;&#125; 4、元素大小 偏移量 offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、（可见的）水平滚动条的高度、上边框的高度和下边框的高度。 offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、（可见的）垂直滚动条的宽度、左边框宽度和右边框宽度。 offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。（类似 Android 中 marginLeft） offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。类似 Android 中 marginTop） 1234567891011function getElementLeft(element) &#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 1234567891011function getElementTop(element) &#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 客户区大小（内容 + 内边距） clientWidth：元素内容区宽度加上左右内边距宽度。 clientHeight：元素内容区高度加上上下内边距高度。 滚动大小 scrollHeight：在没有滚动条的情况下，元素内容的总高度。 scrollWidth：在没有滚动条的情况下，元素内容的总宽度。 scrollLeft：被隐藏在内容区域左侧的像素数。 scrollTop：被隐藏在内容区域上方的像素数。 12345678910111213141516171819202122232425262728293031323334function getBoundingClientRect(element) &#123; var scrollTop = document.documentElement.scrollTop; var scrollLeft = document.documentElement.scrollLeft; if (element.getBoundingClientRect) &#123; if (typeof arguments.callee.offset != \"number\") &#123; var temp = document.createElement(\"div\"); temp.style.cssText = \"position:absolute;left:0;top:0;\" document.body.appendChild(temp); arguments.callee.offset = -temp.getBoundingClientRect().top - scrollTop; temp = null; &#125; var rect = element.getBoundingClientRect(); var offset = arguments.callee.offset; return &#123; left: rect.left + offset, right: rect.right + offset, top: rect.top + offset, bottom: rect.bottom + offset &#125;; &#125; else &#123; var actualLeft = getElementLeft(element); var actualTop = getElementTop(element); return &#123; left: actualLeft - scrollLeft, right: actualLeft + element.offsetWidth - scrollLeft, top: actualTop - scrollTop, bottom: actualTop + element.offsetHeight - scrollTop &#125; &#125;&#125; 四、遍历NodeIterator document.createNodeIterator()：创建 NodeIterator 实例，接收 4 个参数： root：想要作为搜索起点的树中的节点； whatToShow：表示要访问哪些节点的数字代码；whatToShow 参数是一个位掩码，以常量的形式在 NodeFilter 类型中定义，可以在 HTML 中使用的有： 1、NodeFilter.SHOW_ALL：显示所有类型的节点。 2、NodeFilter.SHOW_TEXT：显示文本节点。 3、NodeFilter.SHOW_COMMENT：显示注释节点。 4、NodeFilter.SHOW_DOCUMENT：显示文档节点。 5、NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型。 6、NodeFilter.SHOW_ELEMENT：显示元素节点。 filter：是一个 NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数；可以通过该参数 filter 来指定自定义的 NodeFilter 对象；每个 NodeFilter 对象只有一个方法，即 acceptNode()，该方法有两个返回值： NodeFilter.FILTER_ACCEPT：应该访问给定的节点； NodeFilter.FILTER_SKIP：不应该访问给定的节点。 entityReferenceExpansion：布尔值，表示是否要扩展实体引用。（HTML 页面不能扩展实体引用） nextNode()：向前前进一步。 previousNode()：向后后退一步。 TreeWalker 是 NodeIterator 的一个更高级的版本。 nextNode()：向前前进一步。 previousNode()：向后后退一步。 parentNode()：遍历到当前节点的父节点。 firstChild()：遍历到当前节点的第一个子节点。 lastChild()：遍历到当前节点的最后一个子节点。 nextSibling()：遍历到当前节点的下一个同辈节点。 previousSibling()：遍历到当前节点的上一个同辈节点。 currentNode：便是任何遍历方法在上一次遍历中返回的节点。 创建 TreeWalk 对象使用 document.createTreeWalk()，接收 4 个参数，与 document.createNodeIterator() 方法类似。 NodeFilter.FILTER_SKIP：跳过相应节点继续前进到子树中的下一个节点。 NodeFilter.FILTER_REJECT：跳过相应节点及该节点的整个子树。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Java 问题整理","slug":"Java-问题整理","date":"2017-10-14T09:20:19.000Z","updated":"2017-11-20T00:02:56.000Z","comments":true,"path":"2017/10/14/Java-问题整理/","link":"","permalink":"http://panzeyong.com/2017/10/14/Java-问题整理/","excerpt":"","text":"一、为什么 Java byte 类型取值范围是 -128 ~ 127 ？要解决这个问题，必须先来弄清楚几个概念：机器数、真值、原码、反码和补码。 机器数：数字在计算机中的二进制表示，带符号的，即有正负数之分。在计算机中用一个数的最高位表示符号位，0 表示正数，1 表示负数。例如： 十进制 +10，转换成二进制是 00001010； 如果是 -10，转换成二进制则是 10001010。 真值：由于符号位的存在，机器数并不能表示真正的数值。比如上面带符号数 10001010，最高位 1 表示负数，其真值是 -10；而其形式值是 138（二进制 10001010 转化为十进制），明显两个值是不相等的。因此，将带符号位的机器数真正的数值称为机器数的真值。例如： 00001010 真值：10； 10001010 真值：-10。 原码：机器数中最简单的一种表示形式，符号位为 0 表示正数；符号位为 1 表示负数；数值位即真值的绝对值。故原码表示又称为带符号位的绝对值表示。以 8 位二进制为例子： 10 的原码： 00001010 -10 的原码：10001010 反码：反码通常来作为原码求补码或者补码求原码中间过渡。可以归纳为： 正数的反码是其本身； 负数的反码是在原码基础上，符号位不变，各位取反。 10 反码： 00001010 -10 反码：11110101 补码：补码也是一种用二进制表示有符号数的方法。可归纳为下： 正数的补码是其本身； 负数的补码是在原码基础上，符号位不变，各位取反，末位加 1（即在反码基础上加 1），也可以理解为负数的补码是其绝对值取反末位加 1。 10 补码：00001010； -10 补码：11110110。 理解了机器数、真值、原码、反码、补码这 5 个概念后，我们就可以来解答这个问题了。 二进制有原码、反码、补码这三种表示方法，但是在计算机内部二进制的表示方法最终是采用补码。（至于为何采用补码，自己 Google 。） 在 Java 中，数据类型 byte 占用的空间是 8 位，最高位是符号位。 那么最大整数是 0111111，由于正数的补码是其本身，因此二进制 01111111 转换为十进制为 127； 由于有符号之分，其最小负数是 10000000（最大负整数 11111111，即 -1），负数的补码是在原码基础上，符号位不变，各位取反，末位加 1，而且我们又知道二进制是用补码表示，因此我们把计算补码的步骤反过来即可。即 10000000，减 1 得 011111111，各位取反 10000000。由于负数的补码是其绝对值取反加 1，那么 10000000 是最小负数的绝对值，转换成十进制为 128，最小负数是 -128。 因此，byte 的取值范围是 -128 ~ 127。 注：本文主要是记录在复习 Java 知识点时所想到或遇到的问题，持续更新中。 二、Java 中 == 与 equals 有何区别？== 是二元操作符，用于比较两个对象的内存地址是否相同，如果两个对象的内存地址相同的话，则返回 true；否则返回 false。基本数据类型（int、short、long、char、float、double、boolean、byte）和 复合数据类型。以下通过例子进一步说明： 12345678910public class EqualsOperator &#123; public static void main(String [] args) &#123; String s1 = \"Hello World\"; String s2 = \"Hello World\"; String s3 = new String(\"Hello World\"); System.out.println(s1 == s2); System.out.println(s1 == s3); &#125;&#125; 输出结果： 12truefalse equals() 是 Object 类中方法，默认实现是比较两个对象的内存地址，与 == 操作符的作用是一样。不管是 Java 提供的类，还是自己自定义的类，默认继承 Object，如果没有对 equals() 方法进行重写时，这时 equals() 的作用与操作符 == 是一样的；但是 Object 的子类大部分都会根据自己的需求对 equals() 方法进行重写，既可以比较两个对象的内存地址，也可以比较两个对象所包含的内容，比如 String、Integer 等。 equals() 默认实现： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 很明显可以看出，默认实现是比较两个对象的内存地址。官方文档也给出该方法的具体描述： equals 方法在非 null 对象引用上实现等价关系： 自反性：对于任何非空引用值 x，x.equals(x) 应该返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true 并且 y.equals(z) 也返回 true 时，那么 x.equals(z) 返回 true。 一致性：对于任何非空引用值 x 和 y，如果对象 equals 对象上比较的信息没有被修改，那么多次调用 x.equals(y) 一致返回 true 或者 一致 返回 false。 对于任何非空引用值 x，x.equals(null) 应该返回 false。 Object 类的 equals 方法实现对象上最可能的等价关系;也就是说，对于任何非 null 的引用值 x 和 y，当且仅当 x 和 y 引用同一个对象（x == y 的值为 true）时，此方法返回 true。 注意：无论什么时候重写此方法，都必须重写 hasCode() 方法，以维护 hasCode() 方法一般的约定，该方法声明相等的对象必须具有相同的哈希码。 那么来看下 String 类是如何重写 equals() 方法的，具体源码如下： 12345678910111213141516171819202122public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 第 2 ~ 4 行代码判断两个对象的内存地址是否相同，相同的话返回则返回 true；不同的话执行下面语句。第 5 ~ 20 行代码判断两个对象所包含的内容是否相同，相同的话则返回 true；否则返回 false。当以上两个条件都不满足时，则返回 false。 下面通过例子加深对该知识点的理解： 1234567891011121314public class EqualsMethos &#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1.equals(n2)); Value v1 = new Value(); Value v2 = new Value(); v1.i = v2.i = 100; System.out.println(v1.equals(v2));&#125;class Value &#123; int i;&#125; 输出结果： 12true // Integer 类重写 equals() 方法，比较的对象所包含的内容 false // 由于 Value 类是自己定义的，没有重写 equals() 方法，继承 Object 类 equals() 方法默认实现，比较的是两个对象的内存地址，这时与 **==** 操作符的作用一样。 对于 euqals() 与 == 这知识点异同的比较就说到这里，想要继续更深层的了解就 Google 吧。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"问题","slug":"问题","permalink":"http://panzeyong.com/tags/问题/"}]},{"title":"第二章 一切都是对象","slug":"第二章-一切都是对象","date":"2017-10-11T13:48:07.000Z","updated":"2017-10-31T11:10:37.000Z","comments":true,"path":"2017/10/11/第二章-一切都是对象/","link":"","permalink":"http://panzeyong.com/2017/10/11/第二章-一切都是对象/","excerpt":"","text":"一、数据存储位置 寄存器：最快的存储区，位于处理器内部。 堆栈：位于通用 RAM（随机访问存储区）中，存储速度仅次于寄存器，主要用于存储对象引用。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放内存。有一点不足是 Java 系统必须知道存储在堆栈内的所有项的确切生命周期，方便堆栈指针上下移动。这一约束限制程序的灵活性。 堆：一种通用的内存池（也位于 RAM 区），用于存放所有 Java 对象。不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间，显示提高了灵活性。但是也付出了代价，即用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。 常量存储：常量值通常直接存储在程序代码内部（静态存储区）。 非 RAM 存储：流对象（对象转化成字节流）和持久化对象（对象存放磁盘）。 二、基本数据类型在 Java 中，每种基本数据类型都占一定的存储空间大小，而且不随平台的改变而改变，即在不同平台上每种数据类型所占的空间是相同。Java 提供 8 中基本数据类型，如下表： 基本类型大小（bits）最小值最大值包装器类型boolean———Booleanbyte8-128+127Bytechar16Unicode 0Unicode 216 - 1Charactershort16-215+215 - 1Shortint32-231+231 - 1Integerfloat32IEEE754IEEE754Floatlong64-263+263 - 1Longdouble64IEEE754IEEE754Double 注：Javs SE5 的自动包装功能将自动地将基本类型转换为包装器类型。 字段（数据成员）会获取默认值，可以不初始化； 局部变量没有默认值，必须初始化，否则会报错。 方法的基本组成部分：名称、参数、返回值和方法体。 名称：定义方法的名字。 参数：传给方法的信息的类型和名称。 返回值：在调用方法之后从方法返回的值。 方法体：方法所要执行的逻辑。 方法名和参数列表合称为 “方法签名”。","raw":null,"content":null,"categories":[{"name":"Java","slug":"Java","permalink":"http://panzeyong.com/categories/Java/"}],"tags":[{"name":"《Java Thinking》学习笔记","slug":"《Java-Thinking》学习笔记","permalink":"http://panzeyong.com/tags/《Java-Thinking》学习笔记/"}]},{"title":"第十一章 DOM 扩展","slug":"第十一章-DOM-扩展","date":"2017-09-14T23:50:33.000Z","updated":"2017-09-16T00:01:40.000Z","comments":true,"path":"2017/09/15/第十一章-DOM-扩展/","link":"","permalink":"http://panzeyong.com/2017/09/15/第十一章-DOM-扩展/","excerpt":"","text":"一、选择符 API（Selectors API）选择符 API，简单地来说，就是根据 CSS 选择符选择与某个模式匹配的 DOM 元素。 1、Selectors API 1 核心方法 querySelector()：接收一个参数：CSS 选择符。返回与该模式匹配的第一元素，如果没有找到匹配的元素，返回 null。通过类型 Document 调用 querySelector() 方法时，会在文档元素的范围内查找匹配的元素；而通过 Element 类型调用 querySelector() 方法时，只会在该元素后代元素的范围内查找匹配的元素。 1var body = document.querySelector(\"body\"); querySelectorAll()：接收一个参数：CSS 选择符。返回的是所有匹配的元素，是一个 NodeList 实例。返回的值实际上是带有所有属性和方法的 NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。 1var lis = document.querySelectorAll(\"li\"); 2、Selector API 2 方法matchesSelector()：接收一个参数：CSS 选择符。如果调用元素与该选择符匹配，返回 true；否则返回 false。Selector API 2 w为 Element 类型新增的方法。 在使用该方法的同时要做到兼容不同浏览器，需要对该方法做处理，示例代码如下： 12345678910111213function matchesSelector(element, selector) &#123; if (element.matchesSelector) &#123; return element.matchesSelector(selector); &#125; else if (element.msMatchesSelector) &#123; return element.msMatchesSelector(selector); &#125; else if (element.mozMatchesSelector) &#123; return element.mozMatchesSelector(selector); &#125; else if (element.webkitMatchesSelector) &#123; return element.webkitMatchesSelector(selector); &#125; else &#123; throw new Error(\"Not Supported.\"); &#125;&#125; 二、元素遍历对于元素间的空格，不同浏览器对空格的处理是不一样的。有的浏览器在对空格处理时则会返回文本节点，而有的不会。为了解决此现象，Element Traversal 为 DOM 元素新定义一组元素。 Element Traversal API 为 DOM 元素添加新属性： childElementCount：返回子元素（不包括文本节点和注释）的个数。 firstElementChild：指向第一个子元素；firstChild 的元素版。 lastElementChild：指向最后一个子元素；lastChild 的元素版。 previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。 nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。 三、HTML51、方法 getElementsByClassName()：接收一个参数：一个包含一或多个类名的字符串，返回带有指定类的所有元素的 NodeList。通过 document 对象及所有 HTML 元素调用该方法。在 document 对象上调用 getElementsByClassName() 始终会返回与类名匹配的所有元素，在元素上调用该方法就会返回后代元素中匹配的元素。(一个元素指定多个类名) 1var elements = document.getElementsByClassName(\"title content\"); hasFocus()：确定文档是否获得了焦点了。 window.toStaticHTML()：接收一个参数，即一个 HTML 字符串；返回一个经过无害处理后的版本，即从源 HTML 中删除所有脚本节点和事件处理程序属性。 insertAdjacentHTML()：接收两个参数：插入位置和要插入的文本。第一个参数必须是下列值之一： “beforebegin”：在当前元素之前插入一个紧邻的同辈元素； “afterbegin”：在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素。 “beforeend”：在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素； “afterend”：在当前元素之后插入一个紧邻的同辈元素。 scrollIntoView()：传入参数 true 或者不传入任何参数表示窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐；传入 false 则表示调用元素会尽可能全部出现在视口中。 2、属性 classList：所有 DOM 元素所具有的属性，而且该属性是新集合类型 DOMTokenList 实例，包含 length 属性，并具有以下方法： item()：获取每个元素。 add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value)：表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value)：从列表中删除给定的字符串。 toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。 1&lt;p id=\"title\" class=\"title content user\"&gt;JavaScript Practice&lt;/p&gt; 1234var classList = p.classList;classList.remove(\"title\"); // length：2classList.add(\"content\"); // length：2classList.toggle(\"toggle\"); // length：3 document.activeElement：始终引用 DOM 中当前获取焦点的元素。文档刚刚加载完成时，document.activeElement 中保存的是 document.body 元素的引用。文档加载期间，document.activeElement 的值为 null。（焦点管理） document.readyState：表示文档是否已经加载完成。有两个值：loading（正在加载文档）和 complete（已经加载完文档） 12345if (document.readyState == \"complete\") &#123; alert(\"Complete\");&#125; else &#123; alert(\"Loading\");&#125; document.compatMode：检测浏览器采用的模式（标准还是混杂）。 12345if (document.compatMode == \"CSS1Compat\") &#123; alert(\"Standards mode\");&#125; else &#123; alert(\"Quirks mode\");&#125; document.head：引用文档的 \\ 元素。 1var head = document.head ||document.getElementsByTagName(\"head\")[0]; document.charset：表示文档中实际使用的字符集，也可以用来指定新字符集。 document.defaultCharset：表示根据默认浏览器及操作系统的设置。 dataset：访问自定义属性（用 data- 作为前缀），是 DOMStringMap 的一个实例，也是一个名值而的映射。 1&lt;div id=\"content\" class=\"content\" data-appId=\"12345\" data-username=\"panju\"&gt;Content&lt;/div&gt; 123var div = document.getElementById(\"content\");alert(\"AppId : \" + div.dataset.appId);alert(\"User Name : \" + div.dataset.username); innerHTML：在读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。在写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DMO 树完全替换调用元素原先的所有子节点。 1234567891011121314// index.html&lt;body id=\"bodys\" class=\"page\"&gt; &lt;p id=\"title\" class=\"title content user\"&gt;JavaScript Practice&lt;/p&gt; &lt;div id=\"content\" class=\"content\" data-appId=\"12345\" data-username=\"panju\"&gt;Content&lt;/div&gt; &lt;ul id=\"ui\"&gt; &lt;li class=\"content\"&gt;Python&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;Java&lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\" src=\"index.js\"&gt;&lt;/script&gt;&lt;/body&gt; 12345// 读模式alert(document.body.innerText);// 写模式document.body.innerText = \"Hello DOM\"; 注：并不是所有元素都支持 innerHTML 属性。不支持 innerHTML 的元素有：&lt;col&gt;、&lt;colgroup&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt;。 outerHTML：与 innerHTML 属性类似。区别在于读模式下，outerHTML 返回结果包括调用该属性的元素本身。 四、专有扩展1、4 种文档模式 IE5：以混杂模式渲染页面（IE5 的默认模式就是混杂模式）。IE8 及更高版本中的功能都无法使用。 IE7：以 *IE7 标准模式渲染页面。IE8 及更高版本中的功能都无法使用。 IE8：以 IE8 标准模式渲染页面。IE9 中的新功能无法使用。 IE9：以 IE9 标准模式渲染页面。 要设置浏览器文档类型，可以通过 HTTP 头部信息 X-UA-Compatible 或者通过标签 \\ 来设置，如下： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=IEVersion\" &gt; 对于 IE 版本（IEVersion）的取值如下： Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于 IE8，始终保持以 IE8 标准模式渲染页面。对于 IE9，则以 IE9 标准模式渲染页面。 EmulateIE9：如果有文档类型声明，则以 IE9 标准模式渲染页面，否则将文档模式设置为 IE5。 EmulateIE8：如果有文档类型声明，则以 IE8 标准模式渲染页面，否则将文档模式设置为 IE5。 EmulateIE7：如果有文档类型声明，则以 IE7 标准模式渲染页面，否则将文档模式设置为 IE5。 9：强制以 IE9 标准模式渲染页面，忽略文档类型声明。 8：强制以 IE8 标准模式渲染页面，忽略文档类型声明。 7：强制以 IE7 标准模式渲染页面，忽略文档类型声明。 5：强制以 IE5 标准模式渲染页面，忽略文档类型声明。 2、方法 contains()：检测被测节点是不是参考节点的后代。接收一个参数：即要检测的后代节点。 1var contains = document.documentElement.contains(document.body); compareDocumentPosition()：确定节点之间的关系，返回一个表示该关系的位掩码。（DOM Level 3） 12 // 模仿 contains() 方法var position = document.documentElement.compareDocumentPosition(document.body) &amp; 16) scrollIntoViewIfNeeded(alignCenter)：只有当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。参数 alignCenter 设置为 true 表示尽量将元素显示在视口中部（垂直方向）。（Safari 和 Chrome） scrollByLines(lineCount)：将元素的内容滚动指定的行高，参数 lineCount 可以为正值或者负值。（Safari 和 Chrome） scrollByPages()：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。（Safari 和 Chrome） 3、属性 document.documentMode：检测文档模式 children：只包含元素中同样还是元素的子节点，忽略空格。该属性是 HTMLCollection 的实例。 1var length = ui.children.length; innerText：操作元素中包含的所有文本内容，包括子文档树中的文本。在读模式时，它会将子文档树中所有文本拼接起来；在写模式时，会将元素所有子节点删除，并插入包含文本值的文本子节点。 12345// 读模式var innerText = document.body.innerText;// 写模式document.body.innerText = \"Hello JavaScript\"; textContent：作用与 innerText 类似，DOMLevel 3 规定的一个属性。 outerText：作用与 innerText 基本类似。区别在于作用范围扩大到调用它的节点。 4、通用函数通用 contains() 函数 1234567891011121314151617function contains(refNode, otherNode) &#123; if (typeof refNode.contains == \"function\" &amp;&amp; (!client.engine.webkit || client.engine.webkit &gt;= 522)) &#123; return refNode.contains(otherNode); &#125; else if (typeof refNode.compareDocumentPosition == \"function\") &#123; retrun !!(refNode.compareDocumentPosition(otherNode) &amp; 16); &#125; else &#123; var node = otherNode.parentNode; do &#123; if (node === refNode) &#123; return true; &#125; else &#123; node = node.parentNode; &#125; &#125; while (node !== null); return false; &#125;&#125; 跨浏览器使用属性 innerText 还是 textContent 兼容函数 1234567891011function getInnerText(element) &#123; return (typeof element.textContent == \"string\" ? element.textContent : element.innerText);&#125;function setInnerText(element, text) &#123; if (typeof element.textContent == \"string\") &#123; element.textContent = text; &#125; else &#123; element.innerText = text; &#125;&#125; 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第十一章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"第十章 DOM","slug":"第十章-DOM","date":"2017-08-28T23:26:29.000Z","updated":"2017-09-16T00:02:09.000Z","comments":true,"path":"2017/08/29/第十章-DOM/","link":"","permalink":"http://panzeyong.com/2017/08/29/第十章-DOM/","excerpt":"","text":"一、节点层次DOM（文档对象模型）将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点类型总共有 12 种，每种节点类型分别表示文档中不同的信息及标记。 1、Node 类型在 JavaScript 中，Node 类型实现 Node 接口，并且作为 JavaScript 中所有节点类型的基类，因此所有节点类型都共享着相同的基本属性和方法。除了 IE 之外，在其它所有浏览器中都可以访问到 Node 类型。 （1）、在 Node 类型中定义 12 个数值常量表示 12 种节点类型，如下： Node.ELEMENT_NODE(1) Node.ATTRIBUTE_NODE(2) Node.TEXT_NODE(3) Node.CDATA_SECTION_NODE(4) Node.ENTITY_REFERENCE_NODE(5) Node.ENTITY_NODE(6) Node.PROCESSING_INSTRUCTION_NODE(7) Node.COMMENT_NODE(8) Node.DOCUMENT_NODE(9) Node.DOCUMENT_TYPE_NODE(10) Node.DOCUMENT_FRAGMENT_NODE(11) Node.NOTATION_NODE(12) （2）、属性 nodeType：节点类型； nodeName：节点标签名； nodeValue：null 值。 childNodes：一个节点可能有 0 个、1 个 或多个 child 节点，包括各种类型节点。保存在 NodeList 对象（NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。NodeList 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。）。 parentNode：每个节点的父节点。 previousSibling：childNodes 列表中节点之间的同胞节点。 nextSiblign：childNodes 列表中节点之间的同胞节点。 firstChild：childNodes 列表中第一个节点。 lastChild：childNodes 列表中最后一个节点。 ownerDocument：表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多文档中。 （3）、方法 hasChildNodes()：当节点包含一或多个子节点时返回 true。 appendChild()：在 childNodes 末尾添加新节点，返回新增的节点。 insertBefore()：在 childNodes 指定位置插入节点，该方法接收两个参数：要插入的节点和作为参照的节点。 replaceChild()：从文档树中移除要替换的节点，并返回该节点，同时要插入的节点占据其位置。该方法接收两个参数：插入的节点和替换的节点。 removeChild()：移除节点。（移除的节点仍然为文档所有，但是在文档中已经没有了自己的位置。） cloneNode()：创建调用该方法的节点的一个完全相同的副本。接收一个布尔值：true 表示执行深复制，也就是复制整个节点及其整个子节点数；fasle 表示浅复制，即只复制节点本身。所有类型的方法都拥有该方法。（复制后返回的节点副本属于文档所有，但并没有为它指定父节点。） normalize()：合并相邻文本节点。所有类型的方法都拥有该方法。 注：并不是所有类型的节点都有子节点，如果在不支持子节点调用以上方法，将会导致错误发生，所有在调用方法之前需要进行相应的检测，以免发生错误。 2、Document 类型HTMLDocument 继承 Document，document 对象是 HTMLDocument 的实例，同时也是 window 对象的一个属性。document 对象表示整个 HTML 页面。Document 节点具有以下特征： nodeType 的值为 9； nodeName 的值为 #document； nodeValue 的值为 null； parentNode 的值为 null； ownerDocument 的值为 null； 其子节点可能是一个 DocumentType（最多一个）、Element（Element）、ProcessingInstrction 或 Comment。 （1）、属性 documentElement：访问子节点，指向 HTML 页面中 元素。 body：指向 &lt;body&gt; 元素。 doctype：访问子节点 DocumentType 信息。 title：显示在浏览器窗口的标题栏或者标签页上。 URL：包含页面完整的 URL（即地址栏中显示 URL）。 domain：只包含页面的域名，可设置。 referrer：保存着链接到当前页面的那个页面的 URL。 anchors：包含文档中所有带 name 特性的 &lt;a&gt; 元素，返回的结果是 HTMLCollection 对象。 forms：包含文档中所有的 &lt;form&gt; 元素，返回的结果是 HTMLCollection 对象。 images：包含文档中所有的 &lt;img&gt; 元素，返回的结果是 HTMLCollection 对象。 links：包含文档中所有带 href 特性的 &lt;a&gt; 元素，返回的结果是 HTMLCollection。 implementation：提供检测浏览器相应信息和功能的对象，提供方法 hasFeature()。 （2）、方法 getElementById()：接收一个参数：要取得的元素的 ID。如果找到相应的元素则返回该元素；否则返回 null。 getElementsByTagName()：接收一个参数：元素的标签名。返回零个或多个元素的 NodeList，该方法返回的对象是 HTMLCollection，可使用该对象提供的方法 item(index) 或 namedItem(name) 访问集合中的项。 getElementsByName()：接收一个参数：name 特定。返回带有指定 name 特定的所有元素，即 HTMLCollection 对象。 createElement()：创建新元素，接收一个参数：要创建元素的标签名。 createTextNode()：创建文本节点，接收一个参数：要插入节点中的文本。 createDocument()：创建注释节点。 createCDataSection()：创建 CDATA 区域，只需为其传入节点的内容。 createDocumentFragment()：创建文档片段。 createAttribute()：创建新的特性节点，传入特性的名称。 hasFeature：implmentation 对象提供的方法，接收两个参数：要检测的 DOM 功能的名称及版本号。 write()：接收一个参数：写入到输出流的文本，原样写入；可以动态包含外部资源。 writeln()：接收一个参数：写入到输出流的文本，在字符串的末尾添加一个换行符（\\n）；可以动态包含外部资源。 open()：打开网页的输出流。 close()：关闭网页的输出流。 3、Element 类型Element 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。Element 节点具有以下特征： nodeType 的值为 1； nodeName 的值为元素的标签名（tagName）； nodeValue 的值为 null； parentNode 可能是 Document 或 Element； 其子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference。 1、元素特性HTML 元素由 HTMLElement 类型表示，而 HTMLElement 类型继承 Element 并添加属性，而这些属性成为每个 HTML 元素存在特有标准特性。 id：元素在文档中的唯一标识符。 title：有关元素的附加说明信息，一般通过工具提示条显示出来。 lang：元素内容的语言代码，很少使用。 dir：语言的方向，值为 “ltr” （左 -&gt; 右）或 “rtr” （右 -&gt; 左）。 className：与元素的 class 特性对应，即为元素指定的 CSS 类。 2、属性 attributes：Element 类型是使用 attributes 属性的唯一一个 DOM 节点类型。attributes 属性返回的是 NamedNodeMap 集合，因为元素的每一个特性都由一个 Attr 节点表示，每个节点都保存在 NamedNodeMap 对象中。NamedNodeMap 对象提供以下方法： getNamedItem(name)：返回 nodeName 属性等于 name 的节点； removeNamedItem(name)：从列表中移除 nodeName 属性等于 name 的节点； setNamedItem(node)：向列表中添加节点，以节点的 nodeName 属性为索引； item(pos)：返回位于数字 pos 位置处的节点。 specified：true 表示设置相应特性；否则相反。 3、元素方法 getAttribute()：获取元素标准特性，传入参数特性名；也可以获取自定义特性，自定义特性应该加上 data- 前缀以便验证。注意特性的名称是不区分大小写的。 setAttribute()：设置特性。接收两个参数：要设置的特性名和值。 removeAttribute()：彻底删除元素的特性。该方法不仅会清除特性的值，而且也会从元素中完全删除特性。 4、要点 任何元素的所有特性，也都可以通过 DOM 元素本身的属性来访问；只有公认的（标准）特性才会以属性的形式添加到 DOM 对象中，而自定义属性则不会，无法通过元素本身的属性来访问（IE 除外）。比如：div.id 调用元素方法 getAttribute() 获取特性的返回值与元素本身的属性访问的返回值不同的两类特殊特性： 第一类特性是 style，用于通过 CSS 为元素指定样式。getAttribute() 访问的特性的返回值是 CSS 文本；而通过属性访问则返回一个对象。 第二类特性是 onClick，表示事件处理程序。getAttribute() 访问时返回相应代码的字符串；属性访问则返回 JavaScript 函数。 3、Text 类型文本节点由 Text 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码。Text 节点具有以下特征： nodeType 的值为 3； nodeName 的值为 #text； nodeValue 的值为节点所包含的文本；（data） parentNode 是一个 Element； 不支持子节点。 元素方法 appendData(text)：将 text 添加到节点的末尾； deleteData(offset, count)：从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text)：在 offset 指定的位置插入 text。 replaceData(offset, count, text)：用 text 替换从 offset 指定的位置开始到 offset + count 为止处的文本。 splitText(offset)：从 offset 指定的位置将当前文本节点分成两个文本节点。该方法返回新文本节点。 substringData(offset, count)：提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 5、Comment 类型在 DOM 中，注释是通过 Comment 类型来表示。Comment 类型 与 Text 类型继承相同的基类，因此 Comment 类型具有 splitText() 之外的所有字符串操作方法。Comment 节点具有以下特征： nodeType 的值为 8； nodeName 的值为 #comment； nodeValue 的值是注释的内容； parentNode 可能是 Document 或 Element； 不支持子节点。 6、CDATASection 类型CDATASection 类型只针对基于 XML 的文档，表示的是 CDATA 区域。CDATASection 类型继承自 Text 类型，因此具有 splitText() 之外的所有字符串操作方法。CDATASection 节点具有以下特征： nodeType 的值为 4； nodeName 的值为 “#cdata-section”； nodeValue 的值是 CDATA 区域中的内容； parentNode 可能是 Document 或 Element； 不支持子节点。 7、DocumentType 类型DocumentType 包含着与文档的 doctype 有关的所有信息，它具有以下特征： nodeType 的值为 10； nodeName 的值为 doctype 名称； nodeValue 的值为 null； parentNode 是 Document； 不支持子节点。 属性 name：表示文档类型的名称； entities：由文档类型描述的实体的 NamedNodeMap 对象； notations：由文档类型描述的符号的 NamedNodeMap 对象。 在 DOM 1 级中，DocumentType 对象不支持动态创建，只能通过解析文档代码的方式来创建。 8、DocumentFragment 类型在所有节点类型中，只有 DocumentFragment 类型在文档中没有对应的标记。DocumentFragment 可以比喻为一个 “仓库”，用来保存将来可能会添加到问文档中节点，当其本身是不被添加到文档中去的。DocumentFragment 节点具有以下特征： nodeType 的值为 11； nodeName 的值为 “#document-fragment”； nodeValue 的值为 null； parentNode 的值为 null； 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。 9、Attr 类型在 DOM 中，Attr 类型用于表示元素特性，而特性就存在于元素 attributes 属性中的节点。特性节点具有以下特征： nodeType 的值为 2； nodeName 的值是特性的名称； nodeValue 的值是特性的值； parentNode 的值为 null； 在 HTML 中不支持子节点； 在 XML 中子节点可以是 Text 或 EntityReference。 属性 name：特性名称； value：特性的值； specified：用来表示特性是否被指定，true 表示指定；反之相反。 二、 DOM 操作技术1、动态脚本向 HTML 页面插入 JavaScript 脚本的方式有两种：通过 src 特性包含外部文件和直接通过 &lt;script&gt; 元素包含代码。 这里所说的动态脚本是指在页面加载时不存在，但是将来某一时刻通过修改 DOM 动态添加脚本。示例代码如下： 12345678910function loadScriptString(code) &#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; try &#123; script.appendChild(document.createTextNode(code)); &#125; catch(ex) &#123; script.text = code; // 适配 IE 浏览器 &#125; document.body.appendChild(script);&#125; 注：IE 会将 &lt;script&gt; 元素认为是一个特殊元素，不允许 DOM 访问其子节点。但是可以通过 &lt;script&gt; 元素 text 指定 JavaScript 代码。 2、动态样式HTML 页面包含 CSS 样式的方式有两种：通过 &lt;link&gt; 元素包含外部文件和直接通过 &lt;style&gt; 元素指定嵌入的样式， 这里所说的动态样式是指在页面刚加载时不存在的样式；而是在页面加载完成后动态添加到页面中。示例代码如下： 123456789101112function loadStyleString(css) &#123; var style = document.createElement(\"style\"); style.type = \"text/css\"; try &#123; style.appendChild(document.createTextNode(css)); &#125; catch (ex) &#123; style.styleSheet.cssText = css; &#125; var head = document.getElementsByTagName(\"head\")[0]; head.appendChild(style);&#125; 注：IE 会将 &lt;style&gt; 元素认为是一个特殊元素，不允许 DOM 访问其子节点。但是可以访问元素 &lt;style&gt; 的属性 styleSheet，同时该属性又有 cssText 属性，可以接受 CSS 代码。 3、操作表格&lt;table&gt; 元素在 HTML 中相对复杂些，要创建一个表格，会涉及到表格头、表格行、单元格等。HTML DOM 除了提供对应标签外，还为相应的标签提供属性和方法。 （1）&lt;table&gt; 元素添加的属性和方法 caption：保存着对 &lt;caption&gt; 元素（如果有）的指针。 tBodies：是一个 &lt;tbody&gt; 元素的 HTMLCollection。 tFoot：保存着对 &lt;tfoot&gt; 元素（如果有）的指针。 tHead：保存着对 &lt;thead&gt; 元素（如果有）的指针。 rows：是一个表格中所有行的 HTMLCollection。 createTHead()：创建 &lt;thead&gt; 元素，将其放到表格中，返回引用。 createTFoot()：创建 &lt;tfoot&gt; 元素，将其放到表格中，返回引用。 createCaption()：创建 &lt;caption&gt; 元素，将其放到表格中，返回引用。 deleteTHead()：删除 &lt;thead&gt; 元素。 deleteTFoot()：删除 &lt;tfoot&gt; 元素。 deleteCaption()：删除 &lt;caption&gt; 元素。 deleteRow(pos)：删除指定位置的行。 insertRow(pos)：向 rows 集合中的指定位置插入一行。 （2）&lt;tbody&gt; 元素添加的属性和方法 rows：保存着 &lt;tbody&gt; 元素中行的 HTMLCollection。 deleteRow(pos)：删除指定位置。 insertRow(pos)：向 rows 集合中的指定位置插入一行，返回对新插入行的引用。 （3）&lt;tr&gt; 元素添加的属性和方法 cells：保存着对 &lt;tr&gt; 元素中单元格的 HTMLCollection。 deleteCell(pos)：删除指定位置的单元格。 insertCell(pos)：向 cells 集合中的指定位置插入一个单元格，返回对新插入单元格的引用。 示例代码如下： // 创建表格 table var table = document.createElement(\"table\"); table.border = 1; table.width = \"100%\"; // 创建 tbody var tbody = document.createElement(\"tbody\"); table.appendChild(tbody); // 创建第一行 tbody.insertRow(0); tbody.rows[0].insertCell(0); tbody.rows[0].cells[0].appendChild(document.createTextNode(\"Cell 1,1\")); tbody.rows[0].insertCell(1); tbody.rows[0].cells[1].appendChild(document.createTextNode(\"Cell 2,1\")); // 创建第二行 tbody.insertRow(1); tbody.rows[1].insertCell(0); tbody.rows[1].cells[0].appendChild(document.createTextNode(\"Cell 1,2\")); tbody.rows[1].insertCell(1); tbody.rows[1].cells[1].appendChild(document.createTextNode(\"Cell 2,2\")); document.body.appendChild(table); (4) NodeListNodeList、NamedNodeMap 和 HTMLCollection 这三个集合是 “动态的”，即每当文档结构发生变化时（比如添加元素之类），集合都会得到更新。 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第十章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Kotlin 学习笔记（一）：开发环境搭建","slug":"Kotlin-开发环境搭建","date":"2017-08-19T08:11:20.000Z","updated":"2017-08-19T08:22:48.000Z","comments":true,"path":"2017/08/19/Kotlin-开发环境搭建/","link":"","permalink":"http://panzeyong.com/2017/08/19/Kotlin-开发环境搭建/","excerpt":"","text":"一、Kotlin 语言介绍Kotlin 是一种基于 JVM 新编程语言，由 JetBrains 开发。Kotlin 不仅可以编译成 Java 字节码，而且也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。（来源：百度百科） 在应用上，Kotlin 可以用来开发服务器、Android 以及 JavaScript。 在 2017 年 Google I/O 大会上，官方宣布 Kotlin 正式成为 Android 开发语言。 学习一门新语言，首先要做的第一件事就是搭建开发环境。所谓工欲善其事，必先利其器。 二、用命令行编译器创建 Hello World 程序（链接）1、安装方式（1）、手动安装 下载编译器：kotlin 编译器最新版本是 1.1.3-2，可以从 GitHub Releases 下载。 将下载好的 kotlin 编译器解压到指定目录，然后将 bin 目录添加到系统环境变量中。不同平台添加系统环境变量有所不同，下面介绍下 Mac、Linux 平台，至于 Windows 平台的设置 google 吧。 Linux：以 Ubuntu 为例，Ubuntu 下有多个文件可以配置环境变量（ps：自己 google），这里我选择文件 ~/.bashrc 来配置。在终端打开文件 ~/.bashrc，命令为 1vim ~/.bashrc 然后添加环境变量，如下： 123 KOTLIN_HOME =/home/panju/Install/kotlincPATH=$&#123;PATH&#125;:$&#123;KOTLIN_HOME&#125;/binexport KOTLIN_HOME PATH 最后保存退出，并执行命令 source ~/.bashrc 使其生效。 如果在终端输入命令 kotlin -version，出现以下信息则说明 Kotlin 环境搭建成功。如下图： Mac：在 Mac 中，/etc/profile、/etc/bashrc 这两个文件是针对系统所有用户的全局变量，需要 root 用户才能操作它们，对于普通用户来说是只读；而 ~/.bash_profile 文件是针对普通用户，即当前用户下所设置的系统环境变量，一般推荐对该文件进行操作。因此，将在 ~/.bash_profile 文件下配置 kotlin 环境。 在终端使用命令 vim ~/.bash_profile 打开该文件，并添加环境变量 12export KOTLIN=/Users/Pan/Library/kotlinc export PATH=$PATH:$KOTLIN/bin 最后保存退出，并执行命令 source /.bash_profile 使其生效。 如果在终端输入命令 kotlin -version，会出现以下信息 网上 google 下说这个问题是 Homebrew 安装版的一个 bug，对 kotlin 环境搭建没影响，其实是安装成功的。（链接） （2）、SDKMAN对于基于 UNIX 系统比如 OS X、Linux、Cygwin、FreeBSD and Solaris 则可以使用 SDKMAN 安装，安装命令如下： 123curl -s https://get.sdkman.io | bashsdk install kotlin （3）、Homebrew对于使用 OS X 系统则可以通过 Homebrew 安装，安装命令如下： 123brew updatebrew install kotlin （4）、MacPorts如果你是 MacPorts 用户，则可以通过 MacPorts 安装，安装命令如下： 1sudo port install kotlin 2、创建和运行第一个 kotlin 程序创建文件 hello.kt，敲入以下代码： 123fun main(args: Array&lt;String&gt;) &#123; println(\"Hello, World\");&#125; 保存文件，并使用 kotlin 编译器编译 1kotlinc hello.kt -include-runtime -d hello.jar kotlinc 表示编译的意思；hello.kt 显然是文件名；-include-runtime 表示运行时需要的 kotlin 库包含进来；-d 则表示打包成 jar 文件。至于要了解命令的详细内容，则可以在终端输入 kotlinc -help 查看。那么，接下来就可以运行程序，输入以下命令： 1java -jar hello.jar 此时会在终端显示 Hello, World。到此，第一个 kotlin 程序就完成了。 三、用 Kotlin 开发 Android 环境搭建（链接）1、安装 Kotlin 插件Android Studio 从 3.0 开始集成 Kotlin 插件，无需自己安装。但是如果你使用 3.0 以前版本，则需要手动安装 kotlin 插件，安装流程也挺简单的。Go to File | Settings | Plugins | Install JetBrains plugin… 搜索和安装 Kotlin 插件；如果 Android Studio 是处于 “Welcome to Android Studio” Configure | Plugins | Install JetBrains plugin…。Kotlin 插件安装完成后，需要重新启动 Android Studio 插件才能生效。 2、创建项目使用 Kotlin 开发 Android 程序时，同样也需要创建 Android 项目，创建项目流程跟之前差不多，稍微有区别的是 Android Studio 版本不同在创建时一些选项有所不同。那么就简单来说下他们的不同之处。 在创建项目第一步，Android Studio 3.0 提供一个选项：是否支持 Kotlin。如果选择这个选项，则可以跳过 “在项目中配置 Kotlin” 这一步。 在 Android Studio 3.0 中，你可以选择以 Kotlin 方式创建 Activity，所以可以跳过 “Java 代码转换为 Kotlin 代码” 这一步。可是在之前版本，还是用 Java 创建 Activity，然后使用转换工具转换。 3、Java 代码转换为 Kotlin 代码打开 MainActivity.java 文件，使用快捷键 Command Shift A 调出 Enter action or option name 并搜索 convert Java File to Kotlin File，如下图 然后按下回车，转换的 Kotlin 代码如下： 1234567class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;&#125; 4、在项目中配置 Kotlin完成以上步骤，还需要在项目中配置 Kotlin。找到 Tools | Kotlin | Configure Kotlin in Project，点击后会弹出对话框，如下图： 点击 OK，然后 Sync build.gradle，Kotlin 就配置完成。 5、构建和发布 Kotlin 程序构建程序和运行在真机或模拟器上，会显示 Hello World，那么也就完成了用 Kotlin 开发第一个 Android 程序。 以上是自己在 Kotlin 官网学习后所做的笔记，记录下来的目的是方便自己查找。","raw":null,"content":null,"categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://panzeyong.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin 学习笔记","slug":"Kotlin-学习笔记","permalink":"http://panzeyong.com/tags/Kotlin-学习笔记/"}]},{"title":"第九章 客户端检测","slug":"第九章-客户端检测","date":"2017-08-13T09:23:34.000Z","updated":"2017-08-13T11:04:38.000Z","comments":true,"path":"2017/08/13/第九章-客户端检测/","link":"","permalink":"http://panzeyong.com/2017/08/13/第九章-客户端检测/","excerpt":"","text":"一、能力检测能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。比如说，函数 document.getElementById 在不同浏览器是否被支持。 能力检测有两个重要概念：一是先检测达成目的的最常用的特性；二是必须测试实际要用到的特性。 示例如下： 1234567function getElement(id) &#123; if (document.getElementById) &#123; return document.getElementById(id); &#125; else if (document.all) &#123;&#125;&#123; return document.all[id]; &#125;&#125; 二、怪癖检测识别浏览器的特殊行为，即检测浏览器存在什么缺陷。怪癖检测无法精确地检测特定的浏览器和版本。 三、用户代理检测通过检测用户代理字符串来确定实际使用的浏览器，可以通过 JavaScript 的 navigator.userAgent 属性访问。 1、主要浏览器所使用的呈现引擎如下表：浏览器IEOperaChromeFirefoxSafariKonqueror呈现引擎IEOperaWebKitGeckoWebKitKHTML 2、用户代理字符串（userAgent）所包含属性如下表：字符串项必须吗说明Mozilla 版本号是Mozilla 的版本号平台是浏览器运行的平台。可能的值包括 Windows、Mac 和 X11（指 Unix 的 X 窗口系统）加密类型是加密技术的类型：U 表示 128 位、I 表示 40 位、N 表示未加密操作系统或 CPU是浏览器运行的操作系统或计算机系统使用的 CPU。在 Windows 平台中，这一项指 Windows 的版本（如 WinNT、Win95，等等）。如果平台是 Macintosh，这一项是 Unix 操作系统的名称，与使用 Unix 命令 uname-sm 得到的名称相同。语言是浏览器设计时所针对的目标用户语言预先发行版本否最初用于表示 Mozilla 的预先发行版本，现在则用来表示 Gecko 呈现引擎的版本号Gecko 版本号是Gecko 呈现引擎的版本号，但由 yyyymmdd 格式的日期表示应用程序或产品否使用 Gecko 的产品名。可能是 Netscape、Firefox 等应用程序或产品版本号否应用程序或产品的版本号；用于区分 Mozilla 版本号或 Gecko 版本号 3、用户代理字符串检测技术通过编写脚本检测浏览器呈现引擎、浏览器、平台、Windows 操作系统、移动设备、游戏系统以此来满足项目中需求。 声明全局变量 client，并使用模块增强模式来封装脚本，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var client = function() &#123; var engine = &#123; // 呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本 ver: null &#125;; var system = &#123; // 检测平台 win: false, mac: false, x11: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, // 游戏系统 wii: false, ps: false &#125;; // 在此检测呈现引擎、平台和设备（各部分代码以下给出） return &#123; engine: engine, browser: browser, system: system &#125;;&#125;();var userAgent = navigator.userAgent; （1）、识别呈现引擎以及浏览器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 识别呈现浏览器步骤如下： * * 1. 第一步：检测 Opera * 2. 第二步：检测 WebKit * 3. 第三步：检测 KHTML * 4. 第四步：检测 Gecko * 5. 第五步：检测 IE*/if (window.opera) &#123; alert(\"Opera\"); engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\\/(\\S+)/.test(userAgent)) &#123; alert(\"AppleWebKit\"); engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); // 确定是 Chrome 还是 Safari if (/Chrome\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; // 近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125;&#125; else if (/KHTML\\/(\\S+)/.test(userAgent) || /Konqueror\\/([^;]+)/.test(userAgent)) &#123; alert(\"KHTML\"); engine.ver = browser.ver = RegExp[\"$1\"]; engine.khtml = browser.konq = parseFloat(engine.ver);&#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/.test(userAgent)) &#123; alert(\"Gecko\"); engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); // 确定是不是 Firefox if (/Firefox\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.firefox = parseFloat(browser.ver); &#125;&#125; else if (/MSIE ([^;]+)/.test(userAgent)) &#123; alert(\"IE\"); engine.ver = browser.ver = RegExp[\"$1\"]; engine.ie = browser.ie = parseFloat(engine.ver);&#125; 有了以上代码，就可以对浏览器进行检测，示例代码如下： 12345678910111213141516171819202122232425262728293031if (client.engine.webkit) &#123; if (client.browser.chrome) &#123; alert(\"Chrome : \" + client.browser.chrome); &#125; else if (client.browser.safari) &#123; alert(\"Safari : \" + client.browser.safari); &#125;&#125; else if (client.engine.gecko) &#123; if (client.browser.firefox) &#123; alert(\"Firefox : \" + client.browser.firefox); &#125; else &#123; alert(\"Not Firefox Browser\"); &#125;&#125; else if (client.engine.opera) &#123; if (client.browser.opera) &#123; alert(\"Opera : \" + client.browser.opera); &#125; else &#123; alert(\"Not Opera Browser\"); &#125;&#125; else if (client.engine.khtml) &#123; if (client.browser.konq) &#123; alert(\"konq : \" + client.browser.konq); &#125; else &#123; alert(\"Not konq Browser\"); &#125;&#125; else if (client.engine.ie) &#123; if (client.browser.ie) &#123; alert(\"IE : \" + client.browser.ie); &#125; else &#123; alert(\"Not IE Browser\"); &#125;&#125; （2）、识别平台123456789var platform = navigator.platform;system.win = platform.indexOf(\"Win\") == 0;system.mac = platform.indexOf(\"Mac\") == 0;system.x11 = (platform.indexOf(\"x11\") == 0) || (platform.indexOf(\"Linux\") == 0);alert(\"Win : \" + system.win);alert(\"Mac : \" + system.mac);alert(\"X11 : \" + system.x11); （3）、识别 Windows 操作系统12345678910111213141516171819202122232425262728293031if (system.win) &#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(userAgent)) &#123; if (RegExp[\"$1\"] == \"NT\") &#123; switch(RegExp[$2]) &#123; case \"5.0\": system.win = \"2000\"; break; case \"5.1\": system.win = \"XP\"; break; case \"6.0\": system.win = \"Vista\"; break; case \"6.1\": system.win = \"7\"; break; default: system.win = \"NT\"; break; &#125; &#125; else if (RegExp[\"$1\"] == \"9x\") &#123; system.win = \"ME\"; &#125; else &#123; system.win = RegExp[\"$1\"]; &#125; &#125;&#125; 根据以上代码检测 Windows 操作系统 1234567891011if (client.system.win == \"2000\") &#123; alert(\"Windows 2000\");&#125; else if (client.system.win == \"XP\") &#123; alert(\"Windows XP\");&#125; else if (client.system.win == \"Vista\") &#123; alert(\"Windows Vista\");&#125; else if (client.system.win == \"7\") &#123; alert(\"Windows 7\");&#125; else if (client.system.win == \"NT\") &#123; alert(\"Windows NT\");&#125; (4)、识别移动设备12345678910111213141516171819202122232425262728293031system.iphone = userAgent.indexOf(\"iPhone\") &gt; -1;system.ipod = userAgent.indexOf(\"iPod\") &gt; -1;system.ipad = userAgent.indexOf(\"iPad\") &gt; -1;// 检测 iOS 版本if (system.mac &amp;&amp; userAgent.indexOf(\"Mobile\") &gt; -1) &#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(userAgent)) &#123; system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\")); &#125; else &#123; // 无法检测出来 system.ios = 2; &#125;&#125;// 检测 Android 版本if (/Android (\\d+\\.\\d+)/.test(userAgent)) &#123; system.android = parseFloat(RegExp.$1);&#125;// 检测 诺基亚 N 系列system.nokiaN = userAgent.indexOf(\"NokiaN\") &gt; -1;// 检测 Windows Mobileif (system.win == \"CE\") &#123; system.winMobile = system.win;&#125; else if (system.win == \"Ph\") &#123; if (/Windows Phone OS (\\d+.\\d+)/.test(userAgent)) &#123; system.win = \"Phone\"; system.winMobile = parseFloat(RegExp[\"$1\"]); &#125;&#125; 检测手机，示例代码如下： 123456789if (client.engine.webkit) &#123; if (client.system.ios) &#123; alert(\"iOS 手机\"); &#125; else if (client.system.android) &#123; alert(\"Android 手机\"); &#125; else if (client.system.nokiaN) &#123; alert(\"诺基亚 N 系列手机\"); &#125;&#125; （5）、识别游戏系统12system.wii = userAgent.indexOf(\"Wii\") &gt; -1;system.ps = /playstation/i.test(userAgent); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第九章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"第八章 BOM","slug":"第八章-BOM","date":"2017-07-24T23:42:23.000Z","updated":"2017-08-13T11:09:18.000Z","comments":true,"path":"2017/07/25/第八章-BOM/","link":"","permalink":"http://panzeyong.com/2017/07/25/第八章-BOM/","excerpt":"","text":"一、window 对象1、全局作用域window 对象具有双重角色 通过 JavaScript 访问浏览器窗口的一个接口； ECMAScript 规定的 Global 对象。 定义全局变量与在 window 对象上直接定义属性区别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上定义的属性可以。 尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在。 书中例子如下： 1234567891011121314151617181920212223// 定义全局变量var age = 29;// 在 window 对象上定义属性window.color = \"Green\";// 在 IE &lt; 9 时抛出错误，在其他所以浏览器中都返回 falsealert(delete window.age);// 在 IE &lt; 9 时抛出错误，在其他所以浏览器中都返回 truealert(delete window.color);function sayAge() &#123; alert(this.age);&#125;alert(age);alert(window.age);sayAge();window.sayAge();alert(window.color); 2、窗口关系以及框架每个框架（frame）都拥有自己的 window 对象，并且保存在 frames 集合钟；每个 window 对象都有一个 name 属性，包含框架名称。 top 对象：始终指向最高（最外）层的框架，也就是浏览器窗口；使用它可以确保在一个框架中正确第访问另外一个框架。（当网页有框架的情况下，window 对象指向的是每个框架特定的实例，与 top 对象不相等；反之，则相同。） parent 对象：始终指向当前框架的直接上层框架。（当网页有框架的情况下，parent 不一定等于 top；反之，则一定相等。） self 对象：始终指向 window，可以与 window 对象互换使用。引入该对象的目的只是为了与 top 和 parent 对象对应起来。 top、parent、self 等对象其实都是 window 的属性，也就是说，可以通过 window.top、window.parent 等访问。 访问框架的方式： 1234567891011// 不推荐，因为在有框架的网页中，每个 window 对象都是指向框架的特定实例，而非指向最外层框架。window.frames[index]window.frames[\"框架名称\"]// 推荐，因为始终指向最高（最外）层的框架，也就是浏览器窗口top.frames[index]top.frames[\"框架名称\"]// 通过集合访问frames[index]frames[\"框架名称\"] 3、窗口位置screenLeft、screenTop、screenX、screenY 这四个属性在各个浏览器中使用情况： 浏览器 / 属性IEChromeSarariOperaFirefoxscreenLeft支持支持支持支持不支持screenTop支持支持支持支持不支持screenX不支持支持支持支持支持screenY不支持支持支持支持支持 跨浏览器获取窗口左边和上边的位置的示例代码： 12var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\" )? window.screenTop : window.screenY; 4、窗口大小innerWidth、innerHeight、outerWidth、outerHegiht 这四个属性在以下浏览器是支持的，不同的是获取的值，具体情况如下： 浏览器 / 属性IE9+ChromeSarariOperaFirefoxinnerWidth页面视图区的大小（减去边框宽度）视口（viewport）大小而非浏览器窗口的大小页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）支持innerHeight页面视图区的大小（减去边框宽度）视口（viewport）大小而非浏览器窗口的大小页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）不页面视图区的大小（减去边框宽度）outerWidth返回浏览器本身窗口的大小视口（viewport）大小而非浏览器窗口的大小返回浏览器本身窗口的大小页面视图容器大小（单个标签页对应的浏览器窗口）返回浏览器本身窗口的大小outerHeight返回浏览器本身窗口的大小视口（viewport）大小而非浏览器窗口的大小返回浏览器本身窗口的大小页面视图容器大小（单个标签页对应的浏览器窗口）返回浏览器本身窗口的大小 document.documentElement.clientWidth、document.documentElement.clientHeight、document.body.clientWidth、document.body.clientHeight 这四个属性作用主要是保存页面视口信息，在不同浏览器使用情况如下： 浏览器 / 属性IEChromeSarariOperaFirefoxdocument.documentElement.clientWidth支持（IE6 中标准模式）支持支持支持支持document.documentElement.clientHeight支持支持支持支持支持document.body.clientWidth支持（混杂模式）支持支持支持支持document.body.clientHeight支持（混杂模式）支持支持支持支持 获取页面视口大小示例代码： 123456789101112var pageWidth = window.innerWidth;var pageHeight = window.innerHeight;if (typeof pageWidth != \"number\") &#123; if (document.compatMode == \"CSS1Compat\") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 5、导航和打开窗口window.open()：既可以导航到特定的 URL，也可以打开一个新的浏览器窗口。接收 4 个参数，具体如下： 加载的 URL； 窗口目标：_self、_parent、_top、_blank（指定窗口的话就在该窗口打开 URL；没有的话就根据浏览器设置打开新标签页或者打开新的窗口）； 特性字符串：不允许出现空格； 布尔值（表示新页面是否取代浏览器历史记录中当前加载页面） 第三个参数设置窗口特性，具体如下： 设置值说明fullscreenyes / no表示浏览器窗口是否最大化。仅限 IEheight数值表示新窗口的高度。不能小于 100left数值表示新窗口的左坐标。不能是负值locationyes / no表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为 no，地址栏可能会隐藏，也可能会被禁止（取决于浏览器）menubaryes / no表示是否在浏览器窗口中显示菜单栏。默认值为 noresizeableyes / no表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为 noscrollbarsyes / no表示如果内容在视口中显示不下，是否允许滚动。默认值为 nostatusyes / no表示是否在浏览器窗口中显示状态栏。默认值 notoolbaryes / no表示是否在浏览器窗口中显示工具栏。默认值为 notop数值表示新窗口的上坐标。不能是负值width数值表示新窗口的宽度。不能小于 100 opener：新创建窗口属性，保存着打开它的原始窗口对象。opener 设置为 null，表示在单独的进程中运行新标签页。（Chrome） 屏蔽弹出窗口方式： 浏览器内置的屏蔽程序阻止的弹出窗口，window.open 很可能返回 null。 浏览器扩展或者其它程序阻止的弹出窗口，window.open() 通常会抛出一个错误。 示例代码如下： 123456789101112131415161718var blocked = false;try &#123; var baiduWin = window.open(\"http://www.baidu.com\", \"topFrame\", \"height=400,widht=600,left=25,top=25,location=no,menubar=no,resizable=true,scrollbars=yes,status=no,toolbar=no\"); if (null == baiduWin) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; alert(\"The popup was blocked !\");&#125; else &#123; alert(\"The popup was not blocked !\"); alert(baiduWin);&#125; 6、间歇调用和超时调用一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。 setTimeout()：超时调用,返回一个数值 ID，表示唯一标识。接收两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多时毫秒） setInterval()：间歇调用。接收两个参数：要执行的代码和每次执行之前需要等待的毫秒数。 clearTimeout()：根据相应的 id 取消调用。 示例代码： 1234567setTimeout(function() &#123; alert(\"Hello World !\");&#125;, 1000);setInterval(function() &#123; alert(\"Hello World\");&#125;, 1000); 7、系统对话框alert()：警告框。 comfirm()：确认对话框。 prompt()：提示对话框。 window.print()：打印。 window.find()：查找。 示例代码如下： 123456789101112alert(\"Hello World !\");if (confirm(\"Are you sure ?\")) &#123; alert(\"I'm so glad you're sure !\");&#125; else &#123; alert(\"I'm sorry to hear you're not sure .\");&#125;var result = prompt(\"What is your name ? \", \"\");if (null != result) &#123; alert(\"Welcome, \" + result);&#125; 二、location 对象location 对象不仅提供与当前窗口中加载的文档有关的信息，还提供了一些导航功能以及将 URL 解析为独立的片段。window.location 和 document.location 引用的同是一个对象，即 location 对象。 location 对象所有属性如下表： 属性名例子说明hash“#contents”返回 URL 中的 hash（# 号后跟或多个字符），如果 URL 中不包含散列，则返回空字符串host“www.wrox.com:80”返回服务器名称和端口号（如果有）hostname“www.wrox.com”返回不带端口号的服务器名称href“http://www.wrox.com“返回当前加载页面的完整 URL。而 location 对象的 toString() 方法也返回这个值pathname“/WileyCDA”返回 URL 中的目录和（或）文件名port“8080”返回 URL 中指定的端口号。如果 URL 中不包含端口号，则这个属性返回空字符串protocol“http”返回页面使用的协议。通常是 http: 或 https:search“?q=javascript”返回 URL 的查询字符串。这个字符串以问号开头 查询参数示例代码： 12345678910111213141516171819202122232425function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"); args = &#123;&#125;; items = qs.length ? qs.split(\"&amp;\") : []; item = null; name = null; value = null; i = 0; len = items.length; for (var i = 0; i &lt; len; i++) &#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 位置操作方法： location.assign(url)：立即打开新 URL 并在浏览器的历史记录中生成一条记录。location.href 与 window.location 效果与之一样。 location.replace(url)：打开新 URL，但是不会下历史记录中生成新记录。 location.reload()：重新加载当前显示的页面。可接收参数，比如 true，表示从服务器加载。 三、navigator 对象navigator 对象属性如下表： 属性或方法说明IEFirefoxSafari/ChromeOperaappCodeName浏览器的名称。通常都是 Mozilla，即使在非 Mozilla 浏览器也是如此3.0+1.0+1.0+7.0+appMinorVersion此版本信息4.0+--9.5+appName完整的浏览器名称3.0+1.0+1.0+7.0+appVersion浏览器的版本。一般不与实际的浏览器版本对应3.0+1.0+1.0+7.0+buildId浏览器编译版本-2.0+--cookieEnabled表示 cookie 是否启用4.0+1.0+1.0+7.0+cpuClass客户端计算机中使用的 CPU 类型（x86、68K、Alpha、PPC 或 Other）4.0+---javaEnabled()表示当前浏览器中是否启用了 Java4.0+1.0+1.0+7.0+language浏览器的主语言4.0+1.0+1.0+7.0+mimeTypes在浏览器中注册的 MIME 类型数组4.0+1.0+1.0+7.0+onLine表示浏览器是否连接到因特网4.0+1.0+-9.5+oscpu客户端计算机的操作系统或使用的 CPU-1.0+--platform浏览器所在的系统平台4.0+1.0+1.0+7.0+plugins浏览器中安装的插件信息的数组4.0+1.0+1.0+7.0+preference()设置用户的首选项-1.5+--product产品名称（如 Gecko）-1.0+1.0+-productSub关于产品的次要信息（如 Gecko 版本）-1.0+1.0+-systemLanguage操作系统的语言4.0+---userAgent浏览器的用户代理字符串3.0+1.0+1.0+7.0+userLanguage操作系统的默认语言4.0+--7.0+userProfile借以访问用户个人信息的对象4.0+---vendor浏览器的品牌-1.0+1.0+-vendorSub有关供应商的次要信息-1.0+1.0+- 检测插件对于非 IE 浏览器，可以使用 navigator 对象提供的 plugins 属性来检测浏览器插件信息，返回的是数组。该数组中的每一项都包含以下属性： name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME 类型数量。 检测插件示例代码（在 IE 中无效）： 1234567891011function hasPlugin(name) &#123; name = name.toLowerCase(); for(var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125; 检测插件示例代码（只在 IE 中有效）： 12345678function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125; 四、screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器信息，比如像素宽度和高度。 screen 对象各种属性如下表： 属性说明IEFirefoxSafari / ChromeOperaavailHeight屏幕的像素高度减系统部件高度之后的值（只读）支持支持支持支持availLeft未被系统部件占用的最左侧的像素值（只读）不支持支持支持不支持availTop未被系统部件占用的最上方的像素值（只读）不支持支持支持不支持availWidth屏幕的像素宽度减去系统部件宽度之后的值（只读）支持支持支持支持bufferDepth读、写用于呈现屏外位图的位数支持不支持不支持不支持colorDepth用于表现颜色的位数；多数系统是 32（只读）支持支持支持支持deviceXDPI屏幕实际的水平 DPI（只读）支持不支持不支持不支持deviceYDPI屏幕实际的垂直 DPI（只读）支持不支持不支持不支持fontSmooth / ingEnabled表示是否启用字体平滑（只读）支持不支持不支持不支持height屏幕的像素高度支持支持支持支持left当前屏幕距离左边的像素距离不支持支持不支持不支持logicalXDPI屏幕逻辑的水平 DPI（只读）支持不支持不支持不支持logicalYDPI屏幕逻辑的垂直 DPI（只读）支持不支持不支持不支持pixelDepth屏幕的位深不支持支持支持支持top当前屏幕距上边的像素距离不支持支持不支持不支持updateInterval读、写以毫秒表示的屏幕刷新时间间隔支持不支持不支持不支持width屏幕的像素宽度支持支持支持支持 history 对象history 对象保存着用户上网的的历史记录。 go()：在用户的历史记录中任意跳转，可以向其也可以向后。该方法接收一个参数，正数表示向前，负数表示向后。 back()：后退。 forward()：前进。 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第八章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"第七章 函数表达式","slug":"第七章-函数表达式","date":"2017-07-09T23:11:07.000Z","updated":"2017-07-23T23:39:20.000Z","comments":true,"path":"2017/07/10/第七章-函数表达式/","link":"","permalink":"http://panzeyong.com/2017/07/10/第七章-函数表达式/","excerpt":"","text":"一、创建函数方式1、函数声明声明函数使用的关键字是 function，紧接着是指定函数名及函数体。每个函数都定义一个非标准的 name 属性，通过该属性可以访问到给函数指定的名字。对于函数声明来说，有一个重要特征就是函数提升，即在执行代码之前会先读取函数声明。 1234function create() &#123; alert(\"函数声明\"); alert(create.name);&#125; 2、函数表达式（匿名函数、拉姆达函数）创建一个函数并将其赋值给一个变量，这样的创建的函数也可以称为匿名函数或者拉达姆函数。匿名函数的 name 属性是空字符串。使用这种方式创建函数时，必须先赋值才可以使用，否则会报错。 123var create = function() &#123; alert(\"函数表达式\");&#125; 二、闭包闭包是指有权访问另一个函数作用域中的变量的函数。而创建闭包的常用方式，就是在一个函数内部创建另一个函数。 1234567891011121314151617function createComparisonFunction(propertyName) &#123; console.log(\"create Comparison Function\"); return function(object1, object2) &#123; console.log(\"Any\"); var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 1、理解作用域链当某个函数被调用时，系统会创建一个执行环境以及相应的作用域链；此时会有一个函数的活动对象（变量对象），包含 arguments 和其它命名参数。该活动对象会加入到作用域链的前端，并且作用域链的终点是全局执行环境。 在创建函数时，系统会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的 [[Scope]] 属性中。当调用该函数时，会为函数创建一个执行环境，然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 函数的执行环境只存在于函数的执行过程中，当执行结束后，活动对象及作用域链被销毁；而全局环境直到程序退出才被销毁。 对于闭包来说情况则不同，由于匿名函数的作用域包含了外部函数，即引用外部函数活动对象；因此，当外部函数执行完毕后，虽然其作用域链被销毁，但是其活动对象仍然留在内存中；直到匿名内部函数被销毁后，此活动对象才会被销毁。 2、闭包与变量闭包只能取得包含函数中任意变量的最后一个值。记住闭包保存的是整个变量对象，而不是某个特殊的变量。 先来看一个例子 1234567891011121314151617181920function createFunctions() &#123; console.log(\"Create Function\"); var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; console.log(\"i : \" + i); result[i] = function() &#123; console.log(\"Result\"); return i; &#125;; &#125; return result;&#125;// 返回的是函数数组var result = createFunctions();for (var i = 0; i &lt; result.length; i++) &#123; alert(result[i]());&#125; 估计很多人跟我一样以为输出的值应该是 0、1、…、9，然而结果却都是 10。说真的，我一开始也懵逼，不知道为什么，但是经过慢慢地调试，稍微了解原因，简单说下自己的理解吧。 当调用函数 createFunctions() 时，for 循环就会被执行，这时数组 result 保存着每次执行后的函数，等到执行完之后，i 的值已经变为 10 了；而由于每个函数的作用域链包含外部函数 createFunctions() 的活动对象，即共享外部函数变量；因此，调用函数数组中每个函数时的返回值都是 10。 那么如何才能做到每个函数的返回值是其索引呢？见以下例子（ps：书中例子） 1234567891011121314151617181920function createFunctions() &#123; var result = new Array(); console.log(\"Create Function\"); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; console.log(\"i : \" + i); return function() &#123; console.log(\"Number : \" + num); return num; &#125; &#125;(i); &#125; return result;&#125;var result = createFunctions();for (var i = 0; i &lt; result.length; i++) &#123; alert(result[i]();&#125; （ps：由于刚接触闭包这个知识点，对书中的例子还不是很理解，后续补上自己的理解。） 3、关于 this 对象this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。但是匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 每个函数被调用时自动取得两个特殊变量：this 和 arguments，那么跟 arguments 跟 this 存在同样的问题。如果想访问作用域中的 arguments 或 this 对象时，必须将该对象的引用保存到另一个闭包能够访问的变量中。 123456789101112var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function() &#123; var that = this; // 关键在这行代码 return function() &#123; return that.name; &#125;; &#125;&#125;; 三、模仿块级作用域在函数中定义的局部变量的生命周期只局限于该函数，函数执行完之后，局部变量也就销毁。但是由于 JavaScript 没有块级作用域的概念，即在函数代码块中定义的变量在代码块之外也能访问到，为了解决这种问题，可以使用匿名函数模仿块级作用域（私有作用域）来解决。语法如下： 123(function() &#123; // 块级作用域&#125;)(); JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换为函数表达式，只需给它加上一对圆括号。 私有作用域这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。 私有作用域这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链。 引用书中例子，如下： 123456789function outputNumbers(count) &#123; (function() &#123; for(var i = 0; i &lt; count; i++) &#123; alert(i); &#125; // 执行完之后 i 销毁 &#125;)(); alert(i); // 报错&#125; 四、私有变量任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量一般包括函数的参数、局部变量和在函数内部定义的其它函数。 特权方法：有权访问私有变量和私有函数的公有方法。 1、创建特权方法的方式第一种方法：在构造函数中定义特权方法（之所以能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所以变量和函数。） 123456789101112131415function MyObject() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; 使用该种方法的缺点是构造函数模式针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这个问题。 第二种方法：通过在私有作用域中定义私有变量或函数，也可以创建特权方法。（原型模式） 12345678910111213141516171819(function() &#123; // 私有变量和私有函数 var privateVaribalbe = 10; function privateFunction() &#123; return false; &#125; // 构造函数 MyObject = function() &#123; &#125;; // 特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 通过这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 该方法与第一种方法的区别在于：私有变量和函数是由实例共享的。 2、模块模式（道格拉斯）模块模式：为单例创建私有变量和特权方法。 模块模式使用场景：如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法。 JavaScript 是以对象字面量的方式来创建单例对象的。 模块模式模板： 123456789101112131415161718var singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 return &#123; publicProperty: true; publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;&#125;(); 创建匿名函数并立即调用匿名函数，将对象字面量作为函数返回值，并将其赋值给变量 singleton；由于对象字面量通过特权方法访问匿名函数中私有变量和私有函数，因此变量 singleton 可以其进行访问。以这种方式创建的每个单例都是 Object 的实例。 3、增强的模块模式在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。 123456789101112131415161718192021var singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 创建自定义类型对象 var object = new CustomType(); object.publicProperty: true; object.publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125;; return object;&#125;(); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第七章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Canvas 用法一：绘制图形","slug":"Canvas-用法一-————-绘制图形","date":"2017-07-09T04:19:11.000Z","updated":"2017-07-13T09:47:09.000Z","comments":true,"path":"2017/07/09/Canvas-用法一-————-绘制图形/","link":"","permalink":"http://panzeyong.com/2017/07/09/Canvas-用法一-————-绘制图形/","excerpt":"","text":"一、Canvas 简介Canvas 翻译过来为画布意思。这好比我们在学画画时，首先要有一块画板，然后使用各种彩色笔在画板上绘制各种各样的图形，最终会呈现给我们一幅优美的画。在这里，Canvas 就相当于画板，我们可以使用画笔在 Canvas 绘制各种各样的图形，最终画出我们想要的图形。 Canvas 是 Android 2D 绘制图形的继承，提供丰富的 API 接口，功能非常强大。根据官方文档的介绍，要绘制某些东西需要 4 中基本组件： 持有像素的位图（Bitmap）； 画布（Canvas）； 绘图元素（Rect）； 画笔（Paint）。 二、Canvas API 简介操作类型相关 APIAPI 解释绘制颜色drawARGB(int a, int r, int g, int b)使用 ARGB 填充整块画布drawColor(int color)使用颜色填充整块画布drawColor(int color, PorterDuff.Mode mode)使用颜色和 PorterDuff.Mode 填充整块画布drawRGB(int r, int g, int b)使用 RGB 填充整块画布绘制点drawPoint(float x, float y, Paint paint)绘制单个点drawPoints(float[] pts, Paint paint)绘制一组点drawPoints(float[] pts, int offset, int count, Paint paint)绘制一系列点绘制直线drawLine(float startX, float startY, float stopX, float stopY, Paint paint)使用画笔绘制直线drawLines(float[] pts, Paint paint)使用画笔绘制一组直线drawLines(float[] pts, int offset, int count, Paint paint)使用画笔绘制一系列直线绘制矩形drawRect(float left, float top, float right, float bottom, Paint paint)使用画笔绘制矩形drawRect(Rect r, Paint paint) drawRect(RectF rect, Paint paint)绘制圆角矩形drawRoundRect(RectF rect, float rx, float ry, Paint paint)使用画笔绘制圆角矩形drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)（Android 5.0 及以上才有）绘制椭圆drawOval(float left, float top, float right, float bottom, Paint paint)（Android 5.0 及以上才有）使用画笔绘制椭圆drawOval(RectF oval, Paint paint)绘制圆drawCircle(float cx, float cy, float radius, Paint paint)使用画笔绘制圆绘制圆弧drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)使用画笔绘制圆弧drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)（Android 5.0 及以上才有） 以上只是部分 API 介绍，随着自己进一步学习，会继续完善。 三、Canvas 用法以上介绍部分 Canvas API，那么接下来的任务是学习如何使用相关 API。 1、绘制颜色Canvas API 提供 4 个方法用于绘制颜色，即用某种颜色填充整块画布。 1234567canvas.drawARGB(225, 0, 255, 0);canvas.drawColor(Color.GREEN);canvas.drawRGB(0, 255, 0);canvas.drawColor(Color.GREEN, PorterDuff.Mode.LIGHTEN); 需要注意的是绘制颜色第 4 种方法（即第 7 行代码）中第二个参数 PorterDuff.Mode，具体请参考官网。（ps：这知识点还不是很了解，有时间再研究。） 对于以下各种图形的绘制，都需要画笔，那么就先来创建画笔。 12345678910111213141516public class CustomView extend View &#123; private Paint mPaint; public CustomView(Context context) &#123; super(context); &#125; public CustomView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); // 设置画笔颜色 mPaint.setStrokeWidth(2); // 设置画笔宽度 mPaint.setStyle(Paint.Style.STROKE); // 设置画笔风格（描边） &#125;&#125; 2、绘制点Canvas API 提供 3 个方法用于绘制单个点、一组点以及一系列点。 123456789// 由于点形状比较小，不容易看清，所以将画笔宽度设置大点mPaint.setStrokeWidth(10);// 绘制单个点，画笔颜色为 Color.GREENcanvas.drawPoint(300, 300, mPaint);//绘制一组点，画笔颜色为 Color.RED mPaint.setColor(Color.RED); canvas.drawPoints(new float[] &#123;400, 400, 300, 500, 500, 500&#125;, mPaint); 有没有发现点的形状是正方形，这是因为 Paint 默认 Paint.Cap 属性是 Paint.Cap.SQUARE。如果要修改该属性，可以调用 Paint 方法 setStrokeCap(Paint.Cap cap) 修改。 3、绘制直线Canvas 提供 3 个方法用于绘制单条直线、一组直线和一系列直线。 12345678910111213mPaint.setStrokeWidth(2);// 绘制单条直线，画笔颜色为 Color.GREENmPaint.setColor(Color.GREEN);canvas.drawPoint(300, 300, mPaint);// 绘制一组直线，画笔颜色为 Color.REDmPaint.setColor(Color.RED);canvas.drawLines(new float[] &#123;400, 400, 300, 500, 300, 500, 500, 500, 500, 500, 400, 400&#125;, mPaint);// 绘制一系列直线，画笔颜色为 Color.MAGENTAmPaint.setColor(Color.MAGENTA);canvas.drawLines(new float[] &#123;400, 250, 300, 350, 300, 350, 500, 350, 500, 350, 400, 250&#125;, 0, 12, mPaint); 看下绘制直线第三种方法，即第 13 行代码，方法原型为：drawLines(float[] pts, int offset, int count, Paint paint) pts：绘制直线所需要的点； offset：跳过点个数，这些点不参与绘制； count：实际参与绘制个数； paint：画笔。 该方法相对比较灵活，可以通过参数 offset、count 设置来决定绘制哪些线段。 4、绘制矩形Canvas API 提供 3 个方法用于绘制矩形。绘制矩形一般只需要两个点就可以绘制，即左上角和右下角这两个点坐标即可。 123456789101112Rect rect = new Rect(getWidth() / 8, getHeight() / 8 + 500, getWidth() / 8 * 7, getHeight() / 8 * 3 + 500);RectF rectF = new RectF(getWidth() / 8, getHeight() / 8 + 200, getWidth() / 8 * 7, getHeight() / 8 * 3 + 200);mPaint.setColor(Color.GREEN);canvas.drawRect(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getWidth() / 8 * 3, mPaint);mPaint.setColor(Color.MAGENTA);canvas.drawRect(rectF, mPaint);mPaint.setColor(Color.RED);canvas.drawRect(rect, mPaint); 5、绘制圆角矩形Canvas API 提供 2 种方法用于绘制圆角矩形，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。 123456789// 第一种绘制圆角矩形方法mPaint.setStrokeWidth(5);RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRoundRect(rect, 50, 50, mPaint);// 第二种绘制圆角矩形方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawRoundRect(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, 50, 50, mPaint);&#125; 6、绘制椭圆Canvas API 提供 2 种方法用于绘制椭圆，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。其实椭圆是被包裹在矩形内，话句话说，是矩形的内切图形。绘制椭圆也很容易，只需传入矩形 RectF 和绘制图形 Paint 就可以。 123456789101112// 第一种绘制椭圆方法RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawLine(getWidth() / 8, getHeight() / 4, getWidth() / 8 * 7, getHeight() / 4, mPaint);canvas.drawLine(getWidth() / 2, getHeight() / 8, getWidth() / 2, getHeight() / 8 * 3, mPaint);canvas.drawRect(rect, mPaint);canvas.drawOval(rect, mPaint);// 第二种绘制椭圆方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawOval(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, mPaint);&#125; 以上多绘制出矩形和两条直线，主要是为了方便看清。 7、绘制圆形Canvas API 提供 1 种方法用于绘制圆形。绘制圆形只需要知道圆心和半径。 1234canvas.drawCircle(getWidth() / 2, getHeight() / 2, 200, mPaint);mPaint.setStrokeWidth(5);mPaint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(getWidth() / 2, getHeight() / 2, mPaint); 这里我把圆心也给画出来了，画笔的宽度设置为 5，容易看清。 8、绘制圆弧Canvas API 提供 2 种方法用于绘制圆弧，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。有必要来解释下这两种方法各个参数的含义，以drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 为例子： oval：矩形； startAngle：起始角度； sweepAngle：绘制圆弧的角度，即扫描过的角度； useCenter：true 或者 false，至于区别通过例子来说明。 paint：画笔。 12345678910111213141516171819// userCenter 为 trueRectF rectF = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRect(rectF, mPaint);mPaint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, 0, 90, true, mPaint);canvas.translate(getWidth() / 16, getHeight() / 3);// userCenter 为 false mPaint.setStyle(Paint.Style.STROKE);RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRect(rect, mPaint);mPaint.setStyle(Paint.Style.FILL);canvas.drawArc(rect, 0, 90, false, mPaint);// 第二种方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawArc(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, 0, 90, false, mPaint);&#125; 第一个图形是 userCenter 为 true 的效果图；第二个图形则是 userCenter 为 false 的效果图。 四、小示例学习了 Canvas 绘制图形的基本用法后，通过一个具体的例子来综合运用绘制图形方法。这个具体的例子是画圆饼，相信大家应该经常看到这种图形。这个例子是参考这篇博客：安卓自定义View进阶-Canvas之绘制图形，先看看自己实现的效果图吧。 简单分析下：画这类图最主要的元素是数据，即总共有多少个模块，每个模块的值具体是多少，每个模块在总数中所占的比例以及用某种颜色表示某个模块。因此，这个可以将其封装为数据类，即 Bean。数据有了之后，接下来就根据我们学过的知识点进行绘制，来看下具体代码吧： 用户数据类 Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Bean &#123; private int color; private float percentage; private String name; private float angle; private float value; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; &#125; public float getPercentage() &#123; return percentage; &#125; public void setPercentage(float percentage) &#123; this.percentage = percentage; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getAngle() &#123; return angle; &#125; public void setAngle(float angle) &#123; this.angle = angle; &#125; public float getValue() &#123; return value; &#125; public void setValue(float value) &#123; this.value = value; &#125;&#125; 自定义 View 绘制圆饼 RoundCakeView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class RoundCakeView extends View &#123; private final static String TAG = RoundCakeView.class.getCanonicalName(); private Paint mPaint; private List&lt;Bean&gt; mList; private float mStartAngle; private int mWidth; private int mHeight; public RoundCakeView(Context context) &#123; super(context); &#125; public RoundCakeView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public RoundCakeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.GREEN); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.mWidth = w; this.mHeight = h; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.d(TAG, \"onDraw()\"); int x = mWidth / 2; int y = mHeight / 2; int r = 200; RectF rectF = new RectF(x - r, y - r, x + r, y + r); float currentAngle = mStartAngle; // draw circle point mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(5); canvas.drawPoint(x, y, mPaint); // draw circle mPaint.setStrokeWidth(0); mPaint.setColor(Color.RED); canvas.drawCircle(x, y, r, mPaint); mPaint.setStyle(Paint.Style.FILL); // draw arc for (int i = 0; i &lt; mList.size(); i++) &#123; Bean bean = mList.get(i); mPaint.setColor(bean.getColor()); canvas.drawArc(rectF, currentAngle, bean.getAngle(), true, mPaint); currentAngle += bean.getAngle(); &#125; &#125; public void setList(List&lt;Bean&gt; list) &#123; this.mList = list; invalidate(); &#125; public void setStartAngle(float angle) &#123; this.mStartAngle = angle; &#125;&#125; 那么接下来就是显示出效果了，先看下布局文件 activity_main.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.pan.canvasdemo.MainActivity\"&gt; &lt;com.pan.canvasdemo.RoundCakeView android:id=\"@+id/rcv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends AppCompatActivity &#123; private final static String TAG = MainActivity.class.getCanonicalName(); private RoundCakeView mView; private int [] mColors = &#123;Color.RED, Color.GREEN, Color.BLUE, Color.DKGRAY, Color.MAGENTA&#125;; private int [] mValues = &#123;23, 98, 122, 78, 225&#125;; private List&lt;Bean&gt; mList = new ArrayList&lt;&gt;(); private float mSum; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); initData(); mView.setStartAngle(0); mView.setList(mList); &#125; private void init() &#123; mView = (RoundCakeView) findViewById(R.id.rcv); &#125; private void initData() &#123; for (int i = 0; i &lt; mValues.length; i++) &#123; mSum += mValues[i]; &#125; for (int i = 0; i &lt; 5; i++) &#123; Bean bean = new Bean(); bean.setColor(mColors[i]); bean.setValue(mValues[i]); bean.setPercentage(bean.getValue() / mSum); bean.setAngle(bean.getPercentage() * 360); bean.setName(i + \"\"); mList.add(bean); Log.d(TAG, \"Value : \" + bean.getValue()); Log.d(TAG, \"Percentage : \" + bean.getPercentage()); Log.d(TAG, \"Angle : \" + bean.getAngle()); &#125; &#125;&#125; 以下就是画圆饼的具体实现，逻辑不是很难懂，加上部分注释应该很容易理解。 参考资料安卓自定义View进阶-Canvas之绘制图形","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://panzeyong.com/categories/Android/"}],"tags":[{"name":"自定义 View","slug":"自定义-View","permalink":"http://panzeyong.com/tags/自定义-View/"}]},{"title":"第 六 章 面向对象的程序设计","slug":"第六章-面向对象的程序设计","date":"2017-06-25T23:56:20.000Z","updated":"2017-07-23T15:07:21.000Z","comments":true,"path":"2017/06/26/第六章-面向对象的程序设计/","link":"","permalink":"http://panzeyong.com/2017/06/26/第六章-面向对象的程序设计/","excerpt":"","text":"一、理解对象1、属性类型 数据属性：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。有以下 4 个描述其行为的特性： [[Configurable]]：表示是否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。一旦该属性定义为不可配置，即 false，那么就再也不可能设置为可配置了，即 true。此时，再调用 Object.defineProperty() 方法修改除 writable 之外的属性都会导致错。在非严格模式下什么也不会发生，而在严格模式下会导致错误。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Writable]]：表示能否修改属性的值。在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致错误。（在对象上直接定义的属性，默认值为 true） [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认属性，必须调用 ECMAScript5 的 Object.defineProperty() 方法。该方法接收三个参数：属性所在的对象、属性的名字、和一个描述符对象。描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。例子如下： 将属性特性 writable 改为只读 12345678910111213141516var person = new Object();person.name = \"Julian\";person.age = 22;person.job = \"Software Engineer\";person.sayName = function() &#123; alert(this.name);&#125;;Object.defineProperty(person, \"name\", &#123; writable : false&#125;);person.sayName(); // 修改之前：Julianperson.name = \"Jack\";person.sayName(); // 修改之后：Julian 将属性特性 configurable 改为不可配置（对象 person 使用上面代码）。 1234567Object.defineProperty(person, \"name\", &#123;configurable : false&#125;);person.sayName(); // 修改之前：Juliandelete persion.name;person.sayName(); // 修改之后：Julian 在将属性特性 configurable 改为不可配置时再修改其它属性特性（writable 除外），抛出错误。 1234567Object.defineProperty(person, \"name\", &#123; value : \"Marry\"&#125;);// 错误提示Uncaught TypeError: Cannot redefine property: name at Function.defineProperty (&lt;anonymous&gt;) 访问器属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Get]]：在读取属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能写入，在非严格模式下写入属性会被忽略；在严格模式下写入属性会抛出错误。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能读取，在非严格模式下读取时返回 undefined；在严格模式下会抛出错误。 访问器不能直接定义，必须使用 Object.defineProperty() 定义。 书中例子，代码如下 123456789101112131415161718192021222324252627282930var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; console.log(\"get\"); return this._year; &#125;, set: function(value) &#123; if (value &gt; 2004) &#123; console.log(\"set\"); this._year = value; this.edition += value - 2004; &#125; &#125;&#125;);// 调用访问器 setbook.year = 2007; alert(book.edition); // 调用访问器 getalert(book.year);// 如果将属性名 “year” 改为 \"_year\"，并设置 book._year = 2007，则会导致无限递归，最终导致错误。// 注：_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问属性。 2、定义多个属性调用方法 Object.defineProperties() 可以为一个对象定义多个属性，该方法接收两个对象参数：第一个对象参数是要添加和修改其属性的对象；第二个对象参数是第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 书中例子，代码如下： 12345678910111213141516171819202122232425262728var book = &#123;&#125;;Object.defineProperties(book, &#123; // 数据属性 _year: &#123; value: 2005 &#125;, // 数据属性 edition: &#123; value: 1 &#125;, // 访问器属性 year: &#123; get: function() &#123; return this._year; &#125;, set: function(value) &#123; if (value &gt; 2005) &#123; this._year = value; this.edition += value - 2005; &#125; &#125; &#125;&#125;); 3、读取属性的特性调用 Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取器描述符的属性名称。返回一个对象。 书中例子，代码如下：（基于以上代码） 123456789101112131415// 数据属性var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); // 2005alert(descriptor.configurable); // falsealert(descriptor.writable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // undefined// 访问器属性var descriptor = Object.getOwnPropertyDescriptor(book, \"year\");alert(descriptor.value); // undefined alert(descriptor.configurable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // functionalert(typeof descriptor.set); // function 二、创建对象1、工厂模式用函数来封装以特定接口创建对象的细节，与 Java 中 class 类似，即将对象类型的属性和方法进行封装。 2、构造函数模式可用来创建特定类型的对象，用 new 操作符来调用，这是与普通函数唯一的区别。 3、原型模式在 JavaScript 中，我们创建的每个函数都包含一个（原型）属性：prototype。prototype 属性是一个指针，指向一个对象，即原型对象，该原型对象包含可由特定类型的所有实例共享的属性和方法。换句话说，该原型对象可以说是调用构造函数而创建的对象实例的原型对象。使用原型对象的好处是让所有对象实例共享它包含的属性和方法。 书中例子，代码如下：（1） 1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = \"Marry\";Person.prototype.age = 22;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName();var person2 = new Person();person2.sayName();alert(person1.sayName == person2.sayName); // true 理解原型对象 每当我们创建新函数时，就会根据特定规则为该函数创建一个 prototype 属性，该属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获取 constructor （构造函数）属性，该属性包含一个指向 prototype 属性所在函数的指针。 prototype 这个属性连接在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 读取对象属性的原则：先从对象实例进行搜索，搜索不到的话再从原型对象进行搜索。 虽然可以通过对象实例访问保存在原型对象中的值，但是却不能通过对象实例修改原型对象中的值。如果我们在对象实例定义与原型对象中同名的属性，则对象实例中的属性会屏蔽原型对象中的属性。 使用 delete 操作符可以则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。 原型与 in 操作符 使用 in 操作符方式：单独使用和在 for-in 循环中使用。 单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象，还是存在于原型中。 在 for-in 中，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将 [[Enumerable]]）标记为 false 属性）的实例属性也会在 for-in 循环中返回。（例子如下） 123456789101112131415161718192021222324252627282930313233343536var object = &#123; toString : function() &#123; return \"toString\"; &#125;, hasOwnProperty : function() &#123; return \"hasOwnProperty\"; &#125;, propertyIsEnumerable : function() &#123; return \"propertyIsEnumerable\"; &#125;, toLocaleString : function() &#123; return \"toLocaleString\"; &#125;, valueOf : function() &#123; return \"valueOf\"; &#125;&#125;;for(var o in object) &#123; if (o == \"toString\") &#123; alert(\"toString\"); alert(o); &#125; else if (o == \"toLocaleString\") &#123; alert(\"toLocaleString\"); &#125; else if (o == \"valueOf\") &#123; alert(\"valueOf\"); &#125; else if (o == \"hasOwnProperty\") &#123; alert(\"hasOwnProperty\"); &#125; else if (o == \"propertyIsEnumerable\") &#123; alert(\"propertyIsEnumerable\"); &#125;&#125; 更简单的原型语法 用一个包含所有属性和方法的对象字面量来重写整个原型对象。需要注意的是 constructor 属性不再指向 prototype 属性所在函数（比如 Person），而是指向 Object 构造函数。 12345678910function Person() &#123;&#125;Person.prototype = &#123; name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; 原型的动态性 对原型对象的任何修改都能够立即从实例上反映出来，原因是实例与原型之间的松散连接关系。 123456789function Person() &#123;&#125; var person = new Person(); Person.prototype.sayHi = function() &#123; alert(\"Hi\");&#125;; person.sayHi(); 如果对原型对象进行重写，那情况就不一样。这时存在两个对象，并且毫无关联。 123456789101112131415function Person() &#123;&#125; var friend = new Person(); Person.prototype = &#123; constructor : Person, name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; friend.sayName(); // error 实例中的指针仅指向原型，而不指向构造函数。 构造函数、原型与实例之间关系 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 4、组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。好处是最大限度地节省了内存。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.language = [\"JavaScript\", \"Java\", \"PHP\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.language.push(\"Python\");alert(person1.language); // \"JavaScript, Java, PHP, Python\"alert(person2.language); // \"JavaScript, Java, PHP\"alert(person1.language == person2.language); // falsealert(person1.sayName == person2.sayName); // true 5、动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 123456789101112function Person(name, age, job) &#123; // 属性 this.name = name; this.age = age; this.job = job; if(typeof this.sayName != \"function\") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125; 6、寄生构造函数模式创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。（与工厂模式类似） 12345678910functuon Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; retrun o;&#125; 7、稳妥构造函数模式稳妥对象：指的是没有公共属性，而且其方法也不引用 this 的对象。 适用场景：一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其它应用程序（如 Mashup 程序）改动时使用。 稳妥构造函数与寄生构造函数模式区别： 稳妥构造函数新创建对象的实例方法不引用 this； 稳妥构造函数不使用 new 操作符调用构造函数。 1234567891011121314function Person(name, age, job) &#123; // 创建要返回的对象 var o = new Object(); // 可以在这里定义私有变量和函数 // 添加方法 o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 继承继承有两种方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。ECMAScript 只支持实现继承，并且主要依靠原型链来实现。 1、原型链让一个引用类型继承另一个引用类型的属性和方法。可以简单概括地说：有一个超类，具有属性和方法；通过 new 操作符创建超类实例赋值给子类，即子类的原型指向超类的原型，创建子类实例，指向子类的原型。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function SuperType() &#123; console.log(\"SuperType\"); this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; console.log(\"getSuperValue\"); return this.property;&#125;;function SubType() &#123; console.log(\"SubType\"); this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();// 使用字面量添加新方法，会导致上一行代码无效（17）SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;;// 添加新方法SubType.prototype.getSubValue = function() &#123; console.log(\"getSubValue\"); return this.subproperty;&#125;;// 覆盖方法SubType.prototype.getSuperValue = function() &#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue());alert(instance.getSubValue());alert(instance.property); 需要注意的要点： 所有引用类型默认继承 Object，而且这个继承也是通过原型链实现的。也就是说，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。 在给原型添加新方法或覆盖方法的代码一定要放在替换原型语句之后。 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。（ps：还不是很理解） 原型链存在问题： 包含引用类型值所带来的问题，即引用类型值的所有属性是被共享的，这就导致一个实例修改其中属性，也会影响到其它实例。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 2、借用构造函数（伪造对象或经典继承）在子类型构造函数的内部调用超类型构造函数。可以这样说，在子类创建新对象时执行超类构造函数中初始化代码，使子类实例各具有自己的一份副本。（ps：纯属自己理解） 1234567891011121314function SuperType() &#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType() &#123; SuperType.call(this);&#125;var instance = new SubType();instance.colors.push(\"pink\");alert(instance.colors); // \"red, blue, green, pink\"var instance = new SubType();alert(instance.colors); // \"red, blue, green\" 相对于原型链优势：在子类构造函数中向超类型构造函数传递参数。 借用构造函数存在问题：方法都在构造函数中定义，函数复用无从谈起。 3、组合继承（伪经典继承）使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance = new SubType(\"Jack\", 22);instance.colors.push(\"black\");alert(instance.colors); // \"red, blue, green, pink\" instance.sayName(); // Jackinstance.sayAge(); // 22var instance = new SubType(\"John\", 21); alert(instance.colors); // \"red, blue, green\"instance.sayAge(); // Johninstance.sayName(); // 21 4、原型式继承在函数先创建一个临时构造函数，将传入的对象作为这个构造函数的原型，最终返回该类型的新实例。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 5、寄生式继承（parasitic）创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。与寄生构造函数和工厂模式类型。 1234567function create(original) &#123; var clone = object(original); // object() 原型式继承函数 clone.sayHi = function() &#123; alert(\"hi\"); &#125;; return clone;&#125; 6、寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非就是超类型原型的副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。(主要是为了避免调用两次超类型构造函数) 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 方法 isPrototypeOf()：确定对象之间是否存在关系，即如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象，则返回 true。 12alert(Person.prototype.isPrototypeOf(person1)); // truealert(Person.prototype.isPrototypeOf(person2)); // true Object.getPrototypeOf()：返回 [[Prototype]] 的值。 12alert(Object.getPrototypeOf(person1) == Person.prototype); // truealert(Object.getPrototypeOf(person1).name); // Marry hasOwnProperty()：可以检测一个属性是存在于实例中，还是存在于原型中。如果给定属性存在于实例对象中，则返回 true；否则返回 false。 12345678910111213alert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // falseperson2.name = \"John\";person1.sayName(); // Marryperson2.sayName(); // Johnalert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // truedelete person2.namealert(person2.name); // Maryalert(person2.hasOwnProperty(\"name\")); // false Object.keys()：获取对象上所有可枚举的实例属性。该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 Object.getOwnPropertyNames()：获取所有实例属性，无论是否可枚举。 Object.create()：该方法用于规范化原型式继承。接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 12345678910var person = &#123; name : \"Julian\", friends : [\"Ruby\", \"Java\", \"JavaScript\", \"Python\"]&#125;;var person1 = Object.create(person, &#123; name : &#123; value : \"John\" &#125;&#125;); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第六章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Picasso 用法及源码解析","slug":"Picasso-用法及源码解析","date":"2017-06-06T23:47:21.000Z","updated":"2017-06-19T15:22:12.000Z","comments":true,"path":"2017/06/07/Picasso-用法及源码解析/","link":"","permalink":"http://panzeyong.com/2017/06/07/Picasso-用法及源码解析/","excerpt":"","text":"Picasso 是 Square 公司开源的一个 Android 平台优秀图片加载框架，易用、代码简洁、可读性高。自己接触的第一个开源图片加载框架也是 Picasso，以前只停留在会用阶段，根本不知道是如何实现的，最近花了点时间看了 Picasso 源码，学到的东西还是蛮多；大概理解实现基本流程。 对于看源码这事，一开始真不知从哪里下手。于是 Google 了，发现很多都是从使用方法入手，理清方法间是如何调用，最后形成自己的线索。本文也是按照这种方式来分析 Picasso 源码。 Picasso 使用方法 使用 Picasso 加载一张图片很简单，一行代码就搞定 12345Picasso.whth(context) .load(R.mipmap.ic_default) .placeholder(R.mipmap.ic_default) .error(R.mipmap.ic_default) .into(imageView); 加载一张图片并且按照指定尺寸以 centerCrop 形式对图片进行缩放 12345Picasso.with(this) .load(R.mipmap.ic_default) .resize(200, 200) .centerCrop() .into(imageView); 加载一张图片并且按照指定尺寸以 centerInside 形式图片进行缩放（注：对图片进行处理时，centerCrop 或 centerInside 只能选择一种方式，并且必须调用方法 resize(targetWidth, targetHeight) 或者 resizeDimen(targetWidthResId, targetHeightResId) 设置大小） 12345Picasso.with(this) .load(R.mipmap.ic_default) .resizeDimen(R.dimen.width, R.dimen.height) .centerInside() .into(imageView); 加载一张图片并且按照一定角度对其进行旋转 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .rotate(20) .into(imageView); 加载一张图片自适应目标视图（由于调整大小适应目标视图，结果导致请求被延迟，直到调整完毕才会发送请求；目标视图只能是 ImageView） 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .fit() .into(imageView); 加载一张图片并设置回调接口 12345678910Picasso.with(this) .load(R.mipmap.ic_launcher) .into(mImageView, new Callback() &#123; @Override public void onSuccess() &#123; &#125; @Override public void onError() &#123; &#125; &#125;); 以上只是 Picasso 简单的用法，至于其它用法看API；接下来分析下源码。 Picasso 源码解析Picasso.with() 方法解析为了探究 Picasso.with() 方法如何实现，唯独从源代码找答案。代码如下： 123456789101112131415161718192021222324252627282930/** * The global default &#123;@link Picasso&#125; instance. * &lt;p&gt; * This instance is automatically initialized with defaults that are suitable to most * implementations. * &lt;ul&gt; * &lt;li&gt;LRU memory cache of 15% the available application RAM&lt;/li&gt; * &lt;li&gt;Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only * available on API 14+ &lt;em&gt;or&lt;/em&gt; if you are using a standalone library that provides a disk * cache on all API levels like OkHttp)&lt;/li&gt; * &lt;li&gt;Three download threads for disk and network access.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * If these settings do not meet the requirements of your application you can construct your own * with full control over the configuration by using &#123;@link Picasso.Builder&#125; to create a * &#123;@link Picasso&#125; instance. You can either use this directly or by setting it as the global * instance with &#123;@link #setSingletonInstance&#125;. */ public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton;&#125; 从注释中可以得到以下几点： 全局默认实例，也就是说只有一个实例存在，从使用单例模式可以看出。 Picasso 采用两级缓存：内存缓存和磁盘缓存。 LRU 内存缓存大小占整个应用可用 RAM 容量的 15%。 磁盘缓存大小占存储空间的 2%，不少于 5 MB，不超过 50 MB。（注：仅适于 API 14+ 或者所使用的第三方库包含 API，比如 OkHttp）。 为磁盘访问和网络访问提供 3 个线程。 这些配置是 Picasso 默认配置的，如果不满足自己的需求，可以自己定制。通过 Picasso.Builder 创建 Picasson 实例，根据自己需要配置相关属性，并调用方法 setSingletonInstance(picasso) 设置为全局实例。 很明显可以看到，使用单例模式来创建 Picasso 实例，保证全局只有一个实例存在。简单说下 with() 方法的实现，singleton 为 null 时调用 Builder 类中 build() 方法创建 singleton 实例并返回，那么接下来就来看 Builder 类中 build() 方法是如何实现的？ Picasso.Builder 中 build() 方法解析源码如下： 12345678910111213141516171819202122public Picasso build() &#123; Context context = this.context; if (downloader == null) &#123; downloader = Utils.createDefaultDownloader(context); &#125; if (cache == null) &#123; cache = new LruCache(context); &#125; if (service == null) &#123; service = new PicassoExecutorService(); &#125; if (transformer == null) &#123; transformer = RequestTransformer.IDENTITY; &#125; Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled);&#125; Builder 类是 Picasso 这个类中的静态内部类，而 build() 方法是 Builder 类中的成员方法，可以看出采用建造者模式。那么 build() 方法实现的功能主要有： 创建默认下载器 Downloader 创建默认内存缓存 LruCache （由于接口 Cache 支持多线程访问，所以实现该接口时需确保线程安全） 创建默认线程池 PicassoExecutorService 创建默认请求转发器 RequestTransformer 创建默认统计 Stats 创建默认调度器 Dispatcher 创建 Picasso 实例 那么这些实例是如何创建的，下面主要通过流程图来解析（主要是方法间的调用以及方法内部部分细节）。 Downloader 是一个接口，无法实例化，需要通过实现类创建实例，该接口的功能主要从磁盘缓存加载图片或网络下载图片。OkHttpDownloader 和 UrlConnectionDownloader 分别实现该接口，那么创建实例也是通过这两个实现类来创建的，那么来看下实例化 Downloader 流程。 LruCache 是内存缓存类，实现接口 Cache，采用最近最少使用算法。 PicassoExecutorService 继承 ThreadPoolExecutor，是线程池，供图片下载，线程数根据不同网络类型设置，默认的线程数是 3 个，直接通过 new 操作符实例化对象。 RequestTransformer 是一个接口，功能是在发送请求之前对图片进行转换处理。从源码中可以看出，这是一个测试功能，在后续版本可能不兼容，使用该功能时得谨慎。 对于 Stats 实例的创建，直接 new 一个对象，那么主要来看该构造方法做了哪些操作？代码如下： 1234567Stats(Cache cache) &#123; this.cache = cache; this.statsThread = new HandlerThread(STATS_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); this.statsThread.start(); Utils.flushStackLocalLeaks(statsThread.getLooper()); this.handler = new StatsHandler(statsThread.getLooper(), this);&#125; 主要是实例化对象，结合注释应该不难理解。 Dispatcher 实例的创建与 Stats 类似，代码如下： 12345678910111213141516171819202122232425Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler, Downloader downloader, Cache cache, Stats stats) &#123; // dispatcherThread 是子线程，注意记得调用 start() 方法 this.dispatcherThread = new DispatcherThread(); this.dispatcherThread.start(); Utils.flushStackLocalLeaks(dispatcherThread.getLooper()); this.context = context; this.service = service; this.hunterMap = new LinkedHashMap&lt;String, BitmapHunter&gt;(); this.failedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedTags = new HashSet&lt;Object&gt;(); // 注意该 handler 是在子线程的 this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this); this.downloader = downloader; // 在主线程 this.mainThreadHandler = mainThreadHandler; this.cache = cache; this.stats = stats; this.batch = new ArrayList&lt;BitmapHunter&gt;(4); this.airplaneMode = Utils.isAirplaneModeOn(this.context); this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE); this.receiver = new NetworkBroadcastReceiver(this); receiver.register();&#125; 最后，也是最重要的一点，那就是 Picasso 实例的创建，先看下代码吧 1234567891011121314151617181920212223242526272829303132333435363738Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) &#123; this.context = context; this.dispatcher = dispatcher; this.cache = cache; this.listener = listener; this.requestTransformer = requestTransformer; this.defaultBitmapConfig = defaultBitmapConfig; int builtInHandlers = 7; // Adjust this as internal handlers are added or removed. int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0); List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); this.stats = stats; this.targetToAction = new WeakHashMap&lt;Object, Action&gt;(); this.targetToDeferredRequestCreator = new WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;(); this.indicatorsEnabled = indicatorsEnabled; this.loggingEnabled = loggingEnabled; this.referenceQueue = new ReferenceQueue&lt;Object&gt;(); this.cleanupThread = new CleanupThread(referenceQueue, HANDLER); this.cleanupThread.start();&#125; 除了对一些对象赋值外，重要的一点就是创建和添加 RequestHandler，代码主要在 19 ~ 29 行，比如文件、网络、资源等处理器。至此，Picasso 实例也就创建完毕了，那么接下来看 load() 方法是如何实现的。 Picasso.load() 方法解析load() 有多个重载方法，可以传入 resourceId、string、file、uri，但是最后都是返回 RequestCreator 实例，接下来就来看该方法如何实现？代码如下： 1234567public RequestCreator load(int resourceId) &#123; if (resourceId == 0) &#123; throw new IllegalArgumentException(\"Resource ID must not be zero.\"); &#125; return new RequestCreator(this, null, resourceId);&#125; 很明显地看出，调用 load() 方法后返回的是 RequestCreator 实例，那么来看下 RequestCreator 构造方法是咋样的，代码如下： 123456RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123; if (picasso.shutdown) &#123; throw new IllegalStateException(\"Picasso instance already shut down. Cannot submit new requests.\"); &#125; this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig); &#125; 创建 Request.Builder 对象，并将需要加载图片信息封装到该对象里，采用建造者模式。对于一些操作比如 rotate、centerCrop、centerInside、resize 等，其实只是修改其状态，真正执行操作是方法 into，该方法是核心方法，以下重点分析。 into() 方法解析into() 有 5 个重载方法，每个方法实现的主要功能基本相同，但是稍微还是有点不一样的。以常用 into(ImageView target) 这个方法为例子来讲解下内部是如何实现的？由于个人比较喜欢画流程图来理清方法之间调用关系，于是就有下面的流程图： 结合流程图再来看源码应该会比较好理解，代码如下： 123public void into(ImageView target) &#123; into(target, null);&#125; 该方法所持有的 ImageView 实例是一个弱引用，内存不足情况下可以自动被垃圾回收器回收。很明显，该方法调用重载方法 into(target, null)，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); checkMain(); if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123; if (data.hasSize()) &#123; throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action);&#125; 参数 Callback 是一个强引用，将会阻止 Activity 或者 Fragment 被回收，从而导致内存泄漏。如果使用该方法，在释放资源时最好调用 Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求，以免造成内存泄漏。从源码可以清晰地看出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 判断目标组件 ImageView 是否为 null；如果不为 null，则继续执行；否则抛出异常。 检查发送请求是否包含要加载图片 uri 或 resourceId；如果没有，则调用Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求（后面讲解该方法），并检查是否设置默认图片；否则继续执行。 检查是否调用方法 fit()，即 deferred 是否为 true，true 表示调用，false 表示调用 unfit() 方法；调用该方法意味着延迟加载图片，并且不能与方法 resize() 同时使用。 为加载图片创建请求。 为每个请求创建 key，主要是为了方便存储。 根据缓存策略判断是否从内存缓存读取。 是否设置默认图片。 创建对应的 Action 实例，在这里是 ImageViewAction。 入队和提交 action。 以上是总体概括，接下来逐一看具体实现。 那么先来看下 cancelRequest(android.widget.ImageView) 具体实现，代码如下： 123public void cancelRequest(ImageView view) &#123; cancelExistingRequest(view);&#125; 只有一行代码，调用 cancelExistingRequest(view) 方法，看下具体实现： 12345678910111213141516private void cancelExistingRequest(Object target) &#123; checkMain(); Action action = targetToAction.remove(target); if (action != null) &#123; action.cancel(); dispatcher.dispatchCancel(action); &#125; if (target instanceof ImageView) &#123; ImageView targetImageView = (ImageView) target; DeferredRequestCreator deferredRequestCreator = targetToDeferredRequestCreator.remove(targetImageView); if (deferredRequestCreator != null) &#123; deferredRequestCreator.cancel(); &#125; &#125; &#125; 按照惯例，先列出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 通过 key 从 targetToAction 移除对应 action。 如果 action 不为 null，执行一些取消操作，相当于释放资源。 如果目标组件是 ImageView，则检查是否调用 fit() 方法，是的话就执行一些取消操作。 接着来看下取消操作方法 dispatcher.dispatchCancel(action) 具体实现： 123void dispatchCancel(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));&#125; 很明显是通过 Handler 消息机制来处理的。即 Dispatcher 类中 DispatcherHandler 发送消息 REQUEST_CANCEL，并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performCancel(action) 具体实现： 1234567891011121314151617181920212223242526void performCancel(Action action) &#123; String key = action.getKey(); BitmapHunter hunter = hunterMap.get(key); if (hunter != null) &#123; hunter.detach(action); if (hunter.cancel()) &#123; hunterMap.remove(key); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId()); &#125; &#125; &#125; if (pausedTags.contains(action.getTag())) &#123; pausedActions.remove(action.getTarget()); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId(), \"because paused request got canceled\"); &#125; &#125; Action remove = failedActions.remove(action.getTarget()); if (remove != null &amp;&amp; remove.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, remove.getRequest().logId(), \"from replaying\"); &#125;&#125; 从以上代码很清晰地看出该方法主要做一些取消、移除操作，即释放资源。以上就是 cancelExistingRequest(view) 内部实现解析。 回到 into(target, null) 内部实现，看下创建请求 createRequest(started) 具体实现： 12345678910111213141516171819202122232425private Request createRequest(long started) &#123; int id = nextId.getAndIncrement(); Request request = data.build(); request.id = id; request.started = started; boolean loggingEnabled = picasso.loggingEnabled; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString()); &#125; Request transformed = picasso.transformRequest(request); if (transformed != request) &#123; // If the request was changed, copy over the id and timestamp from the original. transformed.id = id; transformed.started = started; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), \"into \" + transformed); &#125; &#125; return transformed;&#125; 其实实现逻辑很简单，对要加载图片的具体信息封装成 Request；通过 Request 创建对应 key，那么来看下是如何创建的，即 createKey(request) 方法具体实现： 12345static String createKey(Request data) &#123; String result = createKey(data, MAIN_THREAD_KEY_BUILDER); MAIN_THREAD_KEY_BUILDER.setLength(0); return result;&#125; 逻辑很简单，调用方法 createKey(data, MAIN_THREAD_KEY_BUILDER)，看下具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041static String createKey(Request data, StringBuilder builder) &#123; if (data.stableKey != null) &#123; builder.ensureCapacity(data.stableKey.length() + KEY_PADDING); builder.append(data.stableKey); &#125; else if (data.uri != null) &#123; String path = data.uri.toString(); builder.ensureCapacity(path.length() + KEY_PADDING); builder.append(path); &#125; else &#123; builder.ensureCapacity(KEY_PADDING); builder.append(data.resourceId); &#125; builder.append(KEY_SEPARATOR); if (data.rotationDegrees != 0) &#123; builder.append(\"rotation:\").append(data.rotationDegrees); if (data.hasRotationPivot) &#123; builder.append('@').append(data.rotationPivotX).append('x').append(data.rotationPivotY); &#125; builder.append(KEY_SEPARATOR); &#125; if (data.hasSize()) &#123; builder.append(\"resize:\").append(data.targetWidth).append('x').append(data.targetHeight); builder.append(KEY_SEPARATOR); &#125; if (data.centerCrop) &#123; builder.append(\"centerCrop\").append(KEY_SEPARATOR); &#125; else if (data.centerInside) &#123; builder.append(\"centerInside\").append(KEY_SEPARATOR); &#125; if (data.transformations != null) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, count = data.transformations.size(); i &lt; count; i++) &#123; builder.append(data.transformations.get(i).key()); builder.append(KEY_SEPARATOR); &#125; &#125; return builder.toString();&#125; 很简单，根据 Request 设置的属性拼接为字符串，作为最终的 key 并返回。 当我们调用不同 into() 方法时，Picasso 就会实例化不同的 Action，而这里我们是以 into(ImageView) 为例子，因此会实例化 ImageViewAction，在 ImageView 有回调方法，供我们使用，后续会看到。一切都准备就绪，那么就可以入队和提交 action。那么是如何实现的呢？来看下具体实现： 123456789void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action);&#125; 通过 key 从 targetToAction 获取 action，不存在的话就执行检查操作并将 action 插入到 targetToAction，最后调用 submit(action)，具体实现如下： 123void submit(Action action) &#123; dispatcher.dispatchSubmit(action);&#125; 最后还是回到 Dispatcher，通过 DispatcherHandler 消息机制发送消息 REQUEST_SUBMIT，并在其回调方法 并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 123456789101112131415161718@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performSubmit(action) 具体实现： 123void performSubmit(Action action) &#123; performSubmit(action, true);&#125; 只有一行代码，调用方法 performSubmit(action, true)，具体实现如下： 12345678910111213141516171819202122232425262728293031323334void performSubmit(Action action, boolean dismissFailed) &#123; if (pausedTags.contains(action.getTag())) &#123; pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), \"because tag '\" + action.getTag() + \"' is paused\"); &#125; return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\"); &#125; return; &#125; hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); hunterMap.put(action.getKey(), hunter); if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125;&#125; 简要概括下该方法实现的主要功能： 检查标记 tag 请求是否被取消，如果被取消，则将对应 action 插入到 pausedActions 并退出程序；否则继续执行。 通过 key 从 hunterMap 获取相应 BitmapHunter 并判断其是否为 null，如果不为 null，则调用其方法 attach(Action) 并结束退出程序；否则继续执行。简要说明下，BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务。 检查线程池是否停止工作。 创建 BitmapHunter 实例，即调用方法 forRequest(action.getPicasso(), this, cache, stats, action) 将 hunter 提交到线程池并执行，即调用 service.submit(hunter) 看下 forRequest() 方法具体实现： 12345678910111213141516static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) &#123; Request request = action.getRequest(); List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers(); // Index-based loop to avoid allocating an iterator. //noinspection ForLoopReplaceableByForEach for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);&#125; 通过调用 RequestHandler 中 canHandleRequest(Request) 方法逐一检查对应 RequestHandler，并创建 BitmapHunter 对象返回。然后将 hunter 提交到线程池并执行。submit(Runnable) 是接口 ExecutorService 里的方法，PicassoExecutorService 实现接口 ExecutorService，因此 submit(Runnable) 方法的实现逻辑在 PicassoExecutorService 类里面，具体实现如下： 123456@Override public Future&lt;?&gt; submit(Runnable task) &#123; PicassoFutureTask ftask = new PicassoFutureTask((BitmapHunter) task); execute(ftask); return ftask;&#125; execute(ftask) 执行任务，由于 BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务；而在该方法里会调用线程 start() 方法，意味着 BtimapHunter 中 run() 会被调用，真正执行任务逻辑在该方法里面实现，接下来的重点肯定是来研究该方法内部实现逻辑，在研究源代码之前，先来看该方法内部实现流程图： 同样结合流程图来解析 run() 内部实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; try &#123; updateThreadName(data); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this)); &#125; result = hunt(); if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125;&#125; 简要概括下该方法实现的主要功能： 更新线程名字。 返回 Bitmap 对象并赋值给 result。 判断返回结果 result 是否为 null，如果为 null，则调用 dispatcher.dispatchFailed(this)；否则调用 dispatcher.dispatchComplete(this) 各种异常处理。 从源代码可以看出，核心的逻辑在方法 hunt()，那么它的内部实现又是怎么呢？具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\"); &#125; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\"); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap;&#125; 代码实现确实很复杂，没事，先概括下其实现的主要小功能，再逐一解析： 根据缓存策略判断是否从内存缓存读取 bitmap，true 表示直接读取并返回 bitmap；否则继续执行。 根据不同请求资源调用相应 RequestHandler 中 load() 方法下载图片，这里以网络请求资源为例子来讲解，即 NetworkRequestHandler。 从下载返回结果 RequestHandler.Result 获取 bitmap，判断是否为 null 做出相应的处理。 重点来 NetworkRequestHandler 类 load() 方法具体实现： 1234567891011121314151617181920212223242526272829@Overridepublic Result load(Request request, int networkPolicy) throws IOException &#123; Response response = downloader.load(request.uri, request.networkPolicy); if (response == null) &#123; return null; &#125; Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; return new Result(bitmap, loadedFrom); &#125; InputStream is = response.getInputStream(); if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven't found // root cause to this but retrying the request seems safe to do so. if (loadedFrom == DISK &amp;&amp; response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new ContentLengthException(\"Received response with 0 content-length header.\"); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; return new Result(is, loadedFrom); &#125; 第 3 行代码实现图片下载，即客户端发送网络请求，服务端对客户端的请求作出响应，客户端根据服务端返回的结果作出处理。那么是如何实现下载的呢？downloader 是 Downloader 实例，而 Downloader 是接口，无法实例化，需要在子类实例化，而该接口有两个实现类：OkHttpDownloader 和 UrlConnectionDownloader。至于调用哪个类 load() 方法，取决于当前 sdk 最低版本是否在 API 14及以上。这里以 OkHttpDownloader 类 load() 方法为例来讲解是如何实现下载的，代码如下： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Response load(Uri uri, int networkPolicy) throws IOException &#123; CacheControl cacheControl = null; if (networkPolicy != 0) &#123; if (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; cacheControl = CacheControl.FORCE_CACHE; &#125; else &#123; CacheControl.Builder builder = new CacheControl.Builder(); if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; builder.noCache(); &#125; if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; builder.noStore(); &#125; cacheControl = builder.build(); &#125; &#125; Request.Builder builder = new Request.Builder().url(uri.toString()); if (cacheControl != null) &#123; builder.cacheControl(cacheControl); &#125; com.squareup.okhttp.Response response = client.newCall(builder.build()).execute(); int responseCode = response.code(); if (responseCode &gt;= 300) &#123; response.body().close(); throw new ResponseException(responseCode + \" \" + response.message(), networkPolicy, responseCode); &#125; boolean fromCache = response.cacheResponse() != null; ResponseBody responseBody = response.body(); return new Response(responseBody.byteStream(), fromCache, responseBody.contentLength()); &#125; 第 3 - 17 行代码主要是设置缓存策略；第 24 行通过调用 OkHttp 库 API 实现图片下载任务，并返回响应结果 com.squareup.okhttp.Response；最后对响应结果作出相应处理并创建 Response 对象返回。 再回到 NetworkRequestHandler 类 load() 方法，从返回 Response 对象调用 getBitmap() 方法获取 Bitmap 对象并判断其是否为 null，如果不为 null，则将 bitmap 和 loadedfrom 传入 Result 构造器方法中，创建 Result 对象并返回；否则调用 getInputStream() 方法获取输入流，不为 null 的话则创建 Result 对象并返回。 回到 hunt() 方法，从返回结果 result 获取数据类型为 Bitmap 对象 bitmap，并判断其是否为 null 作出不同的处理。如果 bitmap 不为 null，则判断原先发送加载图片请求 Request 是否需要对图片进行转换处理，即裁剪、缩放、重置大小等；不需要的话直接返回 bitmap；需要的话做转换处理后再返回 bitmap；如果 bitmap 为 null，则从 result 获取输入流 InputStream，并对 is 进行解析转换成 Bitmap 类型，将获取到的结果返回。 hunt() 方法解析完了，回到 run() 方法。根据调用方法 hunt() 返回结果 result，类型为 Bitmap，判断其是否为 null 并作出相应的处理。那么就来看下不为 null 的情况下又做了什么操作，即第 14 行代码，具体实现如下： 123void dispatchComplete(BitmapHunter hunter) &#123; handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));&#125; 很明显，又采用 Handler 消息机制处理，即 Dispatcher 类中 DispatcherHandler 发送消息 HUNTER_COMPLETE，其回调方法 handleMessage(final Message msg) 收到消息后并处理。说明一下，DispatcherHandler 所在的线程为子线程，即 DispatcherThread。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 在其回调方法中，核心代码是第 6 行，具体实现如下： 12345678910void performComplete(BitmapHunter hunter) &#123; if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; hunterMap.remove(hunter.getKey()); batch(hunter); if (hunter.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), \"for completion\"); &#125;&#125; 根据发送请求设置的内存缓存策略判断是否将其结果写入到内存中，并通过 key 从 hunterMap 移除 hunter，最后再对 hunter 作出处理，即 第 6 行代码，具体实现如下： 123456789private void batch(BitmapHunter hunter) &#123; if (hunter.isCancelled()) &#123; return; &#125; batch.add(hunter); if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123; handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY); &#125; &#125; 看第 7 行代码，同时采用 Handler 消息机制发送消息，跟上面一样。最终会转到 Dispatcher 类 performBatchComplete() 方法，具体实现如下： 123456void performBatchComplete() &#123; List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);&#125; 核心代码是第 4 行，同样才 Handler 消息机制发送消息，但是此时与之上有所不一样，即 mainThreadHandler 所在线程是主线程，也就是说，此时将任务从子线程切换到主线程，以便可以进行 UI 更新操作，那么赶快来看下在主线程是如何实现的？代码如下： 12345678910111213141516@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_BATCH_COMPLETE: @SuppressWarnings(\"unchecked\") List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = batch.size(); i &lt; n; i++) &#123; BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); &#125; break; default: throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125;&#125; 根据获取到 BitmapHunter 列表大小依次调用 Picasso 中 complete(BitmapHunter) 方法，那么又是怎样实现的呢，代码如下： 1234567891011121314151617181920212223242526272829303132void complete(BitmapHunter hunter) &#123; Action single = hunter.getAction(); List&lt;Action&gt; joined = hunter.getActions(); boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty(); boolean shouldDeliver = single != null || hasMultiple; if (!shouldDeliver) &#123; return; &#125; Uri uri = hunter.getData().uri; Exception exception = hunter.getException(); Bitmap result = hunter.getResult(); LoadedFrom from = hunter.getLoadedFrom(); if (single != null) &#123; deliverAction(result, from, single); &#125; if (hasMultiple) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = joined.size(); i &lt; n; i++) &#123; Action join = joined.get(i); deliverAction(result, from, join); &#125; &#125; if (listener != null &amp;&amp; exception != null) &#123; listener.onImageLoadFailed(this, uri, exception); &#125;&#125; 从 hunter 获取单个 action、合并 actions 以及其它信息，比如 uri、exception 等。如果获取到的 action 不为空，则派发 action，即第 18 行代码，具体实现如下： 12345678910111213141516171819202122private void deliverAction(Bitmap result, LoadedFrom from, Action action) &#123; if (action.isCancelled()) &#123; return; &#125; if (!action.willReplay()) &#123; targetToAction.remove(action.getTarget()); &#125; if (result != null) &#123; if (from == null) &#123; throw new AssertionError(\"LoadedFrom cannot be null.\"); &#125; action.complete(result, from); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), \"from \" + from); &#125; &#125; else &#123; action.error(); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_ERRORED, action.request.logId()); &#125; &#125;&#125; 从以上代码可以清晰地看出，根据 result 是否为空分别调用 Action 的回调方法，即 complete() 与 error()。先来看下 complete() 具体实现： 1234567891011121314151617181920@Overridepublic void complete(Bitmap result, Picasso.LoadedFrom from) &#123; if (result == null) &#123; throw new AssertionError( String.format(\"Attempted to complete action with no result!\\n%s\", this)); &#125; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; Context context = picasso.context; boolean indicatorsEnabled = picasso.indicatorsEnabled; PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled); if (callback != null) &#123; callback.onSuccess(); &#125;&#125; 逻辑很简单，前部分主要是做一些检查操作，真正核心代码是第 15 行代码，即将下载获取到的图片渲染到 UI 上，意味着成功地加载一张图片。那么 error() 方法又做了什么操作呢？具体实现如下： 123456789101112131415public void error() &#123; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; if (errorResId != 0) &#123; target.setImageResource(errorResId); &#125; else if (errorDrawable != null) &#123; target.setImageDrawable(errorDrawable); &#125; if (callback != null) &#123; callback.onError(); &#125;&#125; 逻辑也很简单，如果我们有设置错误时显示图片的话，该方法就将错误时显示图片渲染出来。 那么这是单个 action 的处理逻辑，如果有合并 actions 的，执行的逻辑也一样，即对其进行遍历，获取单个 action，再派发 action，实现的代码在 complete(BitmapHunter) 方法第 21 - 27 行。 好吧， 使用 Picasso 开源框架成功加载一张图片的具体流程大概就这样了。由于自己能力水平有限，在讲解过程中难免有错误，如果您看到了，欢迎指正出来，大家一起学习，共同进步 ！！！ 参考资料http://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://panzeyong.com/categories/Android/"}],"tags":[{"name":"优秀开源框架","slug":"优秀开源框架","permalink":"http://panzeyong.com/tags/优秀开源框架/"}]},{"title":"JobScheduler 用法","slug":"JobScheduler-用法","date":"2017-05-21T04:28:37.000Z","updated":"2017-06-19T14:49:53.000Z","comments":true,"path":"2017/05/21/JobScheduler-用法/","link":"","permalink":"http://panzeyong.com/2017/05/21/JobScheduler-用法/","excerpt":"","text":"背景先来聊聊怎么会知道 JobSchduler 这神奇的东西。公司项目有这么一个需求：平板上实时记录小朋友的学习情况，然后生成学习报告上传到服务器，供手机端查看。原先的做法是开启服务，在服务里注册广播接收器，当广播接收器接收到 action，就会将数据上传，在网络正常的情况下，该做法是没有问题的；但是当网络很差的情况下，有可能造成上传失败，数据丢失。后来我采用一种方式：当上传失败时，开启定时器上传，直到成功为止。原本以为这样就解决问题，可是后来做后台的同事说由于设置时间短，访问量多，造成服务器流量过大，希望我能找另外一种解决方法。这时 Leader 跟我说采用 JobScheduler，它完全有系统控制，满足一定的条件时触发任务。于是我马上 Google，看看这玩意到底是啥？经过搜索一番，发现 JobScheduler 功能挺强大的。下面是自己学习 JobSchduler 小结。 JobScheduler 是在 Android 5.0 Google 推出的一个新组件，它的出现主要是为了解决某些任务需要在满足一个或多个条件的情况下才触发的需求，这些条件比如网络状态、电池充电、数据变化、自己设定的条件等，在满足条件时会触发相应的 JobScheduler 完成相应的任务。这个过程只需我们对要执行的任务设定条件，其它都由系统控制完成的，无需我们去控制任务。在学习 JobScheduler 的用法之前，先来了解相关的 API，这里涉及到 JobScheduler、JobInfo、JobParameters、JobService 这四个类。 API 讲解JobScheduler先来看下官方文档对 JobScheduler 的描述： 根据应用程序自己的进程中调度各种类型的任务。 关于可以运行的任务类型以及如何构建它们的更多描述，请参阅 JobInfo。你将构建这些 JobInfo 对象,并调用 JobScheduler 方法 schdule(JonInfo)) 将这些 JobInfo 对象传给它。当设定的条件满足时，系统将会在你应用程序 JobService 上执行相应的任务。当你使用 JobInfo.Builder(int, android.content.ComponentName)) 创建你的 JobInfo 时，意味着已经确定哪个 JobService 将执行你的任务逻辑。 框架对于你接收回调的时机很智能的，并且尝试尽可能地分批处理和延迟它们。通常来说，如果你没有为你的任务设置最后期限，那么就会根据 JobScheduler 内部队列当前的状态在任何时刻来执行它们；可是只要到下一次设备连接电源，那么任务就有可能被延迟。 你不能直接实例化 JobScheduler，而是需要通过 Context.getSystemService(Context.JOB_SCHEDULER_SERVICE)) 获取实例。 从官方文档可以知道，JobScheduler 的职责是调度任务、取消任务。JobScheduler 提供 2 个常量和 5 个方法，在了解它们之前，先来了解如何获取 JobScheduler 实例。正如官方文档所介绍的，通过获取系统服务来获取的，代码如下： 1JobScheduler jobScheduler = (JobScheduler) Context.getSystemService(Context.JOB_SCHEDULER_SERVICE); 接下来来了解两个常量的具体含义 RESULT_FAILURE：调度任务失败时返回值。 RESULT_SUCCESS：调度任务成功时返回值。 JobScheduler 提供 5 个方法供我们使用，让我们来了解下这 5 个方法的具体用法 cancel(int jobId)：取消 JobScheduler 内部队列 id 为 jobId 待处理任务。 cancelAll()：取消在这个应用程序上 JobScheduler 已经注册的所有任务。 getAllPendingJobs()：检索 JobScheduler 待处理所有任务。 getPendingJob(int jobId)：检索 JobScheduler 内部队列 id 为 jobId 待处理任务。 schedule(JobInfo job)：调度任务。 JobInfoJobInfo 对一个即将被执行的任务的信息进行封装，然后供 JobScheduler 调度。由于 JobInfo 包含的信息比较多，所有采用建造者模式来构建其实例，即 JobInfo.Builder 来创建。 来看下官方文档的描述： 将要调度的任务所需的参数（信息）封装为 JobInfo 对象传递给 JobScheduler。使用 JobInfo.Builder) 创建 JobInfo 实例。当你正在创建 JobInfo 对象时，你必须至少指定一项约束条件。这样做的目标是为你想完成的任务提供优先级高调度。如果你没有指定任何一项约束时，你的 app 会抛出异常。 那么来看下如何创建 JobInfo 实例 123JobInfo.Builder builder = new JobInfo.Builder(jobId, componentName);builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);JobInfo jobInfo = builder.build(); 由于创建 JobInfo 对象时至少指定一项约束条件，所以以上只是指定请求网络类型，至于其它属性可以根据自己的需求指定。那么 JobInfo 到底有哪些属性呢？下面一一揭晓。 先来看下 JobInfo 提供常量： BACKOFF_POLICY_EXPONENTIAL：退避策略，任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：退避策略，任务失败时等待间隔呈线性增长。 DEFAULT_INITIAL_BACKOFF_MILLIS：默认情况下任务的 backoff，以毫秒为单位。 MAX_BACKOFF_DELAY_MILLIS：允许任务最大 backoff，以毫秒为单位。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NONE：默认值，没联网。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 JobInfo 设置属性的方法由 JobInfo.Builder，那么来看下提供哪些方法设置属性 setRequiredNetworkType (int networkType)：设置网络类型。如果任务需要通过网络访问服务器，但是没有调用该方法设置网络类型时，那么任务不会被执行。提供四个参数可以设置： NETWORK_TYPE_NONE：默认值，不连接网络。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 setRequiresCharging (boolean requiresCharging)：设置是否连接电源，默认值为 false。 setRequiresDeviceIdle (boolean requiresDeviceIdle)：设置是否需要设备处于空闲模式，默认值为 false。空闲模式是系统提供的一种松散模式，意味着设备没有在使用或者已经有一段时间没有使用，这正是执行繁重任务的好时机。 addTriggerContentUri (JobInfo.TriggerContentUri uri)：API 24 支持使用 content provider 变化作为触发任务执行的时机。需要指定触发 URL，并通过 ContentObserver 监听 content provider 变化，从而触发任务的执行。注意设置该属性后，不能设置 setPeriodic(long) 或者 setPersisted(boolean) 属性，也就是说不能与他们任何一个一起使用。因为他们之间是不兼容的，如果一起使用的话，当 build() 被调用时，会抛出 IllegalArgumentException 异常。为了持续监听 content 变化，需要在 JobService 完成最近变化执行的任务之前，调用新的 JobInfo 观察相同的 URL。 setTriggerContentMaxDelay (long durationMs)：设置当第一次监听到 content 变化到任务执行时可以延迟的最大时间，以毫秒为单位。 setTriggerContentUpdateDelay (long durationMs)：设置当监听到 content 变化时到任务执行时可以延迟的时间，如果在这期间监听到更多变化，那么延迟时间的计时将被重置到最近一次更改开始。 setBackoffCriteria (long initialBackoffMillis, int backoffPolicy)：设置 back-off 或者 重试策略。注意尝试调用 setRequiresDeviceIdle(boolean) 为任务设置回退策略时，当 build() 被调用时会抛出异常。因为 back-off 对这些工作类型没意义。 第一个参数表示第一次失败时尝试的时间间隔，单位为毫秒，预设的参数有： DEFAULT_INITIAL_BACKOFF_MILLIS：30000 MAX_BACKOFF_DELAY_MILLIS：18000000 第二个参数表示退避策略 BACKOFF_POLICY_EXPONENTIAL：任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：任务失败时等待间隔呈线性增长。 setMinimumLatency (long minLatencyMillis)：指定任务延迟执行时间。 setOverrideDeadline (long maxExecutionDelayMillis)：设置任务执行最大的延迟时间。即使到了时间期限，条件还没满足，任务也会被执行。 setPeriodic (long intervalMillis)：指定任务在一定的周期内执行，并且每一个任务在周期内只执行一次。调用该方法设置后，不能再调用 setMinimumLatency (long minLatencyMillis) 或者 setOverrideDeadline (long maxExecutionDelayMillis) 方法，否则会抛出异常。 setPersisted (boolean isPersisted)：设置当设备重启，任务是否被重新调度。如果设置 true，必须申请权限 RECEIVE_BOOT_COMPLETED，否则运行时会报错。 setExtras (PersistableBundle extras)：设置额外参数，值允许原始数据类型。 JobServiceJobScheduler 所要调度的任务是在 JobService 定义的，而 JobService 是继承 Service；也就是说，JobService 也是服务，只是它与四大组件之一 Service 有所区别。JobService 有一大特点是无论你的 app 是否处于活跃状态，当你的任务满足特定的条件时，系统都会执行任务。我们可以编写多个 JobServices，而且每个 JobService 指定不同的任务，每个任务在某个时间点被执行。 来看下官方文档的描述 JobScheduler 回调的入口点。 JobService 是处理之前调度的异步请求的基类。你应该重写 onStartJob (JobParameters params)) 方法，将在该方法实现你的任务逻辑。 此服务运行在应用程序主线程处理传入的任务。这意味着你必须将执行逻辑放到子线程、handler、AsyncTask。如果不这样做的话会阻塞 JobManager 的回调，特别是 onStopJob(android.app.job.JobParameters))，这意味着将通知你不满足调度要求。 那么该如何实现 JobService 呢？必须创建一个新类，继承 JobService，并重写方法 onStartJob(JobParameters) 和 onStopJob(android.app.job.JobParameters)。下面给出一个模板： 123456789101112public class JobSchedulerService extends JobService &#123; @Override public boolean onStartJob(JobParameters params) &#123; return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; return false; &#125;&#125; 从以上可知，两个方法都返回 boolean 值，那么什么时候返回 true，什么时候返回 false 呢，返回值对 JobScheduler 任务调度又有什么影响呢？下面一一来解析： onStartJob(JobParameters)：在此方法实现任务的逻辑。由于 JobService 是在主线程运行，因此对于逻辑简单的可以直接写在该方法里，但是对于比较复杂任务，例如网络请求，那么就要开启子线程来操作，以免造成阻塞。当任务完成的时候返回 false，作用是通知系统任务已经完成；当有任务要执行的话返回 true，作用是让系统知道有任务即将执行或正在执行，并对该任务持有锁。因为任务一旦完成并通知系统，系统就释放持有该任务锁。 onStopJob (JobParameters params)：当任务未完成调用 jobFinished(JobParameters, boolean)) 取消任务时，此方法就会被调用。发生这种现象的原因大部分是调度的任务不满足所指定的条件，导致系统无法执行任务。当任务停止时，如果还想系统重新调度任务的话，那么返回 true；反之返回 false，此时系统会移除任务，导致所要调度的任务必须暂停。 除此之外，JobService 还提供了 jobFinished(JobParameters, boolean)) 这个方法，虽然不用重写该方法，但是该方法却有很大的作用。此回调方法用来通知 JobManager 任务已经完成。由于此方法最终在主线程调用，因此可以在任何线程调用该方法。当系统收到信息时，就会释放持有该任务锁。当 onStartJob(JobParameters) 返回 true，即表示任务正在执行或要被执行，在任务执行完成后需要调用 jobFinished(JobParameters, boolean) 方法来通知系统任务已经完成，此时系统才可以安全地释放持有该任务锁。如果忘记调用该方法的话，应用中其它任务就不会被执行。 jobFinished(JobParameters, boolean) 需要传入两个参数：第一个参数 JobParameters 表示当前任务的信息，以至于任务完成时系统知道释放哪个锁；第二个参数是 boolean 值，true 表示根据退避策略（back-off criteria）重新调度任务；false 则表示不调度任务。 跟四大组件之一 service 一样，都需要在 AndroidManifest.xml 声明，但是有一点不同的是需要添加权限 android:permission=”android.permission.BIND_JOB_SERVICE” 123&lt;service android:permission=\"android.permission.BIND_JOB_SERVICE\" android:name=\".service.JobSchedulerService\" &gt; JobParameters来看下官方文档描述 JobParameters 对任务的信息进行封装，当任务被调度时，系统就会创建该对象，包含任务的信息；自己是无法实例化该对象的。 PS：自己觉得是与 JobInfo 对应的，JobInfo 是设置属性，而 JobParameters 是获取相应属性。 那么来看下 JobParameters 提供的方法，只列出部分： getJobId ()：获取每个任务独一无二的 id。 getExtras ()：获取额外参数。 了解 API 之后，接下来的任务是学习 JobScheduler 用法。 JobScheduler 用法对于 JobScheduler 的用法，我打算用项目中使用到 JobScheduler 作为例子，前提是移除了业务逻辑，代码可能不太完整。换句话说吧，给个模板吧。 先给出例子，再来分步讲解吧。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class JobSchedulerService extends JobService &#123; private static final String TAG = JobSchedulerService.class.getCanonicalName(); public final static String TASK = \"com.demo.panju.task\"; private final static int JOB_ID = 1; private static ComponentName mComponentName; private static JobScheduler mJobScheduler; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case 1； task(); break; default: break; &#125; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mReceiver = new Receiver(); mFilter = new IntentFilter(); mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); registerReceiver(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; sendMessage(params); return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; mHandler.removeMessages(1)); return false; &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); stopSelf(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (null != mReceiver) &#123; unregisterReceiver(mReceiver); mReceiver = null; &#125; &#125; private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; private void sendMessage(JobParameters parameters) &#123; Message message = mHandler.obtainMessage(); message.what = 1; message.obj = parameters; mHandler.sendMessage(message); &#125; private void registerReceiver() &#123; mFilter.addAction(TASK); registerReceiver(mReceiver, mFilter); &#125; private void task() &#123; mApi.task(new Callback() &#123;&#125; @Override public void onSuccess(Object result) &#123; jobFinished(mJobParameters, false); &#125; @Override public void onError(Object e, int errno) &#123; jobFinished(mJobParameters, true); &#125; &#125;); &#125; private class Receiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (TASK.equals(action)) &#123; scheduleJob(JOB_ID); &#125; &#125; &#125; &#125; 以上例子应该不难理解，接下来分步讲解： 创建新类 JobSchedulerService 并继承 Service，重写方法 onStartJob(JobParameters params) 和 onStopJob(JobParameters params)。onStartJob(JobParameters params) 返回 true 表示任务将被执行；onStopJob(JobParameters params) 返回 false 表示当任务中途被取消而导致暂停任务，系统将会移除任务。 创建 JobScheduler 和 ComponentName 对象 12mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); 对调度任务所需要的属性进行封装 1234567private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; 编写广播接收器、注册接收器、重写 Handler 回调方法 handleMessage(Message msg) 并实现相应逻辑。 当注册的广播接收器收到相应 action 时，就会调用方法 scheduleJob(JOB_ID)，即调度任务，那么方法 onStartJob(JobParameters params) 就会被调用，在该方法里通过 Handler 机制发送消息，Handler 的回调方法 handleMessage(Message msg) 就会被调用，实现的逻辑主要是发起网络请求，即 task() 方法。task() 方法逻辑中有两个回调方法：onSuccess(Object result) 和 onError(Object e, int errno)。发起网络请求成功的话就会调用方法 onSuccess(Object result)，在该方法里又调用 jobFinished(mJobParameters, false)，传入的 boolean 值是 false，意味着任务已经成功完成，无需重新调度任务；发起网络请求失败的话就会调用 onError(Object e, int errno)，在该方法里又会调用 jobFinished(mJobParameters, true)，传入的 boolean 值是 true，意味着任务失败，根据重试策略重新调度任务。 由于自己的水平有限，若有些地方描述的不对或者翻译的不恰当（参考官方文档和国外博客），欢迎指出 ！ 大家一起学习，共同进步 ！ 参考链接官方文档 https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129 http://josiassena.com/the-jobscheduler-on-android/ http://blog.csdn.net/bboyfeiyu/article/details/44809395 http://zhanghuimin.com/2016/10/27/about-android-job-scheduler/ http://mahong978.top/2016/08/19/android-job-scheduler/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://panzeyong.com/categories/Android/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://panzeyong.com/tags/性能优化/"}]},{"title":"第二章 在 HTML 中使用 JavaScript","slug":"第二章-在-HTML-中使用-JavaScript","date":"2017-05-03T23:40:59.000Z","updated":"2017-09-15T23:52:31.000Z","comments":true,"path":"2017/05/04/第二章-在-HTML-中使用-JavaScript/","link":"","permalink":"http://panzeyong.com/2017/05/04/第二章-在-HTML-中使用-JavaScript/","excerpt":"","text":"标签script：表示向 HTML 页面插入 JavaScript。该元素定义 6 个属性： async：可选。表示应该立即下载脚本，但不应妨碍页面中的其它内容加载。只对外部脚本文件有效。标记为 async 的脚本并不能保证按照指定的的先后顺序执行，一定会在页面的 load 事件前执行，但是对于 DOMContentLoaded 事件就不一定了。建议异步脚本不要在加载期间修改 DOM。 charset：可选。表示通过 src 属性指定的代码的字符集。 defer：可选。表示所要加载的脚本可以延迟到文档完全被解析和显示之后再执行，即遇到 html 标签之后才执行；只对外部脚本文件有效。HTML 5 规范要求延迟脚本是按照出现的顺序执行的，并且先于 DOMContentLoaded 事件，但是现实是不一定的，因此最好只包含一个延迟脚本。 language：已经废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME 类型）。通常的默认值为 text/javascript。 noscript：在不支持 JavaScript 的浏览器中显示替代的内容。 123&lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript&lt;/p&gt;&lt;/noscript&gt; 注意点 解释器对 script 元素内代码的解析是从上往下，在该元素内的代码被解析完之前，页面其它内容是不会被浏览器加载或者显示的。（外部文件也一样） 通过 src 属性引入外部文件必须要包含开始的 script 和结束的 script，只是 HTML 规范。 1&lt;script type=\"text/javasript\" src=\"example.js\"&gt;&lt;/script&gt; 带有 src 属性的 script 元素不应该在其元素之间包含额外的 JavaScritp 代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 JavaScript 代码建议放在 body 元素中页面内容之后 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第二章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://panzeyong.com/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"http://panzeyong.com/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"AsnycTask 用法及源码解析","slug":"AsnycTask-用法及源码解析","date":"2017-05-01T09:49:39.000Z","updated":"2017-06-19T14:44:13.000Z","comments":true,"path":"2017/05/01/AsnycTask-用法及源码解析/","link":"","permalink":"http://panzeyong.com/2017/05/01/AsnycTask-用法及源码解析/","excerpt":"","text":"AsyncTask 是一种轻量级异步任务类，可以在线程池执行后台任务，获取到的结果传递给主线程并且在主线程中更新 UI。AsyncTask 比较适合执行短时间任务，对于长时间任务推荐使用 Executor，ThreadPoolExecutor 和 FutureTask。 AsyncTask 是一个抽象类，提供三个泛型参数，分别是 Params，Progress 和 Result；以及 4 个步骤：onPreExecute，doInBackground，onProgressUpdate 和 onPostExecute。 AsyncTask 三个泛型参数 Params：发送给执行任务的参数类型。 Progress：执行后台任务进度的类型。 Result：执行完后台任务返回的结果类型。 AsyncTask 四个核心方法 onPreExecute()：在任务执行之前调用，主线程执行；主要做一些初始化工作，比如在用户界面展示进度条。 doInBackground(Params…)：onPreExecute() 执行完成后被调用，在线程池执行；所有的异步操作都在这个方法执行，执行结果被返回时，onPostExecute(Result) 会被调用。如果在该方法中调用 publishProgress(Progress…)，那么方法 onProgressUpdate(Progress…) 也会被调用，主要用于更新后台任务进度。 onProgressUpdate(Progress…)：publishProgress(Progress…) 执行完之后被调用，在主线程执行；主要在用户界面显示后台任务执行进度。 onPostExecute(Result)：doInBackground(Params…) 执行完之后调用，在主线程执行；参数 Result 是 doInBackground(Params…) 的返回值。 一个异步任务可以通过调用 cancel(boolean) 随时取消，此时 isCancelled() 被调用，这就导致 doInBackground(Params…) 执行完后 onPostExecute(Result) 不会被调用。 在使用 AsyncTask 的过程中，要注意以下几点： AsyncTask 类必须在 UI 线程加载，Android 4.1 已经自动绑定了。 AsyncTask 实例必须在 UI 线程创建。 execute(Params…) 必须在 UI 线程调用。 不要手动调用 onPreExecute()、onPostExecute(Result)、doInBackground(Params…)、onProgressUpdate(Progress…)。 一个 AsyncTask 对象只能被执行一次；否则会抛异常。 以上是 AsnycTask 基本知识点，掌握知识点后就要学会如何使用它。那么接下来就来学习 AsyncTask 用法。 AsyncTask 用法AsyncTask 是抽象类，不能直接实例化，必须创建新类并继承它，抽象方法 doInBackground(Params…) 是一定要重写的，其它三个方法根据自己的需求确定。以下通过 URL 获取数据为例子来讲解 AsyncTask 的用法。代码如下： 12345678910111213141516171819public class AsyncTaskExample extends AsyncTask&lt;String, Integer, String&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); mLoad.setVisibility(View.VISIBLE); &#125; @Override protected String doInBackground(String... params) &#123; return getUrlResponse(params[0]); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); mLoad.setVisibility(View.GONE); mText.setText(s); &#125;&#125; 从代码中可以很清晰地看出，第 5 行是显示加载进度条，表示正在获取数据；第 10 行是核心代码，异步操作，网络请求数据并将结果返回；第 16 - 17 行代码主要操作是隐藏进度条，表示数据加载完毕，并将获取到的结果显示出来。这里主要给出核心代码，至于其它代码也就调用而已。 那么该如何调用呢？很简单，一行代码就搞定 1new AsyncTaskExample().execute(url); AsyncTask 源码解析知其然必知其所以然。对于新知识点，学会使用之后，就应该探究其原理。由于个人倾向于通过画图来理解知识点的流程，因此先简单地给出 AsyncTask 任务执行的流程图，再根据流程图和源码进行讲解。流程图如下： 对于源码的理解，一般是以最终调用的方法为入口，一步一步地理解整个流程。那么对于 AsyncTask 该从哪里入手呢？当然是从方法 execute(Params… params) 入手了，代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 对于 AsyncTask 不同版本，execute(Params… params) 方法的执行方式是不一样的。Android 1.6 以前，AsyncTask 是单线程串行执行任务的；Android 1.6，AsyncTask 是线程池多线程并行执行任务；但是到 Android 3.0，AsyncTask 又改为单线程串行执行任务的。该方法的逻辑很简单，直接调用方法 executeOnExecutor(Executor exec, Params… params)，将我们传入的参数 params 和 sDefaultExecutor 传到该方法里，并将的返回值返回。那么来看下该方法的具体实现，代码如下： 12345678910111213141516public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; executeOnExecutor(Executor exec, Params… params) 方法是在线程池 THREAD_POOL_EXECUTOR 执行，允许多任务并发执行，但是不推荐采用多任务并发执行；在主线程执行。该方法实现的主要功能是： 检查任务状态，并记录任务当前状态； 调用 onPreExecute() 方法，根据我们自己的需求可以重写该方法； 将我们传入的参数 params 赋值给 WorkRunnable 中字段 mParams(稍后解释)； 调用 SerialExecutor 中方法 execute(Runnable r) 执行任务。 mWorker 是 WorkerRunnable 实例，而 WorkerRunnable 是抽象类，实现 Callable 接口，并且该接口有一个回调方法 call()；同时抽象类有一个字段 Params []，第 13 行代码就是把我们传进来的参数 params 赋值给它的。mWorker 是在创建 AsyncTask 实例时被初始化的，即 AsyncTask 构造方法里，并重写回调方法 call()，那么接下来看回调方法 call() 的具体实现。 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 该回调方法实现的主要功能： 将 mTaskInvoked 设置为 true，表示任务已经被调用过； 设置线程优先级为后台线程； 调用 doInBackground(mParams) 方法，异步执行，后台执行的逻辑都写在这个方法里面，一定要被重写；如果任务执行抛出异常时，取消任务； 调用 postResult(result) 方法； postResult(result) 的具体实现如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 从代码里可以看出，将执行结果通过 sHandler 发送 MESSAGE_POST_RESULT 的消息，然后 handleMessage() 方法收到消息后进行相应的处理。sHandler 是 InternalHandler 实例，主要作用是将任务执行的环境从线程切换到主线程中，从 InternalHandler 的具体实现就可以看出了。代码如下： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 从构造函数 InternalHandler() 就可以看出了，获取主线程 Looper，而 Handler 必须与 Looper 进行绑定，因此可以断定是在主线程里。handleMessage() 函数对两种消息进行处理：MESSAGE_POST_RESULT 和 MESSAGE_POST_PROGRESS；而我们刚刚发送的消息是 MESSAGE_POST_RESULT，那就先来看该消息收到后会做什么处理吧？很显然，调用 finish(Result result)，具体实现如下： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 如果任务被取消了，直接调用 onCancelled(result) 方法，onPostExecute(result) 方法不会被调用；否则就调用 onPostExecute(result) 方法，该方法需要被重写，在主线程执行，根据返回的结果进行相应的处理；最后修改任务的状态。那么对于消息 MESSAGE_POST_PROGRESS 是从哪里发出来的呢？还记得在前面的知识点讲解中有提到过如果在 doInBackground(mParams) 方法中调用 publishProgress(Progress…) 方法时，方法 onProgressUpdate(Progress…) 也会被调用，用于后台任务进度更新。没错，消息 MESSAGE_POST_PROGRESS 就是用来处理进度更新的。先看下 publishProgress(Progress…) 具体实现： 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 很显然，如果任务没有被取消的话，就会发送消息 MESSAGE_POST_PROGRESS，那么来看下收到该消息后的处理逻辑，即调用 onProgressUpdate(Progress… values) 方法，该方法需要我们根据自己的需求进行重写。 再回到 executeOnExecutor(Executor exec, Params… params) 方法，第 14 行代码开始执行任务，在理解如何执行任务之前，先来理解参数 mFuture 和 sDefaultExecutor 的含义。 mFuture 是 FutureTask 实例，在 AsyncTask 构造方法中初始化。将 mWorker 作为参数传入 FutureTask 构造函数，个人认为传入该参数的作用是由于 FutureTask 中 run() 方法会被调用，而在该方法里会通过传入参数 mWorker 调用 call() 方法，进而使任务得到执行。FutureTask 是一个并发执行任务类，可以执行任务、取消任务、查询结果、获取结果；提交到线程池执行。实现的接口有 Future、Runnable。 对于传入的参数 sDefaultExecutor，究竟是什么啥玩意呢？让我们来探个究竟吧。sDefaultExecutor 是 SerialExecutor 的实例，而 SerialExecutor 实际上是一个串行的线程池，主要的功能是一个进程中所有的 AsyncTask 任务都在这个串行的线程池中排队执行。看到这里，是不是还不知道任务真正在哪里被开始执行？其实以上都只是铺垫，下面才真正拉开序幕。真正开始执行任务的逻辑是在 SerialExecutor 中 execute(Runnable r) 方法里，具体实现如下： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 首先将 AsyncTask 通过线程池 SerialExecutor 添加到队列里（从这里可以看出 SerialExecutor 的作用），然后重写 run() 方法，并判断 mActive 是否为 null，即当前是否有任务在执行，如果有任务执行的话就等待该任务执行完后再执行其他任务，否则就执行任务，即调用 scheduleNext() 方法，该方法的主要功能是从队列 mTasks 获取任务，任务不为空的话就直接提交到线程池 THREAD_POOL_EXECUTOR 里执行（任务真正开始执行），即启动任务，根据个人的理解，任务被启动后，会调用第 6 行代码，即 run() 方法，进而调用 FutureTask 中 run() 方法，从而会调用 WorkerRunnable 中 call() 方法，因此任务被执行，我们重写的方法也会被调用。结合以上流程图应该能更清晰地理解 AsyncTask 执行流程。 以上是自己在学习 《Android 开发艺术探索》 这本书第十一章关于 AsyncTask 这个主题的学习笔记，由于自己能力有限，有错误的地方欢迎指出。 参考资料https://developer.android.com/reference/android/os/AsyncTask.html 《Android 开发艺术探索》》中 第 11 章 Android 的线程和线程池","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://panzeyong.com/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"http://panzeyong.com/tags/《Android-开发艺术探索》学习笔记/"}]},{"title":"Python 学习笔记：字符串","slug":"Python-学习笔记：字符串","date":"2017-04-17T14:27:28.000Z","updated":"2017-12-21T08:13:19.000Z","comments":true,"path":"2017/04/17/Python-学习笔记：字符串/","link":"","permalink":"http://panzeyong.com/2017/04/17/Python-学习笔记：字符串/","excerpt":"","text":"定义：Python 的字符串是一种对象类型，这种类型用 str 表示，通常用双引号 “” 或者单引号 ‘’ 表示。Python 字符串不可以被更改，即它们是不可变的。 拼接字符串Python 的字符串是可以拼接，用符号 + 表示；但是与 Java 语言有一点不同的是拼接的两个对象必须是同类型，否则会报错。例子如下： 两个相同类型 str 拼接（正确） 12&gt;&gt;&gt; \"Hello \" + \"Python\"'Hello Python' 两个相同类型 int 拼接（正确） 12&gt;&gt;&gt; 5 + 38 两个不同类型 str 和 int 拼接（错误） 1234&gt;&gt;&gt; \"Python \" + 5Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 很显然，对于类型都是 str 将多个对象拼接起来；对于类型都是 int 则执行相加操作；对于不同类型则报错。那么对于不同类型的操作该如何转换呢？解决办法如下： str() 函数 12&gt;&gt;&gt; \"Python \" + str(3)'Python 3' repr() 函数（反引号的替代品） 12&gt;&gt;&gt; \"Python \" + repr(3)'Python 3' str() 与 repr() 区别 str() 将对象转化为可读性好的字符串，适合于 print 输出到终端，其返回值无法用于内建函数 eval。 repr() 返回对象的规范字符串表示形式；对于大多数对象而言，eval（repr（obj））== obj，也就是说，大多数情况下可以通过内建函数 eval 重新获取该对象。 大部分情况下 str() 用于终端输出，eval() 主要用于调试。 字符串格式化输出用于指定输出参数的格式与相对位置的字符串参数。通俗地讲，先定制模板，预留占位符，用对应类型的值填充；常用的占位符有 %s（字符串）、%d（整数）、%f（浮点数）。 以下通过例子说明 12&gt;&gt;&gt; \"I love my %s\" % \"job\" 'I love my job' 在这个字符串中，%s 是一个占位符，可以被其它字符串替换，这里替换的是 “job”。 12&gt;&gt;&gt; \"I'm %d years old\" % 20\"I'm 20 years old\" 不同占位符也可以混合使用，例子如下： 12&gt;&gt;&gt; \"What's your name ? My name is %s and I'm %d years old.\" % (\"John\", 15)\"What's your name ? My name is John and I'm 15 years old.\" 字符串常用方法index(…)：子字符串在整个字符串中的索引，即子字符串中第一个字符的位置。 123&gt;&gt;&gt; string = \"The programming language Python\"&gt;&gt;&gt; string.index(\"Python\")25 isalnum(…)：字符串中所有字符都是字母数字时返回 True，否则 False。 12345678910111213141516&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"199993\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalnum()True# 包含空格，并非全是字母数字，所以返回 False&gt;&gt;&gt; string = \"Python 3\"&gt;&gt;&gt; string.isalnum()False isalpha(…)：字符串中所有字符都是字母时返回 True，否则 False。 12345678910111213&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalpha()True# 包含数字&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalpha()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.isalpha()False isdecimal(…)：字符串中只有十进制字符时返回 True，否则返回 False。 12345678910111213141516171819202122232425262728293031# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdecimal()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isdecimal()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isdecimal'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdecimal()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdecimal()False# 包含字母&gt;&gt;&gt; string = \"Python1993\"&gt;&gt;&gt; string.isdecimal()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"1993 1993\"&gt;&gt;&gt; string.isdecimal()False isdigit(…)：字符串中所有字符都是数字 True，否则返回 False。 1234567891011121314151617181920212223# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdigit()True# byte数字（单字节）&gt;&gt;&gt; string =b\"1\"&gt;&gt;&gt; string.isdigit()True# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isdigit()False isnumeric(…)：字符串中只有数字字符时返回 True，否则返回 False。 123456789101112131415161718192021# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isnumeric()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isnumeric()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isnumeric'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isnumeric()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isnumeric()True 提示：isdecimal()、isdigit()、isnumeric() 三个函数区别如上。 islower(…)：字符串中所有字符都是小写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"python\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.islower()False isupper(…)：字符串中所有字符都是大写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"PYTHON\"&gt;&gt;&gt; string.isupper()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isupper()False join(…)：将序列中的元素以指定的字符连接成生成新的字符串。 123456789&gt;&gt;&gt; string = \"-\" # 指定的字符&gt;&gt;&gt; seq = \"Hello,Python\" # 序列&gt;&gt;&gt; string.join(seq)'H-e-l-l-o-,-P-y-t-h-o-n'&gt;&gt;&gt; string = \"-\"&gt;&gt;&gt; seq = ['Python', 'PHP']&gt;&gt;&gt; string.join(seq)'Python-PHP' lower(…)：返回字符串的副本并将其转换为小写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.lower()'welcome to python world !' upper(…)：返回字符串的副本并将其转换为大写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.upper()'WELCOME TO PYTHON WORLD !' capitalize(…)：字符串中首字母大写，其它都是小写。 123&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.capitalize()'Hello python' istitle(…)：字符串中所有单词的首字母大写，其它小写时返回 True，否则返回 False。 123456789101112131415&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"hello python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"HELLO PYTHON\"&gt;&gt;&gt; string.istitle()False split(…）：根据分隔符对字符串进行分割，返回列表。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string.split()['I', 'love', 'Python', '!'] strip(…)：去掉字符串左右空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.strip()'I love Python !' lstrip(…)：去掉字符串左边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.lstrip()'I love Python ! ' rstrip(…)：去掉字符串右边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.rstrip()&gt;&gt;&gt; ' I love Python !' len(…)：返回序列（字符串）的长度。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; len(string)15 in：判断字符串是否包含某个字符或子字符串，包含的话返回 True；否则返回 False。（区分大小写） 1234567&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"python\" in stringFalse&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"Python\" in stringTrue max：根据 ASCII 编码，求出字符串中最大值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; max(string)'y' min：根据 ASCII 编码，求出字符串中最小值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; min(string)' ' 索引与切片与其它编程一样，在 Python 中的字符串也可以通过索引获取相应的字符，唯一的区别是获取的方式不一样。在 Python 中，字符串是一种序列，以一种数组的形式存在，可以通过下标获取。最直接的方式还是通过例子来说明吧。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[7]'P' 这种形式很类似 Java 语言中数组，但是 Java 语言中通过索引获取字符串中某个字符是通过调用 charAt(index) 方法获取到；获取子字符串是通过调用 subString(start, end) 方法，但是在 Python 获取子字符串称为切片，获取方式跟字符类似。例子如下： 1234# 得到从字符串索引为 2 到 7 的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:8]'love P' 1234得到从字符串索引为 2 到末尾的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:]'love Python !' 1234# 获取全部字符&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:]'I love Python !' 1234# 获取从第一个字符到 9 之前的字符串&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:9]'I love Py' 从以上例子可以看出字符串切片的使用用法，以下做下简单的总结： [a : b]：表示从索引为 a 起到索引 b 之前字符串。(包含起始字符，不包含末尾字符) [:a]：从第一个字符到索引 a 之前的所有字符串。（切片的索引有默认值，省略的第一个索引默认为 0） [a : ]：表示从索引为 a 到末尾字符串。（切片的索引有默认值，省略的第二个索引默认为切片的字符串的大小） [:]：表示原始字符串，但不是复制一份，只是两个变量指向同一个对象。 一个过大的索引值(即下标值大于字符串实际长度)将被字符串实际长度所代替，当上边界比下边界大时(即切片左值大于右值)就返回空字符串。 以上只是最近在学 Python 中字符串的小结，也可以说是学习笔记，方便以后查找。（基于 Python3） 参考资料http://docs.pythontab.com/learnpython/106/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"http://panzeyong.com/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://panzeyong.com/tags/学习笔记/"}]},{"title":"第一章 Activity 的生命周期和启动模式","slug":"第一章-Activity-的生命周期和启动模式","date":"2017-03-26T08:41:15.000Z","updated":"2017-06-19T14:43:39.000Z","comments":true,"path":"2017/03/26/第一章-Activity-的生命周期和启动模式/","link":"","permalink":"http://panzeyong.com/2017/03/26/第一章-Activity-的生命周期和启动模式/","excerpt":"","text":"Activity 正常情况下生命周期 生命周期方法分析 onCreate()：Activity 创建时调用，可以做一些初始化工作。 onRestart()：Activity 正在重新启动，由不可见状态变为可见状态。 onStart()：Activity 正在被启动，这时已经处于可见状态，但是还没出现在前台，而是在后台，无法与用户交互。 onResume()：Activity 已经处于可见状态，并且出现在前台。 onPause()：Activity 暂停，位于后台，可以做一些存储数据、停止动画等工作，但是不能太耗时。 onStop()：Activity 停止，不可见状态，可以做一些资源回收工作，但不能太耗时。 onDestroy()：Activity 销毁，可以做一些回收工作和资源释放。 Activity 生命周期方法不同情况下调用 Activity 第一次启动：onCreate() —&gt; onStart() —&gt; onResume()。 打开新的 Activity 或者切换到桌面：onPause() —&gt; onStop()。 回到原来 Activity：onRestart() —&gt; onStart() —&gt; onResume()。 按 back 键：onPause() —&gt; onStop() —&gt; onDestroy()。 注意（提示、问题） onCreate() 与 onDestroy() 是配对的，表示 Activity 的创建和销毁,并且只有可能一次调用。 onStart() 与 onStop() 是配对的，从是否可见这个角度来回调。 onResume() 与 onPause() 是配对的，从是否位于前台这个角度来回调。 如果新 Activity 采用了透明主题，那么当前 Activity 不会回到 onStop()（原因：处于可见状态，但是失去焦点，无法与用户进行交互）。 假设当前 Activity A，用户打开新的 Activity B，此时 A 的 onPause() 先调用，再调用 B 的 onResume()。 Activity异常情况下生命周期 系统配置发生改变导致 Activity 被杀死并重新创建 系统配置文件发生改变时，Activity 会被重新创建，生命周期方法调用顺序 onPause() —&gt; onSaveInstanceState() —&gt; onStop() —&gt; onDestroy() —&gt; onCreate() —&gt; onStart() —&gt; onRestoreInstanceState() —&gt; onResume()。 Activity 被异常终止情况下，onSaveInstanceState() 方法才会被调用，正常情况下是不会的；该方法调用时机是在 onStop() 之前，至于在 onPause() 之前或者之后并不确定。 Activity 被异常终止情况下，Activity 会被重建，此时 onRestoreInstanceState() 会被调用，调用时机在 onStart() 之后。 onCreate() 与 onRestoreInstanceState() 区别：onRestoreInstanceState() 一旦被调用，其参数 savedInstanceState 一定是有值的，不用判断是否为空；但 onCreate() 不一样，如果是正常启动时，其参数 savedInstanceState 为 null，所以需要额外判空。 可以通过设置android:configChanges属性让屏幕旋转时不重新创建。 资源内存不足导致低优先级的 Activity 被杀死 前台 Activity：正在和用户交互的 Activity，优先级最高。 可见但非前台 Activity：可见但是位于后台无法与用户进行交互，优先级次之。 后台 Activity：优先级最低。 Activity四种启动模式 启动模式 standard：标准模式，这也是系统默认模式。每当启动一个 Activity 创建一个实例，谁启动谁就在谁任务栈。 singleTop：栈顶复用模式。如果新 Activity 已经位于任务栈栈顶，那么此 Activity 不会被创建，同时 onNewIntent() 方法被调用，随后 onResume() 方法也被调用；反之则会重新创建 Activity。 singleTask：栈内复用模式，这是一种实例模式。 singleInstance：单实例模式，singleTask 加强版。Activity 启动时，系统会单独为其创建任务栈，然后此 Activity 就在这个任务栈中，后续跟 singleTask 相同。 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 启动模式。 FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 启动模式。 FLAG_ACTIVITY_CLEAR_TOP：与 singleTask 启动模式异同出现，作用相同。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有该标记的 Activity 不会出现在历史 Activity 列表中。 注意点 TaskAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用才起作用，其它情况下没用。 TaskAffinity 与 singleTask 启动模式配对使用时，此时 Activity 运行 TaskAffinity 属性所指定的任务栈。 TaskAffinity 与 allowTaskReparenting 配对使用时，情况比较复杂，会产生特殊效果。 IntentFilter 匹配规则 action 的匹配规则 匹配规则：Intent 中的 action 必须能够和过滤规则中的任何一个action 匹配。 区分大小写。 注意与 category 匹配规则不一样。 category 的匹配规则 匹配规则：Intent 所包含的 category 必须与过滤规则中的任何一个 category 相同（可理解为一对一关系）。 特殊情况是 Intent 可以没有 category，但是系统默认会加上android.intent.category.DEFAULT，这也是隐式调用所要求的。 data 匹配规则 data 的结构 android:scheme：URI 模式，比如 http、file、content 等。 android:port：URI 中的端口号，需要指定 scheme 和 host 才有作用。 android:host：URI 主机名。 android:path：完整的路径。 android:pathPattern：完整的路径信息，也可以包含通配符 *。 android:pathPrefix：路径的前缀信息。 android:mimeType：媒体类型。 匹配规则：Intent 包含的 data 数据必须与过滤规则中某一个匹配（Intent 是过滤规则的子集），与 action 类似。 过滤规则有默认URI值：content 和 file。 注意点 判断是否能匹配隐式 Intent 方法 调用 PackageManager 的 resolveActivity 方法。 Intent 的 resolveActivity 方法。 PackageManager 中 queryIntentActivies 方法。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://panzeyong.com/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"http://panzeyong.com/tags/《Android-开发艺术探索》学习笔记/"}]}]}