{"meta":{"title":"PANJU's Note","subtitle":"故不积跬步，无以至千里；不积小流，无以成江海。","description":"笔记——记录工作和学习中的点点滴滴","author":"PANJU","url":"https://panzeyong.github.io"},"pages":[{"title":"about","date":"2017-03-11T15:18:09.000Z","updated":"2017-03-11T15:18:09.000Z","comments":true,"path":"about/index.html","permalink":"https://panzeyong.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-06-19T04:52:59.000Z","updated":"2017-06-19T04:52:59.000Z","comments":true,"path":"categories/index.html","permalink":"https://panzeyong.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-06-19T04:52:00.000Z","updated":"2017-06-19T04:52:00.000Z","comments":true,"path":"tags/index.html","permalink":"https://panzeyong.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"第九章 客户端检测","slug":"第九章-客户端检测","date":"2017-08-13T09:23:34.000Z","updated":"2017-08-13T11:04:38.000Z","comments":true,"path":"2017/08/13/第九章-客户端检测/","link":"","permalink":"https://panzeyong.github.io/2017/08/13/第九章-客户端检测/","excerpt":"","text":"一、能力检测能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。比如说，函数 document.getElementById 在不同浏览器是否被支持。 能力检测有两个重要概念：一是先检测达成目的的最常用的特性；二是必须测试实际要用到的特性。 示例如下： 1234567function getElement(id) &#123; if (document.getElementById) &#123; return document.getElementById(id); &#125; else if (document.all) &#123;&#125;&#123; return document.all[id]; &#125;&#125; 二、怪癖检测识别浏览器的特殊行为，即检测浏览器存在什么缺陷。怪癖检测无法精确地检测特定的浏览器和版本。 三、用户代理检测通过检测用户代理字符串来确定实际使用的浏览器，可以通过 JavaScript 的 navigator.userAgent 属性访问。 1、主要浏览器所使用的呈现引擎如下表：浏览器IEOperaChromeFirefoxSafariKonqueror呈现引擎IEOperaWebKitGeckoWebKitKHTML 2、用户代理字符串（userAgent）所包含属性如下表：字符串项必须吗说明Mozilla 版本号是Mozilla 的版本号平台是浏览器运行的平台。可能的值包括 Windows、Mac 和 X11（指 Unix 的 X 窗口系统）加密类型是加密技术的类型：U 表示 128 位、I 表示 40 位、N 表示未加密操作系统或 CPU是浏览器运行的操作系统或计算机系统使用的 CPU。在 Windows 平台中，这一项指 Windows 的版本（如 WinNT、Win95，等等）。如果平台是 Macintosh，这一项是 Unix 操作系统的名称，与使用 Unix 命令 uname-sm 得到的名称相同。语言是浏览器设计时所针对的目标用户语言预先发行版本否最初用于表示 Mozilla 的预先发行版本，现在则用来表示 Gecko 呈现引擎的版本号Gecko 版本号是Gecko 呈现引擎的版本号，但由 yyyymmdd 格式的日期表示应用程序或产品否使用 Gecko 的产品名。可能是 Netscape、Firefox 等应用程序或产品版本号否应用程序或产品的版本号；用于区分 Mozilla 版本号或 Gecko 版本号 3、用户代理字符串检测技术通过编写脚本检测浏览器呈现引擎、浏览器、平台、Windows 操作系统、移动设备、游戏系统以此来满足项目中需求。 声明全局变量 client，并使用模块增强模式来封装脚本，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var client = function() &#123; var engine = &#123; // 呈现引擎 ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本 ver: null &#125;; var system = &#123; // 检测平台 win: false, mac: false, x11: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, // 游戏系统 wii: false, ps: false &#125;; // 在此检测呈现引擎、平台和设备（各部分代码以下给出） return &#123; engine: engine, browser: browser, system: system &#125;;&#125;();var userAgent = navigator.userAgent; （1）、识别呈现引擎以及浏览器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 识别呈现浏览器步骤如下： * * 1. 第一步：检测 Opera * 2. 第二步：检测 WebKit * 3. 第三步：检测 KHTML * 4. 第四步：检测 Gecko * 5. 第五步：检测 IE*/if (window.opera) &#123; alert(\"Opera\"); engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver);&#125; else if (/AppleWebKit\\/(\\S+)/.test(userAgent)) &#123; alert(\"AppleWebKit\"); engine.ver = RegExp[\"$1\"]; engine.webkit = parseFloat(engine.ver); // 确定是 Chrome 还是 Safari if (/Chrome\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; // 近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125;&#125; else if (/KHTML\\/(\\S+)/.test(userAgent) || /Konqueror\\/([^;]+)/.test(userAgent)) &#123; alert(\"KHTML\"); engine.ver = browser.ver = RegExp[\"$1\"]; engine.khtml = browser.konq = parseFloat(engine.ver);&#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/.test(userAgent)) &#123; alert(\"Gecko\"); engine.ver = RegExp[\"$1\"]; engine.gecko = parseFloat(engine.ver); // 确定是不是 Firefox if (/Firefox\\/(\\S+)/.test(userAgent)) &#123; browser.ver = RegExp[\"$1\"]; browser.firefox = parseFloat(browser.ver); &#125;&#125; else if (/MSIE ([^;]+)/.test(userAgent)) &#123; alert(\"IE\"); engine.ver = browser.ver = RegExp[\"$1\"]; engine.ie = browser.ie = parseFloat(engine.ver);&#125; 有了以上代码，就可以对浏览器进行检测，示例代码如下： 12345678910111213141516171819202122232425262728293031if (client.engine.webkit) &#123; if (client.browser.chrome) &#123; alert(\"Chrome : \" + client.browser.chrome); &#125; else if (client.browser.safari) &#123; alert(\"Safari : \" + client.browser.safari); &#125;&#125; else if (client.engine.gecko) &#123; if (client.browser.firefox) &#123; alert(\"Firefox : \" + client.browser.firefox); &#125; else &#123; alert(\"Not Firefox Browser\"); &#125;&#125; else if (client.engine.opera) &#123; if (client.browser.opera) &#123; alert(\"Opera : \" + client.browser.opera); &#125; else &#123; alert(\"Not Opera Browser\"); &#125;&#125; else if (client.engine.khtml) &#123; if (client.browser.konq) &#123; alert(\"konq : \" + client.browser.konq); &#125; else &#123; alert(\"Not konq Browser\"); &#125;&#125; else if (client.engine.ie) &#123; if (client.browser.ie) &#123; alert(\"IE : \" + client.browser.ie); &#125; else &#123; alert(\"Not IE Browser\"); &#125;&#125; （2）、识别平台123456789var platform = navigator.platform;system.win = platform.indexOf(\"Win\") == 0;system.mac = platform.indexOf(\"Mac\") == 0;system.x11 = (platform.indexOf(\"x11\") == 0) || (platform.indexOf(\"Linux\") == 0);alert(\"Win : \" + system.win);alert(\"Mac : \" + system.mac);alert(\"X11 : \" + system.x11); （3）、识别 Windows 操作系统12345678910111213141516171819202122232425262728293031if (system.win) &#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(userAgent)) &#123; if (RegExp[\"$1\"] == \"NT\") &#123; switch(RegExp[$2]) &#123; case \"5.0\": system.win = \"2000\"; break; case \"5.1\": system.win = \"XP\"; break; case \"6.0\": system.win = \"Vista\"; break; case \"6.1\": system.win = \"7\"; break; default: system.win = \"NT\"; break; &#125; &#125; else if (RegExp[\"$1\"] == \"9x\") &#123; system.win = \"ME\"; &#125; else &#123; system.win = RegExp[\"$1\"]; &#125; &#125;&#125; 根据以上代码检测 Windows 操作系统 1234567891011if (client.system.win == \"2000\") &#123; alert(\"Windows 2000\");&#125; else if (client.system.win == \"XP\") &#123; alert(\"Windows XP\");&#125; else if (client.system.win == \"Vista\") &#123; alert(\"Windows Vista\");&#125; else if (client.system.win == \"7\") &#123; alert(\"Windows 7\");&#125; else if (client.system.win == \"NT\") &#123; alert(\"Windows NT\");&#125; (4)、识别移动设备12345678910111213141516171819202122232425262728293031system.iphone = userAgent.indexOf(\"iPhone\") &gt; -1;system.ipod = userAgent.indexOf(\"iPod\") &gt; -1;system.ipad = userAgent.indexOf(\"iPad\") &gt; -1;// 检测 iOS 版本if (system.mac &amp;&amp; userAgent.indexOf(\"Mobile\") &gt; -1) &#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(userAgent)) &#123; system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\")); &#125; else &#123; // 无法检测出来 system.ios = 2; &#125;&#125;// 检测 Android 版本if (/Android (\\d+\\.\\d+)/.test(userAgent)) &#123; system.android = parseFloat(RegExp.$1);&#125;// 检测 诺基亚 N 系列system.nokiaN = userAgent.indexOf(\"NokiaN\") &gt; -1;// 检测 Windows Mobileif (system.win == \"CE\") &#123; system.winMobile = system.win;&#125; else if (system.win == \"Ph\") &#123; if (/Windows Phone OS (\\d+.\\d+)/.test(userAgent)) &#123; system.win = \"Phone\"; system.winMobile = parseFloat(RegExp[\"$1\"]); &#125;&#125; 检测手机，示例代码如下： 123456789if (client.engine.webkit) &#123; if (client.system.ios) &#123; alert(\"iOS 手机\"); &#125; else if (client.system.android) &#123; alert(\"Android 手机\"); &#125; else if (client.system.nokiaN) &#123; alert(\"诺基亚 N 系列手机\"); &#125;&#125; （5）、识别游戏系统12system.wii = userAgent.indexOf(\"Wii\") &gt; -1;system.ps = /playstation/i.test(userAgent); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第九章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Kotlin 开发环境搭建","slug":"Kotlin-开发环境搭建","date":"2017-08-11T14:57:49.000Z","updated":"2017-08-11T15:38:17.000Z","comments":true,"path":"2017/08/11/Kotlin-开发环境搭建/","link":"","permalink":"https://panzeyong.github.io/2017/08/11/Kotlin-开发环境搭建/","excerpt":"","text":"一、Kotlin 语言介绍Kotlin 是一种基于 JVM 新编程语言，由 JetBrains 开发。Kotlin 不仅可以可以编译成 Java 字节码，而且也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。（来源：百度百科） 在应用上，Kotlin 可以用来开发服务器、Android 以及 JavaScript。 在 2017 年 Google I/O 大会上，官方宣布 Kotlin 正式成为 Android 开发语言。 学习一门新语言，首先要做的第一件事就是搭建开发环境。所谓工欲善其事，必先利其器。 二、Kotlin 开发环境搭建（一）、用命令行编译器创建 Hello World 程序1、下载编译器kotlin 编译器最新版本是 1.1.3-2，可以从 GitHub Releases 下载。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"第八章 BOM","slug":"第八章-BOM","date":"2017-07-24T23:42:23.000Z","updated":"2017-08-13T11:09:18.000Z","comments":true,"path":"2017/07/25/第八章-BOM/","link":"","permalink":"https://panzeyong.github.io/2017/07/25/第八章-BOM/","excerpt":"","text":"一、window 对象1、全局作用域window 对象具有双重角色 通过 JavaScript 访问浏览器窗口的一个接口； ECMAScript 规定的 Global 对象。 定义全局变量与在 window 对象上直接定义属性区别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上定义的属性可以。 尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在。 书中例子如下： 1234567891011121314151617181920212223// 定义全局变量var age = 29;// 在 window 对象上定义属性window.color = \"Green\";// 在 IE &lt; 9 时抛出错误，在其他所以浏览器中都返回 falsealert(delete window.age);// 在 IE &lt; 9 时抛出错误，在其他所以浏览器中都返回 truealert(delete window.color);function sayAge() &#123; alert(this.age);&#125;alert(age);alert(window.age);sayAge();window.sayAge();alert(window.color); 2、窗口关系以及框架每个框架（frame）都拥有自己的 window 对象，并且保存在 frames 集合钟；每个 window 对象都有一个 name 属性，包含框架名称。 top 对象：始终指向最高（最外）层的框架，也就是浏览器窗口；使用它可以确保在一个框架中正确第访问另外一个框架。（当网页有框架的情况下，window 对象指向的是每个框架特定的实例，与 top 对象不相等；反之，则相同。） parent 对象：始终指向当前框架的直接上层框架。（当网页有框架的情况下，parent 不一定等于 top；反之，则一定相等。） self 对象：始终指向 window，可以与 window 对象互换使用。引入该对象的目的只是为了与 top 和 parent 对象对应起来。 top、parent、self 等对象其实都是 window 的属性，也就是说，可以通过 window.top、window.parent 等访问。 访问框架的方式： 1234567891011// 不推荐，因为在有框架的网页中，每个 window 对象都是指向框架的特定实例，而非指向最外层框架。window.frames[index]window.frames[\"框架名称\"]// 推荐，因为始终指向最高（最外）层的框架，也就是浏览器窗口top.frames[index]top.frames[\"框架名称\"]// 通过集合访问frames[index]frames[\"框架名称\"] 3、窗口位置screenLeft、screenTop、screenX、screenY 这四个属性在各个浏览器中使用情况： 浏览器 / 属性IEChromeSarariOperaFirefoxscreenLeft支持支持支持支持不支持screenTop支持支持支持支持不支持screenX不支持支持支持支持支持screenY不支持支持支持支持支持 跨浏览器获取窗口左边和上边的位置的示例代码： 12var leftPos = (typeof window.screenLeft == \"number\") ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == \"number\" )? window.screenTop : window.screenY; 4、窗口大小innerWidth、innerHeight、outerWidth、outerHegiht 这四个属性在以下浏览器是支持的，不同的是获取的值，具体情况如下： 浏览器 / 属性IE9+ChromeSarariOperaFirefoxinnerWidth页面视图区的大小（减去边框宽度）视口（viewport）大小而非浏览器窗口的大小页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）支持innerHeight页面视图区的大小（减去边框宽度）视口（viewport）大小而非浏览器窗口的大小页面视图区的大小（减去边框宽度）页面视图区的大小（减去边框宽度）不页面视图区的大小（减去边框宽度）outerWidth返回浏览器本身窗口的大小视口（viewport）大小而非浏览器窗口的大小返回浏览器本身窗口的大小页面视图容器大小（单个标签页对应的浏览器窗口）返回浏览器本身窗口的大小outerHeight返回浏览器本身窗口的大小视口（viewport）大小而非浏览器窗口的大小返回浏览器本身窗口的大小页面视图容器大小（单个标签页对应的浏览器窗口）返回浏览器本身窗口的大小 document.documentElement.clientWidth、document.documentElement.clientHeight、document.body.clientWidth、document.body.clientHeight 这四个属性作用主要是保存页面视口信息，在不同浏览器使用情况如下： 浏览器 / 属性IEChromeSarariOperaFirefoxdocument.documentElement.clientWidth支持（IE6 中标准模式）支持支持支持支持document.documentElement.clientHeight支持支持支持支持支持document.body.clientWidth支持（混杂模式）支持支持支持支持document.body.clientHeight支持（混杂模式）支持支持支持支持 获取页面视口大小示例代码： 123456789101112var pageWidth = window.innerWidth;var pageHeight = window.innerHeight;if (typeof pageWidth != \"number\") &#123; if (document.compatMode == \"CSS1Compat\") &#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 5、导航和打开窗口window.open()：既可以导航到特定的 URL，也可以打开一个新的浏览器窗口。接收 4 个参数，具体如下： 加载的 URL； 窗口目标：_self、_parent、_top、_blank（指定窗口的话就在该窗口打开 URL；没有的话就根据浏览器设置打开新标签页或者打开新的窗口）； 特性字符串：不允许出现空格； 布尔值（表示新页面是否取代浏览器历史记录中当前加载页面） 第三个参数设置窗口特性，具体如下： 设置值说明fullscreenyes / no表示浏览器窗口是否最大化。仅限 IEheight数值表示新窗口的高度。不能小于 100left数值表示新窗口的左坐标。不能是负值locationyes / no表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为 no，地址栏可能会隐藏，也可能会被禁止（取决于浏览器）menubaryes / no表示是否在浏览器窗口中显示菜单栏。默认值为 noresizeableyes / no表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为 noscrollbarsyes / no表示如果内容在视口中显示不下，是否允许滚动。默认值为 nostatusyes / no表示是否在浏览器窗口中显示状态栏。默认值 notoolbaryes / no表示是否在浏览器窗口中显示工具栏。默认值为 notop数值表示新窗口的上坐标。不能是负值width数值表示新窗口的宽度。不能小于 100 opener：新创建窗口属性，保存着打开它的原始窗口对象。opener 设置为 null，表示在单独的进程中运行新标签页。（Chrome） 屏蔽弹出窗口方式： 浏览器内置的屏蔽程序阻止的弹出窗口，window.open 很可能返回 null。 浏览器扩展或者其它程序阻止的弹出窗口，window.open() 通常会抛出一个错误。 示例代码如下： 123456789101112131415161718var blocked = false;try &#123; var baiduWin = window.open(\"http://www.baidu.com\", \"topFrame\", \"height=400,widht=600,left=25,top=25,location=no,menubar=no,resizable=true,scrollbars=yes,status=no,toolbar=no\"); if (null == baiduWin) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; alert(\"The popup was blocked !\");&#125; else &#123; alert(\"The popup was not blocked !\"); alert(baiduWin);&#125; 6、间歇调用和超时调用一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。 setTimeout()：超时调用,返回一个数值 ID，表示唯一标识。接收两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多时毫秒） setInterval()：间歇调用。接收两个参数：要执行的代码和每次执行之前需要等待的毫秒数。 clearTimeout()：根据相应的 id 取消调用。 示例代码： 1234567setTimeout(function() &#123; alert(\"Hello World !\");&#125;, 1000);setInterval(function() &#123; alert(\"Hello World\");&#125;, 1000); 7、系统对话框alert()：警告框。 comfirm()：确认对话框。 prompt()：提示对话框。 window.print()：打印。 window.find()：查找。 示例代码如下： 123456789101112alert(\"Hello World !\");if (confirm(\"Are you sure ?\")) &#123; alert(\"I'm so glad you're sure !\");&#125; else &#123; alert(\"I'm sorry to hear you're not sure .\");&#125;var result = prompt(\"What is your name ? \", \"\");if (null != result) &#123; alert(\"Welcome, \" + result);&#125; 二、location 对象location 对象不仅提供与当前窗口中加载的文档有关的信息，还提供了一些导航功能以及将 URL 解析为独立的片段。window.location 和 document.location 引用的同是一个对象，即 location 对象。 location 对象所有属性如下表： 属性名例子说明hash“#contents”返回 URL 中的 hash（# 号后跟或多个字符），如果 URL 中不包含散列，则返回空字符串host“www.wrox.com:80”返回服务器名称和端口号（如果有）hostname“www.wrox.com”返回不带端口号的服务器名称href“http://www.wrox.com“返回当前加载页面的完整 URL。而 location 对象的 toString() 方法也返回这个值pathname“/WileyCDA”返回 URL 中的目录和（或）文件名port“8080”返回 URL 中指定的端口号。如果 URL 中不包含端口号，则这个属性返回空字符串protocol“http”返回页面使用的协议。通常是 http: 或 https:search“?q=javascript”返回 URL 的查询字符串。这个字符串以问号开头 查询参数示例代码： 12345678910111213141516171819202122232425function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"); args = &#123;&#125;; items = qs.length ? qs.split(\"&amp;\") : []; item = null; name = null; value = null; i = 0; len = items.length; for (var i = 0; i &lt; len; i++) &#123; item = items[i].split(\"=\"); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 位置操作方法： location.assign(url)：立即打开新 URL 并在浏览器的历史记录中生成一条记录。location.href 与 window.location 效果与之一样。 location.replace(url)：打开新 URL，但是不会下历史记录中生成新记录。 location.reload()：重新加载当前显示的页面。可接收参数，比如 true，表示从服务器加载。 三、navigator 对象navigator 对象属性如下表： 属性或方法说明IEFirefoxSafari/ChromeOperaappCodeName浏览器的名称。通常都是 Mozilla，即使在非 Mozilla 浏览器也是如此3.0+1.0+1.0+7.0+appMinorVersion此版本信息4.0+--9.5+appName完整的浏览器名称3.0+1.0+1.0+7.0+appVersion浏览器的版本。一般不与实际的浏览器版本对应3.0+1.0+1.0+7.0+buildId浏览器编译版本-2.0+--cookieEnabled表示 cookie 是否启用4.0+1.0+1.0+7.0+cpuClass客户端计算机中使用的 CPU 类型（x86、68K、Alpha、PPC 或 Other）4.0+---javaEnabled()表示当前浏览器中是否启用了 Java4.0+1.0+1.0+7.0+language浏览器的主语言4.0+1.0+1.0+7.0+mimeTypes在浏览器中注册的 MIME 类型数组4.0+1.0+1.0+7.0+onLine表示浏览器是否连接到因特网4.0+1.0+-9.5+oscpu客户端计算机的操作系统或使用的 CPU-1.0+--platform浏览器所在的系统平台4.0+1.0+1.0+7.0+plugins浏览器中安装的插件信息的数组4.0+1.0+1.0+7.0+preference()设置用户的首选项-1.5+--product产品名称（如 Gecko）-1.0+1.0+-productSub关于产品的次要信息（如 Gecko 版本）-1.0+1.0+-systemLanguage操作系统的语言4.0+---userAgent浏览器的用户代理字符串3.0+1.0+1.0+7.0+userLanguage操作系统的默认语言4.0+--7.0+userProfile借以访问用户个人信息的对象4.0+---vendor浏览器的品牌-1.0+1.0+-vendorSub有关供应商的次要信息-1.0+1.0+- 检测插件对于非 IE 浏览器，可以使用 navigator 对象提供的 plugins 属性来检测浏览器插件信息，返回的是数组。该数组中的每一项都包含以下属性： name：插件的名字。 description：插件的描述。 filename：插件的文件名。 length：插件所处理的 MIME 类型数量。 检测插件示例代码（在 IE 中无效）： 1234567891011function hasPlugin(name) &#123; name = name.toLowerCase(); for(var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125; 检测插件示例代码（只在 IE 中有效）： 12345678function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125; 四、screen 对象用来表明客户端的能力，其中包括浏览器窗口外部的显示器信息，比如像素宽度和高度。 screen 对象各种属性如下表： 属性说明IEFirefoxSafari / ChromeOperaavailHeight屏幕的像素高度减系统部件高度之后的值（只读）支持支持支持支持availLeft未被系统部件占用的最左侧的像素值（只读）不支持支持支持不支持availTop未被系统部件占用的最上方的像素值（只读）不支持支持支持不支持availWidth屏幕的像素宽度减去系统部件宽度之后的值（只读）支持支持支持支持bufferDepth读、写用于呈现屏外位图的位数支持不支持不支持不支持colorDepth用于表现颜色的位数；多数系统是 32（只读）支持支持支持支持deviceXDPI屏幕实际的水平 DPI（只读）支持不支持不支持不支持deviceYDPI屏幕实际的垂直 DPI（只读）支持不支持不支持不支持fontSmooth / ingEnabled表示是否启用字体平滑（只读）支持不支持不支持不支持height屏幕的像素高度支持支持支持支持left当前屏幕距离左边的像素距离不支持支持不支持不支持logicalXDPI屏幕逻辑的水平 DPI（只读）支持不支持不支持不支持logicalYDPI屏幕逻辑的垂直 DPI（只读）支持不支持不支持不支持pixelDepth屏幕的位深不支持支持支持支持top当前屏幕距上边的像素距离不支持支持不支持不支持updateInterval读、写以毫秒表示的屏幕刷新时间间隔支持不支持不支持不支持width屏幕的像素宽度支持支持支持支持 history 对象history 对象保存着用户上网的的历史记录。 go()：在用户的历史记录中任意跳转，可以向其也可以向后。该方法接收一个参数，正数表示向前，负数表示向后。 back()：后退。 forward()：前进。 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第八章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"第七章 函数表达式","slug":"第七章-函数表达式","date":"2017-07-09T23:11:07.000Z","updated":"2017-07-23T23:39:20.000Z","comments":true,"path":"2017/07/10/第七章-函数表达式/","link":"","permalink":"https://panzeyong.github.io/2017/07/10/第七章-函数表达式/","excerpt":"","text":"一、创建函数方式1、函数声明声明函数使用的关键字是 function，紧接着是指定函数名及函数体。每个函数都定义一个非标准的 name 属性，通过该属性可以访问到给函数指定的名字。对于函数声明来说，有一个重要特征就是函数提升，即在执行代码之前会先读取函数声明。 1234function create() &#123; alert(\"函数声明\"); alert(create.name);&#125; 2、函数表达式（匿名函数、拉姆达函数）创建一个函数并将其赋值给一个变量，这样的创建的函数也可以称为匿名函数或者拉达姆函数。匿名函数的 name 属性是空字符串。使用这种方式创建函数时，必须先赋值才可以使用，否则会报错。 123var create = function() &#123; alert(\"函数表达式\");&#125; 二、闭包闭包是指有权访问另一个函数作用域中的变量的函数。而创建闭包的常用方式，就是在一个函数内部创建另一个函数。 1234567891011121314151617function createComparisonFunction(propertyName) &#123; console.log(\"create Comparison Function\"); return function(object1, object2) &#123; console.log(\"Any\"); var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 1、理解作用域链当某个函数被调用时，系统会创建一个执行环境以及相应的作用域链；此时会有一个函数的活动对象（变量对象），包含 arguments 和其它命名参数。该活动对象会加入到作用域链的前端，并且作用域链的终点是全局执行环境。 在创建函数时，系统会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的 [[Scope]] 属性中。当调用该函数时，会为函数创建一个执行环境，然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。 作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 函数的执行环境只存在于函数的执行过程中，当执行结束后，活动对象及作用域链被销毁；而全局环境直到程序退出才被销毁。 对于闭包来说情况则不同，由于匿名函数的作用域包含了外部函数，即引用外部函数活动对象；因此，当外部函数执行完毕后，虽然其作用域链被销毁，但是其活动对象仍然留在内存中；直到匿名内部函数被销毁后，此活动对象才会被销毁。 2、闭包与变量闭包只能取得包含函数中任意变量的最后一个值。记住闭包保存的是整个变量对象，而不是某个特殊的变量。 先来看一个例子 1234567891011121314151617181920function createFunctions() &#123; console.log(\"Create Function\"); var result = new Array(); for(var i = 0; i &lt; 10; i++) &#123; console.log(\"i : \" + i); result[i] = function() &#123; console.log(\"Result\"); return i; &#125;; &#125; return result;&#125;// 返回的是函数数组var result = createFunctions();for (var i = 0; i &lt; result.length; i++) &#123; alert(result[i]());&#125; 估计很多人跟我一样以为输出的值应该是 0、1、…、9，然而结果却都是 10。说真的，我一开始也懵逼，不知道为什么，但是经过慢慢地调试，稍微了解原因，简单说下自己的理解吧。 当调用函数 createFunctions() 时，for 循环就会被执行，这时数组 result 保存着每次执行后的函数，等到执行完之后，i 的值已经变为 10 了；而由于每个函数的作用域链包含外部函数 createFunctions() 的活动对象，即共享外部函数变量；因此，调用函数数组中每个函数时的返回值都是 10。 那么如何才能做到每个函数的返回值是其索引呢？见以下例子（ps：书中例子） 1234567891011121314151617181920function createFunctions() &#123; var result = new Array(); console.log(\"Create Function\"); for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; console.log(\"i : \" + i); return function() &#123; console.log(\"Number : \" + num); return num; &#125; &#125;(i); &#125; return result;&#125;var result = createFunctions();for (var i = 0; i &lt; result.length; i++) &#123; alert(result[i]();&#125; （ps：由于刚接触闭包这个知识点，对书中的例子还不是很理解，后续补上自己的理解。） 3、关于 this 对象this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。但是匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 每个函数被调用时自动取得两个特殊变量：this 和 arguments，那么跟 arguments 跟 this 存在同样的问题。如果想访问作用域中的 arguments 或 this 对象时，必须将该对象的引用保存到另一个闭包能够访问的变量中。 123456789101112var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function() &#123; var that = this; // 关键在这行代码 return function() &#123; return that.name; &#125;; &#125;&#125;; 三、模仿块级作用域在函数中定义的局部变量的生命周期只局限于该函数，函数执行完之后，局部变量也就销毁。但是由于 JavaScript 没有块级作用域的概念，即在函数代码块中定义的变量在代码块之外也能访问到，为了解决这种问题，可以使用匿名函数模仿块级作用域（私有作用域）来解决。语法如下： 123(function() &#123; // 块级作用域&#125;)(); JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换为函数表达式，只需给它加上一对圆括号。 私有作用域这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。 私有作用域这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链。 引用书中例子，如下： 123456789function outputNumbers(count) &#123; (function() &#123; for(var i = 0; i &lt; count; i++) &#123; alert(i); &#125; // 执行完之后 i 销毁 &#125;)(); alert(i); // 报错&#125; 四、私有变量任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量一般包括函数的参数、局部变量和在函数内部定义的其它函数。 特权方法：有权访问私有变量和私有函数的公有方法。 1、创建特权方法的方式第一种方法：在构造函数中定义特权方法（之所以能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所以变量和函数。） 123456789101112131415function MyObject() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; 使用该种方法的缺点是构造函数模式针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这个问题。 第二种方法：通过在私有作用域中定义私有变量或函数，也可以创建特权方法。（原型模式） 12345678910111213141516171819(function() &#123; // 私有变量和私有函数 var privateVaribalbe = 10; function privateFunction() &#123; return false; &#125; // 构造函数 MyObject = function() &#123; &#125;; // 特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 通过这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。 该方法与第一种方法的区别在于：私有变量和函数是由实例共享的。 2、模块模式（道格拉斯）模块模式：为单例创建私有变量和特权方法。 模块模式使用场景：如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法。 JavaScript 是以对象字面量的方式来创建单例对象的。 模块模式模板： 123456789101112131415161718var singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 return &#123; publicProperty: true; publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;&#125;(); 创建匿名函数并立即调用匿名函数，将对象字面量作为函数返回值，并将其赋值给变量 singleton；由于对象字面量通过特权方法访问匿名函数中私有变量和私有函数，因此变量 singleton 可以其进行访问。以这种方式创建的每个单例都是 Object 的实例。 3、增强的模块模式在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。 123456789101112131415161718192021var singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 创建自定义类型对象 var object = new CustomType(); object.publicProperty: true; object.publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125;; return object;&#125;(); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第七章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Canvas 用法一：绘制图形","slug":"Canvas-用法一-————-绘制图形","date":"2017-07-09T04:19:11.000Z","updated":"2017-07-13T09:47:09.000Z","comments":true,"path":"2017/07/09/Canvas-用法一-————-绘制图形/","link":"","permalink":"https://panzeyong.github.io/2017/07/09/Canvas-用法一-————-绘制图形/","excerpt":"","text":"一、Canvas 简介Canvas 翻译过来为画布意思。这好比我们在学画画时，首先要有一块画板，然后使用各种彩色笔在画板上绘制各种各样的图形，最终会呈现给我们一幅优美的画。在这里，Canvas 就相当于画板，我们可以使用画笔在 Canvas 绘制各种各样的图形，最终画出我们想要的图形。 Canvas 是 Android 2D 绘制图形的继承，提供丰富的 API 接口，功能非常强大。根据官方文档的介绍，要绘制某些东西需要 4 中基本组件： 持有像素的位图（Bitmap）； 画布（Canvas）； 绘图元素（Rect）； 画笔（Paint）。 二、Canvas API 简介操作类型相关 APIAPI 解释绘制颜色drawARGB(int a, int r, int g, int b)使用 ARGB 填充整块画布drawColor(int color)使用颜色填充整块画布drawColor(int color, PorterDuff.Mode mode)使用颜色和 PorterDuff.Mode 填充整块画布drawRGB(int r, int g, int b)使用 RGB 填充整块画布绘制点drawPoint(float x, float y, Paint paint)绘制单个点drawPoints(float[] pts, Paint paint)绘制一组点drawPoints(float[] pts, int offset, int count, Paint paint)绘制一系列点绘制直线drawLine(float startX, float startY, float stopX, float stopY, Paint paint)使用画笔绘制直线drawLines(float[] pts, Paint paint)使用画笔绘制一组直线drawLines(float[] pts, int offset, int count, Paint paint)使用画笔绘制一系列直线绘制矩形drawRect(float left, float top, float right, float bottom, Paint paint)使用画笔绘制矩形drawRect(Rect r, Paint paint) drawRect(RectF rect, Paint paint)绘制圆角矩形drawRoundRect(RectF rect, float rx, float ry, Paint paint)使用画笔绘制圆角矩形drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint)（Android 5.0 及以上才有）绘制椭圆drawOval(float left, float top, float right, float bottom, Paint paint)（Android 5.0 及以上才有）使用画笔绘制椭圆drawOval(RectF oval, Paint paint)绘制圆drawCircle(float cx, float cy, float radius, Paint paint)使用画笔绘制圆绘制圆弧drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)使用画笔绘制圆弧drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)（Android 5.0 及以上才有） 以上只是部分 API 介绍，随着自己进一步学习，会继续完善。 三、Canvas 用法以上介绍部分 Canvas API，那么接下来的任务是学习如何使用相关 API。 1、绘制颜色Canvas API 提供 4 个方法用于绘制颜色，即用某种颜色填充整块画布。 1234567canvas.drawARGB(225, 0, 255, 0);canvas.drawColor(Color.GREEN);canvas.drawRGB(0, 255, 0);canvas.drawColor(Color.GREEN, PorterDuff.Mode.LIGHTEN); 需要注意的是绘制颜色第 4 种方法（即第 7 行代码）中第二个参数 PorterDuff.Mode，具体请参考官网。（ps：这知识点还不是很了解，有时间再研究。） 对于以下各种图形的绘制，都需要画笔，那么就先来创建画笔。 12345678910111213141516public class CustomView extend View &#123; private Paint mPaint; public CustomView(Context context) &#123; super(context); &#125; public CustomView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.GREEN); // 设置画笔颜色 mPaint.setStrokeWidth(2); // 设置画笔宽度 mPaint.setStyle(Paint.Style.STROKE); // 设置画笔风格（描边） &#125;&#125; 2、绘制点Canvas API 提供 3 个方法用于绘制单个点、一组点以及一系列点。 123456789// 由于点形状比较小，不容易看清，所以将画笔宽度设置大点mPaint.setStrokeWidth(10);// 绘制单个点，画笔颜色为 Color.GREENcanvas.drawPoint(300, 300, mPaint);//绘制一组点，画笔颜色为 Color.RED mPaint.setColor(Color.RED); canvas.drawPoints(new float[] &#123;400, 400, 300, 500, 500, 500&#125;, mPaint); 有没有发现点的形状是正方形，这是因为 Paint 默认 Paint.Cap 属性是 Paint.Cap.SQUARE。如果要修改该属性，可以调用 Paint 方法 setStrokeCap(Paint.Cap cap) 修改。 3、绘制直线Canvas 提供 3 个方法用于绘制单条直线、一组直线和一系列直线。 12345678910111213mPaint.setStrokeWidth(2);// 绘制单条直线，画笔颜色为 Color.GREENmPaint.setColor(Color.GREEN);canvas.drawPoint(300, 300, mPaint);// 绘制一组直线，画笔颜色为 Color.REDmPaint.setColor(Color.RED);canvas.drawLines(new float[] &#123;400, 400, 300, 500, 300, 500, 500, 500, 500, 500, 400, 400&#125;, mPaint);// 绘制一系列直线，画笔颜色为 Color.MAGENTAmPaint.setColor(Color.MAGENTA);canvas.drawLines(new float[] &#123;400, 250, 300, 350, 300, 350, 500, 350, 500, 350, 400, 250&#125;, 0, 12, mPaint); 看下绘制直线第三种方法，即第 13 行代码，方法原型为：drawLines(float[] pts, int offset, int count, Paint paint) pts：绘制直线所需要的点； offset：跳过点个数，这些点不参与绘制； count：实际参与绘制个数； paint：画笔。 该方法相对比较灵活，可以通过参数 offset、count 设置来决定绘制哪些线段。 4、绘制矩形Canvas API 提供 3 个方法用于绘制矩形。绘制矩形一般只需要两个点就可以绘制，即左上角和右下角这两个点坐标即可。 123456789101112Rect rect = new Rect(getWidth() / 8, getHeight() / 8 + 500, getWidth() / 8 * 7, getHeight() / 8 * 3 + 500);RectF rectF = new RectF(getWidth() / 8, getHeight() / 8 + 200, getWidth() / 8 * 7, getHeight() / 8 * 3 + 200);mPaint.setColor(Color.GREEN);canvas.drawRect(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getWidth() / 8 * 3, mPaint);mPaint.setColor(Color.MAGENTA);canvas.drawRect(rectF, mPaint);mPaint.setColor(Color.RED);canvas.drawRect(rect, mPaint); 5、绘制圆角矩形Canvas API 提供 2 种方法用于绘制圆角矩形，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。 123456789// 第一种绘制圆角矩形方法mPaint.setStrokeWidth(5);RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRoundRect(rect, 50, 50, mPaint);// 第二种绘制圆角矩形方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawRoundRect(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, 50, 50, mPaint);&#125; 6、绘制椭圆Canvas API 提供 2 种方法用于绘制椭圆，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。其实椭圆是被包裹在矩形内，话句话说，是矩形的内切图形。绘制椭圆也很容易，只需传入矩形 RectF 和绘制图形 Paint 就可以。 123456789101112// 第一种绘制椭圆方法RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawLine(getWidth() / 8, getHeight() / 4, getWidth() / 8 * 7, getHeight() / 4, mPaint);canvas.drawLine(getWidth() / 2, getHeight() / 8, getWidth() / 2, getHeight() / 8 * 3, mPaint);canvas.drawRect(rect, mPaint);canvas.drawOval(rect, mPaint);// 第二种绘制椭圆方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawOval(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, mPaint);&#125; 以上多绘制出矩形和两条直线，主要是为了方便看清。 7、绘制圆形Canvas API 提供 1 种方法用于绘制圆形。绘制圆形只需要知道圆心和半径。 1234canvas.drawCircle(getWidth() / 2, getHeight() / 2, 200, mPaint);mPaint.setStrokeWidth(5);mPaint.setStrokeCap(Paint.Cap.ROUND);canvas.drawPoint(getWidth() / 2, getHeight() / 2, mPaint); 这里我把圆心也给画出来了，画笔的宽度设置为 5，容易看清。 8、绘制圆弧Canvas API 提供 2 种方法用于绘制圆弧，其中有一种方法是 Android 5.0 以上才提供，见以上 API 介绍。有必要来解释下这两种方法各个参数的含义，以drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 为例子： oval：矩形； startAngle：起始角度； sweepAngle：绘制圆弧的角度，即扫描过的角度； useCenter：true 或者 false，至于区别通过例子来说明。 paint：画笔。 12345678910111213141516171819// userCenter 为 trueRectF rectF = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRect(rectF, mPaint);mPaint.setStyle(Paint.Style.FILL);canvas.drawArc(rectF, 0, 90, true, mPaint);canvas.translate(getWidth() / 16, getHeight() / 3);// userCenter 为 false mPaint.setStyle(Paint.Style.STROKE);RectF rect = new RectF(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3);canvas.drawRect(rect, mPaint);mPaint.setStyle(Paint.Style.FILL);canvas.drawArc(rect, 0, 90, false, mPaint);// 第二种方法if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; canvas.drawArc(getWidth() / 8, getHeight() / 8, getWidth() / 8 * 7, getHeight() / 8 * 3, 0, 90, false, mPaint);&#125; 第一个图形是 userCenter 为 true 的效果图；第二个图形则是 userCenter 为 false 的效果图。 四、小示例学习了 Canvas 绘制图形的基本用法后，通过一个具体的例子来综合运用绘制图形方法。这个具体的例子是画圆饼，相信大家应该经常看到这种图形。这个例子是参考这篇博客：安卓自定义View进阶-Canvas之绘制图形，先看看自己实现的效果图吧。 简单分析下：画这类图最主要的元素是数据，即总共有多少个模块，每个模块的值具体是多少，每个模块在总数中所占的比例以及用某种颜色表示某个模块。因此，这个可以将其封装为数据类，即 Bean。数据有了之后，接下来就根据我们学过的知识点进行绘制，来看下具体代码吧： 用户数据类 Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Bean &#123; private int color; private float percentage; private String name; private float angle; private float value; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; &#125; public float getPercentage() &#123; return percentage; &#125; public void setPercentage(float percentage) &#123; this.percentage = percentage; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getAngle() &#123; return angle; &#125; public void setAngle(float angle) &#123; this.angle = angle; &#125; public float getValue() &#123; return value; &#125; public void setValue(float value) &#123; this.value = value; &#125;&#125; 自定义 View 绘制圆饼 RoundCakeView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class RoundCakeView extends View &#123; private final static String TAG = RoundCakeView.class.getCanonicalName(); private Paint mPaint; private List&lt;Bean&gt; mList; private float mStartAngle; private int mWidth; private int mHeight; public RoundCakeView(Context context) &#123; super(context); &#125; public RoundCakeView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public RoundCakeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setStyle(Paint.Style.STROKE); mPaint.setColor(Color.GREEN); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); this.mWidth = w; this.mHeight = h; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Log.d(TAG, \"onDraw()\"); int x = mWidth / 2; int y = mHeight / 2; int r = 200; RectF rectF = new RectF(x - r, y - r, x + r, y + r); float currentAngle = mStartAngle; // draw circle point mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setStrokeWidth(5); canvas.drawPoint(x, y, mPaint); // draw circle mPaint.setStrokeWidth(0); mPaint.setColor(Color.RED); canvas.drawCircle(x, y, r, mPaint); mPaint.setStyle(Paint.Style.FILL); // draw arc for (int i = 0; i &lt; mList.size(); i++) &#123; Bean bean = mList.get(i); mPaint.setColor(bean.getColor()); canvas.drawArc(rectF, currentAngle, bean.getAngle(), true, mPaint); currentAngle += bean.getAngle(); &#125; &#125; public void setList(List&lt;Bean&gt; list) &#123; this.mList = list; invalidate(); &#125; public void setStartAngle(float angle) &#123; this.mStartAngle = angle; &#125;&#125; 那么接下来就是显示出效果了，先看下布局文件 activity_main.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.pan.canvasdemo.MainActivity\"&gt; &lt;com.pan.canvasdemo.RoundCakeView android:id=\"@+id/rcv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends AppCompatActivity &#123; private final static String TAG = MainActivity.class.getCanonicalName(); private RoundCakeView mView; private int [] mColors = &#123;Color.RED, Color.GREEN, Color.BLUE, Color.DKGRAY, Color.MAGENTA&#125;; private int [] mValues = &#123;23, 98, 122, 78, 225&#125;; private List&lt;Bean&gt; mList = new ArrayList&lt;&gt;(); private float mSum; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); initData(); mView.setStartAngle(0); mView.setList(mList); &#125; private void init() &#123; mView = (RoundCakeView) findViewById(R.id.rcv); &#125; private void initData() &#123; for (int i = 0; i &lt; mValues.length; i++) &#123; mSum += mValues[i]; &#125; for (int i = 0; i &lt; 5; i++) &#123; Bean bean = new Bean(); bean.setColor(mColors[i]); bean.setValue(mValues[i]); bean.setPercentage(bean.getValue() / mSum); bean.setAngle(bean.getPercentage() * 360); bean.setName(i + \"\"); mList.add(bean); Log.d(TAG, \"Value : \" + bean.getValue()); Log.d(TAG, \"Percentage : \" + bean.getPercentage()); Log.d(TAG, \"Angle : \" + bean.getAngle()); &#125; &#125;&#125; 以下就是画圆饼的具体实现，逻辑不是很难懂，加上部分注释应该很容易理解。 参考资料安卓自定义View进阶-Canvas之绘制图形","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"自定义 View","slug":"自定义-View","permalink":"https://panzeyong.github.io/tags/自定义-View/"}]},{"title":"第 六 章 面向对象的程序设计","slug":"第六章-面向对象的程序设计","date":"2017-06-25T23:56:20.000Z","updated":"2017-07-23T15:07:21.000Z","comments":true,"path":"2017/06/26/第六章-面向对象的程序设计/","link":"","permalink":"https://panzeyong.github.io/2017/06/26/第六章-面向对象的程序设计/","excerpt":"","text":"一、理解对象1、属性类型 数据属性：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。有以下 4 个描述其行为的特性： [[Configurable]]：表示是否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。一旦该属性定义为不可配置，即 false，那么就再也不可能设置为可配置了，即 true。此时，再调用 Object.defineProperty() 方法修改除 writable 之外的属性都会导致错。在非严格模式下什么也不会发生，而在严格模式下会导致错误。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Writable]]：表示能否修改属性的值。在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致错误。（在对象上直接定义的属性，默认值为 true） [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认属性，必须调用 ECMAScript5 的 Object.defineProperty() 方法。该方法接收三个参数：属性所在的对象、属性的名字、和一个描述符对象。描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。例子如下： 将属性特性 writable 改为只读 12345678910111213141516var person = new Object();person.name = \"Julian\";person.age = 22;person.job = \"Software Engineer\";person.sayName = function() &#123; alert(this.name);&#125;;Object.defineProperty(person, \"name\", &#123; writable : false&#125;);person.sayName(); // 修改之前：Julianperson.name = \"Jack\";person.sayName(); // 修改之后：Julian 将属性特性 configurable 改为不可配置（对象 person 使用上面代码）。 1234567Object.defineProperty(person, \"name\", &#123;configurable : false&#125;);person.sayName(); // 修改之前：Juliandelete persion.name;person.sayName(); // 修改之后：Julian 在将属性特性 configurable 改为不可配置时再修改其它属性特性（writable 除外），抛出错误。 1234567Object.defineProperty(person, \"name\", &#123; value : \"Marry\"&#125;);// 错误提示Uncaught TypeError: Cannot redefine property: name at Function.defineProperty (&lt;anonymous&gt;) 访问器属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Get]]：在读取属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能写入，在非严格模式下写入属性会被忽略；在严格模式下写入属性会抛出错误。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能读取，在非严格模式下读取时返回 undefined；在严格模式下会抛出错误。 访问器不能直接定义，必须使用 Object.defineProperty() 定义。 书中例子，代码如下 123456789101112131415161718192021222324252627282930var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; console.log(\"get\"); return this._year; &#125;, set: function(value) &#123; if (value &gt; 2004) &#123; console.log(\"set\"); this._year = value; this.edition += value - 2004; &#125; &#125;&#125;);// 调用访问器 setbook.year = 2007; alert(book.edition); // 调用访问器 getalert(book.year);// 如果将属性名 “year” 改为 \"_year\"，并设置 book._year = 2007，则会导致无限递归，最终导致错误。// 注：_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问属性。 2、定义多个属性调用方法 Object.defineProperties() 可以为一个对象定义多个属性，该方法接收两个对象参数：第一个对象参数是要添加和修改其属性的对象；第二个对象参数是第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 书中例子，代码如下： 12345678910111213141516171819202122232425262728var book = &#123;&#125;;Object.defineProperties(book, &#123; // 数据属性 _year: &#123; value: 2005 &#125;, // 数据属性 edition: &#123; value: 1 &#125;, // 访问器属性 year: &#123; get: function() &#123; return this._year; &#125;, set: function(value) &#123; if (value &gt; 2005) &#123; this._year = value; this.edition += value - 2005; &#125; &#125; &#125;&#125;); 3、读取属性的特性调用 Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取器描述符的属性名称。返回一个对象。 书中例子，代码如下：（基于以上代码） 123456789101112131415// 数据属性var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); // 2005alert(descriptor.configurable); // falsealert(descriptor.writable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // undefined// 访问器属性var descriptor = Object.getOwnPropertyDescriptor(book, \"year\");alert(descriptor.value); // undefined alert(descriptor.configurable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // functionalert(typeof descriptor.set); // function 二、创建对象1、工厂模式用函数来封装以特定接口创建对象的细节，与 Java 中 class 类似，即将对象类型的属性和方法进行封装。 2、构造函数模式可用来创建特定类型的对象，用 new 操作符来调用，这是与普通函数唯一的区别。 3、原型模式在 JavaScript 中，我们创建的每个函数都包含一个（原型）属性：prototype。prototype 属性是一个指针，指向一个对象，即原型对象，该原型对象包含可由特定类型的所有实例共享的属性和方法。换句话说，该原型对象可以说是调用构造函数而创建的对象实例的原型对象。使用原型对象的好处是让所有对象实例共享它包含的属性和方法。 书中例子，代码如下：（1） 1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = \"Marry\";Person.prototype.age = 22;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName();var person2 = new Person();person2.sayName();alert(person1.sayName == person2.sayName); // true 理解原型对象 每当我们创建新函数时，就会根据特定规则为该函数创建一个 prototype 属性，该属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获取 constructor （构造函数）属性，该属性包含一个指向 prototype 属性所在函数的指针。 prototype 这个属性连接在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 读取对象属性的原则：先从对象实例进行搜索，搜索不到的话再从原型对象进行搜索。 虽然可以通过对象实例访问保存在原型对象中的值，但是却不能通过对象实例修改原型对象中的值。如果我们在对象实例定义与原型对象中同名的属性，则对象实例中的属性会屏蔽原型对象中的属性。 使用 delete 操作符可以则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。 原型与 in 操作符 使用 in 操作符方式：单独使用和在 for-in 循环中使用。 单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象，还是存在于原型中。 在 for-in 中，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将 [[Enumerable]]）标记为 false 属性）的实例属性也会在 for-in 循环中返回。（例子如下） 123456789101112131415161718192021222324252627282930313233343536var object = &#123; toString : function() &#123; return \"toString\"; &#125;, hasOwnProperty : function() &#123; return \"hasOwnProperty\"; &#125;, propertyIsEnumerable : function() &#123; return \"propertyIsEnumerable\"; &#125;, toLocaleString : function() &#123; return \"toLocaleString\"; &#125;, valueOf : function() &#123; return \"valueOf\"; &#125;&#125;;for(var o in object) &#123; if (o == \"toString\") &#123; alert(\"toString\"); alert(o); &#125; else if (o == \"toLocaleString\") &#123; alert(\"toLocaleString\"); &#125; else if (o == \"valueOf\") &#123; alert(\"valueOf\"); &#125; else if (o == \"hasOwnProperty\") &#123; alert(\"hasOwnProperty\"); &#125; else if (o == \"propertyIsEnumerable\") &#123; alert(\"propertyIsEnumerable\"); &#125;&#125; 更简单的原型语法 用一个包含所有属性和方法的对象字面量来重写整个原型对象。需要注意的是 constructor 属性不再指向 prototype 属性所在函数（比如 Person），而是指向 Object 构造函数。 12345678910function Person() &#123;&#125;Person.prototype = &#123; name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; 原型的动态性 对原型对象的任何修改都能够立即从实例上反映出来，原因是实例与原型之间的松散连接关系。 123456789function Person() &#123;&#125; var person = new Person(); Person.prototype.sayHi = function() &#123; alert(\"Hi\");&#125;; person.sayHi(); 如果对原型对象进行重写，那情况就不一样。这时存在两个对象，并且毫无关联。 123456789101112131415function Person() &#123;&#125; var friend = new Person(); Person.prototype = &#123; constructor : Person, name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; friend.sayName(); // error 实例中的指针仅指向原型，而不指向构造函数。 构造函数、原型与实例之间关系 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 4、组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。好处是最大限度地节省了内存。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.language = [\"JavaScript\", \"Java\", \"PHP\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.language.push(\"Python\");alert(person1.language); // \"JavaScript, Java, PHP, Python\"alert(person2.language); // \"JavaScript, Java, PHP\"alert(person1.language == person2.language); // falsealert(person1.sayName == person2.sayName); // true 5、动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 123456789101112function Person(name, age, job) &#123; // 属性 this.name = name; this.age = age; this.job = job; if(typeof this.sayName != \"function\") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125; 6、寄生构造函数模式创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。（与工厂模式类似） 12345678910functuon Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; retrun o;&#125; 7、稳妥构造函数模式稳妥对象：指的是没有公共属性，而且其方法也不引用 this 的对象。 适用场景：一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其它应用程序（如 Mashup 程序）改动时使用。 稳妥构造函数与寄生构造函数模式区别： 稳妥构造函数新创建对象的实例方法不引用 this； 稳妥构造函数不使用 new 操作符调用构造函数。 1234567891011121314function Person(name, age, job) &#123; // 创建要返回的对象 var o = new Object(); // 可以在这里定义私有变量和函数 // 添加方法 o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 继承继承有两种方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。ECMAScript 只支持实现继承，并且主要依靠原型链来实现。 1、原型链让一个引用类型继承另一个引用类型的属性和方法。可以简单概括地说：有一个超类，具有属性和方法；通过 new 操作符创建超类实例赋值给子类，即子类的原型指向超类的原型，创建子类实例，指向子类的原型。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function SuperType() &#123; console.log(\"SuperType\"); this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; console.log(\"getSuperValue\"); return this.property;&#125;;function SubType() &#123; console.log(\"SubType\"); this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();// 使用字面量添加新方法，会导致上一行代码无效（17）SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;;// 添加新方法SubType.prototype.getSubValue = function() &#123; console.log(\"getSubValue\"); return this.subproperty;&#125;;// 覆盖方法SubType.prototype.getSuperValue = function() &#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue());alert(instance.getSubValue());alert(instance.property); 需要注意的要点： 所有引用类型默认继承 Object，而且这个继承也是通过原型链实现的。也就是说，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。 在给原型添加新方法或覆盖方法的代码一定要放在替换原型语句之后。 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。（ps：还不是很理解） 原型链存在问题： 包含引用类型值所带来的问题，即引用类型值的所有属性是被共享的，这就导致一个实例修改其中属性，也会影响到其它实例。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 2、借用构造函数（伪造对象或经典继承）在子类型构造函数的内部调用超类型构造函数。可以这样说，在子类创建新对象时执行超类构造函数中初始化代码，使子类实例各具有自己的一份副本。（ps：纯属自己理解） 1234567891011121314function SuperType() &#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType() &#123; SuperType.call(this);&#125;var instance = new SubType();instance.colors.push(\"pink\");alert(instance.colors); // \"red, blue, green, pink\"var instance = new SubType();alert(instance.colors); // \"red, blue, green\" 相对于原型链优势：在子类构造函数中向超类型构造函数传递参数。 借用构造函数存在问题：方法都在构造函数中定义，函数复用无从谈起。 3、组合继承（伪经典继承）使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance = new SubType(\"Jack\", 22);instance.colors.push(\"black\");alert(instance.colors); // \"red, blue, green, pink\" instance.sayName(); // Jackinstance.sayAge(); // 22var instance = new SubType(\"John\", 21); alert(instance.colors); // \"red, blue, green\"instance.sayAge(); // Johninstance.sayName(); // 21 4、原型式继承在函数先创建一个临时构造函数，将传入的对象作为这个构造函数的原型，最终返回该类型的新实例。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 5、寄生式继承（parasitic）创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。与寄生构造函数和工厂模式类型。 1234567function create(original) &#123; var clone = object(original); // object() 原型式继承函数 clone.sayHi = function() &#123; alert(\"hi\"); &#125;; return clone;&#125; 6、寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非就是超类型原型的副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。(主要是为了避免调用两次超类型构造函数) 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 方法 isPrototypeOf()：确定对象之间是否存在关系，即如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象，则返回 true。 12alert(Person.prototype.isPrototypeOf(person1)); // truealert(Person.prototype.isPrototypeOf(person2)); // true Object.getPrototypeOf()：返回 [[Prototype]] 的值。 12alert(Object.getPrototypeOf(person1) == Person.prototype); // truealert(Object.getPrototypeOf(person1).name); // Marry hasOwnProperty()：可以检测一个属性是存在于实例中，还是存在于原型中。如果给定属性存在于实例对象中，则返回 true；否则返回 false。 12345678910111213alert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // falseperson2.name = \"John\";person1.sayName(); // Marryperson2.sayName(); // Johnalert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // truedelete person2.namealert(person2.name); // Maryalert(person2.hasOwnProperty(\"name\")); // false Object.keys()：获取对象上所有可枚举的实例属性。该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 Object.getOwnPropertyNames()：获取所有实例属性，无论是否可枚举。 Object.create()：该方法用于规范化原型式继承。接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 12345678910var person = &#123; name : \"Julian\", friends : [\"Ruby\", \"Java\", \"JavaScript\", \"Python\"]&#125;;var person1 = Object.create(person, &#123; name : &#123; value : \"John\" &#125;&#125;); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第六章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Picasso 用法及源码解析","slug":"Picasso-用法及源码解析","date":"2017-06-06T23:47:21.000Z","updated":"2017-06-19T15:22:12.000Z","comments":true,"path":"2017/06/07/Picasso-用法及源码解析/","link":"","permalink":"https://panzeyong.github.io/2017/06/07/Picasso-用法及源码解析/","excerpt":"","text":"Picasso 是 Square 公司开源的一个 Android 平台优秀图片加载框架，易用、代码简洁、可读性高。自己接触的第一个开源图片加载框架也是 Picasso，以前只停留在会用阶段，根本不知道是如何实现的，最近花了点时间看了 Picasso 源码，学到的东西还是蛮多；大概理解实现基本流程。 对于看源码这事，一开始真不知从哪里下手。于是 Google 了，发现很多都是从使用方法入手，理清方法间是如何调用，最后形成自己的线索。本文也是按照这种方式来分析 Picasso 源码。 Picasso 使用方法 使用 Picasso 加载一张图片很简单，一行代码就搞定 12345Picasso.whth(context) .load(R.mipmap.ic_default) .placeholder(R.mipmap.ic_default) .error(R.mipmap.ic_default) .into(imageView); 加载一张图片并且按照指定尺寸以 centerCrop 形式对图片进行缩放 12345Picasso.with(this) .load(R.mipmap.ic_default) .resize(200, 200) .centerCrop() .into(imageView); 加载一张图片并且按照指定尺寸以 centerInside 形式图片进行缩放（注：对图片进行处理时，centerCrop 或 centerInside 只能选择一种方式，并且必须调用方法 resize(targetWidth, targetHeight) 或者 resizeDimen(targetWidthResId, targetHeightResId) 设置大小） 12345Picasso.with(this) .load(R.mipmap.ic_default) .resizeDimen(R.dimen.width, R.dimen.height) .centerInside() .into(imageView); 加载一张图片并且按照一定角度对其进行旋转 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .rotate(20) .into(imageView); 加载一张图片自适应目标视图（由于调整大小适应目标视图，结果导致请求被延迟，直到调整完毕才会发送请求；目标视图只能是 ImageView） 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .fit() .into(imageView); 加载一张图片并设置回调接口 12345678910Picasso.with(this) .load(R.mipmap.ic_launcher) .into(mImageView, new Callback() &#123; @Override public void onSuccess() &#123; &#125; @Override public void onError() &#123; &#125; &#125;); 以上只是 Picasso 简单的用法，至于其它用法看API；接下来分析下源码。 Picasso 源码解析Picasso.with() 方法解析为了探究 Picasso.with() 方法如何实现，唯独从源代码找答案。代码如下： 123456789101112131415161718192021222324252627282930/** * The global default &#123;@link Picasso&#125; instance. * &lt;p&gt; * This instance is automatically initialized with defaults that are suitable to most * implementations. * &lt;ul&gt; * &lt;li&gt;LRU memory cache of 15% the available application RAM&lt;/li&gt; * &lt;li&gt;Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only * available on API 14+ &lt;em&gt;or&lt;/em&gt; if you are using a standalone library that provides a disk * cache on all API levels like OkHttp)&lt;/li&gt; * &lt;li&gt;Three download threads for disk and network access.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * If these settings do not meet the requirements of your application you can construct your own * with full control over the configuration by using &#123;@link Picasso.Builder&#125; to create a * &#123;@link Picasso&#125; instance. You can either use this directly or by setting it as the global * instance with &#123;@link #setSingletonInstance&#125;. */ public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton;&#125; 从注释中可以得到以下几点： 全局默认实例，也就是说只有一个实例存在，从使用单例模式可以看出。 Picasso 采用两级缓存：内存缓存和磁盘缓存。 LRU 内存缓存大小占整个应用可用 RAM 容量的 15%。 磁盘缓存大小占存储空间的 2%，不少于 5 MB，不超过 50 MB。（注：仅适于 API 14+ 或者所使用的第三方库包含 API，比如 OkHttp）。 为磁盘访问和网络访问提供 3 个线程。 这些配置是 Picasso 默认配置的，如果不满足自己的需求，可以自己定制。通过 Picasso.Builder 创建 Picasson 实例，根据自己需要配置相关属性，并调用方法 setSingletonInstance(picasso) 设置为全局实例。 很明显可以看到，使用单例模式来创建 Picasso 实例，保证全局只有一个实例存在。简单说下 with() 方法的实现，singleton 为 null 时调用 Builder 类中 build() 方法创建 singleton 实例并返回，那么接下来就来看 Builder 类中 build() 方法是如何实现的？ Picasso.Builder 中 build() 方法解析源码如下： 12345678910111213141516171819202122public Picasso build() &#123; Context context = this.context; if (downloader == null) &#123; downloader = Utils.createDefaultDownloader(context); &#125; if (cache == null) &#123; cache = new LruCache(context); &#125; if (service == null) &#123; service = new PicassoExecutorService(); &#125; if (transformer == null) &#123; transformer = RequestTransformer.IDENTITY; &#125; Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled);&#125; Builder 类是 Picasso 这个类中的静态内部类，而 build() 方法是 Builder 类中的成员方法，可以看出采用建造者模式。那么 build() 方法实现的功能主要有： 创建默认下载器 Downloader 创建默认内存缓存 LruCache （由于接口 Cache 支持多线程访问，所以实现该接口时需确保线程安全） 创建默认线程池 PicassoExecutorService 创建默认请求转发器 RequestTransformer 创建默认统计 Stats 创建默认调度器 Dispatcher 创建 Picasso 实例 那么这些实例是如何创建的，下面主要通过流程图来解析（主要是方法间的调用以及方法内部部分细节）。 Downloader 是一个接口，无法实例化，需要通过实现类创建实例，该接口的功能主要从磁盘缓存加载图片或网络下载图片。OkHttpDownloader 和 UrlConnectionDownloader 分别实现该接口，那么创建实例也是通过这两个实现类来创建的，那么来看下实例化 Downloader 流程。 LruCache 是内存缓存类，实现接口 Cache，采用最近最少使用算法。 PicassoExecutorService 继承 ThreadPoolExecutor，是线程池，供图片下载，线程数根据不同网络类型设置，默认的线程数是 3 个，直接通过 new 操作符实例化对象。 RequestTransformer 是一个接口，功能是在发送请求之前对图片进行转换处理。从源码中可以看出，这是一个测试功能，在后续版本可能不兼容，使用该功能时得谨慎。 对于 Stats 实例的创建，直接 new 一个对象，那么主要来看该构造方法做了哪些操作？代码如下： 1234567Stats(Cache cache) &#123; this.cache = cache; this.statsThread = new HandlerThread(STATS_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); this.statsThread.start(); Utils.flushStackLocalLeaks(statsThread.getLooper()); this.handler = new StatsHandler(statsThread.getLooper(), this);&#125; 主要是实例化对象，结合注释应该不难理解。 Dispatcher 实例的创建与 Stats 类似，代码如下： 12345678910111213141516171819202122232425Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler, Downloader downloader, Cache cache, Stats stats) &#123; // dispatcherThread 是子线程，注意记得调用 start() 方法 this.dispatcherThread = new DispatcherThread(); this.dispatcherThread.start(); Utils.flushStackLocalLeaks(dispatcherThread.getLooper()); this.context = context; this.service = service; this.hunterMap = new LinkedHashMap&lt;String, BitmapHunter&gt;(); this.failedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedTags = new HashSet&lt;Object&gt;(); // 注意该 handler 是在子线程的 this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this); this.downloader = downloader; // 在主线程 this.mainThreadHandler = mainThreadHandler; this.cache = cache; this.stats = stats; this.batch = new ArrayList&lt;BitmapHunter&gt;(4); this.airplaneMode = Utils.isAirplaneModeOn(this.context); this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE); this.receiver = new NetworkBroadcastReceiver(this); receiver.register();&#125; 最后，也是最重要的一点，那就是 Picasso 实例的创建，先看下代码吧 1234567891011121314151617181920212223242526272829303132333435363738Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) &#123; this.context = context; this.dispatcher = dispatcher; this.cache = cache; this.listener = listener; this.requestTransformer = requestTransformer; this.defaultBitmapConfig = defaultBitmapConfig; int builtInHandlers = 7; // Adjust this as internal handlers are added or removed. int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0); List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); this.stats = stats; this.targetToAction = new WeakHashMap&lt;Object, Action&gt;(); this.targetToDeferredRequestCreator = new WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;(); this.indicatorsEnabled = indicatorsEnabled; this.loggingEnabled = loggingEnabled; this.referenceQueue = new ReferenceQueue&lt;Object&gt;(); this.cleanupThread = new CleanupThread(referenceQueue, HANDLER); this.cleanupThread.start();&#125; 除了对一些对象赋值外，重要的一点就是创建和添加 RequestHandler，代码主要在 19 ~ 29 行，比如文件、网络、资源等处理器。至此，Picasso 实例也就创建完毕了，那么接下来看 load() 方法是如何实现的。 Picasso.load() 方法解析load() 有多个重载方法，可以传入 resourceId、string、file、uri，但是最后都是返回 RequestCreator 实例，接下来就来看该方法如何实现？代码如下： 1234567public RequestCreator load(int resourceId) &#123; if (resourceId == 0) &#123; throw new IllegalArgumentException(\"Resource ID must not be zero.\"); &#125; return new RequestCreator(this, null, resourceId);&#125; 很明显地看出，调用 load() 方法后返回的是 RequestCreator 实例，那么来看下 RequestCreator 构造方法是咋样的，代码如下： 123456RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123; if (picasso.shutdown) &#123; throw new IllegalStateException(\"Picasso instance already shut down. Cannot submit new requests.\"); &#125; this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig); &#125; 创建 Request.Builder 对象，并将需要加载图片信息封装到该对象里，采用建造者模式。对于一些操作比如 rotate、centerCrop、centerInside、resize 等，其实只是修改其状态，真正执行操作是方法 into，该方法是核心方法，以下重点分析。 into() 方法解析into() 有 5 个重载方法，每个方法实现的主要功能基本相同，但是稍微还是有点不一样的。以常用 into(ImageView target) 这个方法为例子来讲解下内部是如何实现的？由于个人比较喜欢画流程图来理清方法之间调用关系，于是就有下面的流程图： 结合流程图再来看源码应该会比较好理解，代码如下： 123public void into(ImageView target) &#123; into(target, null);&#125; 该方法所持有的 ImageView 实例是一个弱引用，内存不足情况下可以自动被垃圾回收器回收。很明显，该方法调用重载方法 into(target, null)，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); checkMain(); if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123; if (data.hasSize()) &#123; throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action);&#125; 参数 Callback 是一个强引用，将会阻止 Activity 或者 Fragment 被回收，从而导致内存泄漏。如果使用该方法，在释放资源时最好调用 Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求，以免造成内存泄漏。从源码可以清晰地看出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 判断目标组件 ImageView 是否为 null；如果不为 null，则继续执行；否则抛出异常。 检查发送请求是否包含要加载图片 uri 或 resourceId；如果没有，则调用Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求（后面讲解该方法），并检查是否设置默认图片；否则继续执行。 检查是否调用方法 fit()，即 deferred 是否为 true，true 表示调用，false 表示调用 unfit() 方法；调用该方法意味着延迟加载图片，并且不能与方法 resize() 同时使用。 为加载图片创建请求。 为每个请求创建 key，主要是为了方便存储。 根据缓存策略判断是否从内存缓存读取。 是否设置默认图片。 创建对应的 Action 实例，在这里是 ImageViewAction。 入队和提交 action。 以上是总体概括，接下来逐一看具体实现。 那么先来看下 cancelRequest(android.widget.ImageView) 具体实现，代码如下： 123public void cancelRequest(ImageView view) &#123; cancelExistingRequest(view);&#125; 只有一行代码，调用 cancelExistingRequest(view) 方法，看下具体实现： 12345678910111213141516private void cancelExistingRequest(Object target) &#123; checkMain(); Action action = targetToAction.remove(target); if (action != null) &#123; action.cancel(); dispatcher.dispatchCancel(action); &#125; if (target instanceof ImageView) &#123; ImageView targetImageView = (ImageView) target; DeferredRequestCreator deferredRequestCreator = targetToDeferredRequestCreator.remove(targetImageView); if (deferredRequestCreator != null) &#123; deferredRequestCreator.cancel(); &#125; &#125; &#125; 按照惯例，先列出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 通过 key 从 targetToAction 移除对应 action。 如果 action 不为 null，执行一些取消操作，相当于释放资源。 如果目标组件是 ImageView，则检查是否调用 fit() 方法，是的话就执行一些取消操作。 接着来看下取消操作方法 dispatcher.dispatchCancel(action) 具体实现： 123void dispatchCancel(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));&#125; 很明显是通过 Handler 消息机制来处理的。即 Dispatcher 类中 DispatcherHandler 发送消息 REQUEST_CANCEL，并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performCancel(action) 具体实现： 1234567891011121314151617181920212223242526void performCancel(Action action) &#123; String key = action.getKey(); BitmapHunter hunter = hunterMap.get(key); if (hunter != null) &#123; hunter.detach(action); if (hunter.cancel()) &#123; hunterMap.remove(key); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId()); &#125; &#125; &#125; if (pausedTags.contains(action.getTag())) &#123; pausedActions.remove(action.getTarget()); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId(), \"because paused request got canceled\"); &#125; &#125; Action remove = failedActions.remove(action.getTarget()); if (remove != null &amp;&amp; remove.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, remove.getRequest().logId(), \"from replaying\"); &#125;&#125; 从以上代码很清晰地看出该方法主要做一些取消、移除操作，即释放资源。以上就是 cancelExistingRequest(view) 内部实现解析。 回到 into(target, null) 内部实现，看下创建请求 createRequest(started) 具体实现： 12345678910111213141516171819202122232425private Request createRequest(long started) &#123; int id = nextId.getAndIncrement(); Request request = data.build(); request.id = id; request.started = started; boolean loggingEnabled = picasso.loggingEnabled; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString()); &#125; Request transformed = picasso.transformRequest(request); if (transformed != request) &#123; // If the request was changed, copy over the id and timestamp from the original. transformed.id = id; transformed.started = started; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), \"into \" + transformed); &#125; &#125; return transformed;&#125; 其实实现逻辑很简单，对要加载图片的具体信息封装成 Request；通过 Request 创建对应 key，那么来看下是如何创建的，即 createKey(request) 方法具体实现： 12345static String createKey(Request data) &#123; String result = createKey(data, MAIN_THREAD_KEY_BUILDER); MAIN_THREAD_KEY_BUILDER.setLength(0); return result;&#125; 逻辑很简单，调用方法 createKey(data, MAIN_THREAD_KEY_BUILDER)，看下具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041static String createKey(Request data, StringBuilder builder) &#123; if (data.stableKey != null) &#123; builder.ensureCapacity(data.stableKey.length() + KEY_PADDING); builder.append(data.stableKey); &#125; else if (data.uri != null) &#123; String path = data.uri.toString(); builder.ensureCapacity(path.length() + KEY_PADDING); builder.append(path); &#125; else &#123; builder.ensureCapacity(KEY_PADDING); builder.append(data.resourceId); &#125; builder.append(KEY_SEPARATOR); if (data.rotationDegrees != 0) &#123; builder.append(\"rotation:\").append(data.rotationDegrees); if (data.hasRotationPivot) &#123; builder.append('@').append(data.rotationPivotX).append('x').append(data.rotationPivotY); &#125; builder.append(KEY_SEPARATOR); &#125; if (data.hasSize()) &#123; builder.append(\"resize:\").append(data.targetWidth).append('x').append(data.targetHeight); builder.append(KEY_SEPARATOR); &#125; if (data.centerCrop) &#123; builder.append(\"centerCrop\").append(KEY_SEPARATOR); &#125; else if (data.centerInside) &#123; builder.append(\"centerInside\").append(KEY_SEPARATOR); &#125; if (data.transformations != null) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, count = data.transformations.size(); i &lt; count; i++) &#123; builder.append(data.transformations.get(i).key()); builder.append(KEY_SEPARATOR); &#125; &#125; return builder.toString();&#125; 很简单，根据 Request 设置的属性拼接为字符串，作为最终的 key 并返回。 当我们调用不同 into() 方法时，Picasso 就会实例化不同的 Action，而这里我们是以 into(ImageView) 为例子，因此会实例化 ImageViewAction，在 ImageView 有回调方法，供我们使用，后续会看到。一切都准备就绪，那么就可以入队和提交 action。那么是如何实现的呢？来看下具体实现： 123456789void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action);&#125; 通过 key 从 targetToAction 获取 action，不存在的话就执行检查操作并将 action 插入到 targetToAction，最后调用 submit(action)，具体实现如下： 123void submit(Action action) &#123; dispatcher.dispatchSubmit(action);&#125; 最后还是回到 Dispatcher，通过 DispatcherHandler 消息机制发送消息 REQUEST_SUBMIT，并在其回调方法 并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 123456789101112131415161718@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performSubmit(action) 具体实现： 123void performSubmit(Action action) &#123; performSubmit(action, true);&#125; 只有一行代码，调用方法 performSubmit(action, true)，具体实现如下： 12345678910111213141516171819202122232425262728293031323334void performSubmit(Action action, boolean dismissFailed) &#123; if (pausedTags.contains(action.getTag())) &#123; pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), \"because tag '\" + action.getTag() + \"' is paused\"); &#125; return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\"); &#125; return; &#125; hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); hunterMap.put(action.getKey(), hunter); if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125;&#125; 简要概括下该方法实现的主要功能： 检查标记 tag 请求是否被取消，如果被取消，则将对应 action 插入到 pausedActions 并退出程序；否则继续执行。 通过 key 从 hunterMap 获取相应 BitmapHunter 并判断其是否为 null，如果不为 null，则调用其方法 attach(Action) 并结束退出程序；否则继续执行。简要说明下，BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务。 检查线程池是否停止工作。 创建 BitmapHunter 实例，即调用方法 forRequest(action.getPicasso(), this, cache, stats, action) 将 hunter 提交到线程池并执行，即调用 service.submit(hunter) 看下 forRequest() 方法具体实现： 12345678910111213141516static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) &#123; Request request = action.getRequest(); List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers(); // Index-based loop to avoid allocating an iterator. //noinspection ForLoopReplaceableByForEach for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);&#125; 通过调用 RequestHandler 中 canHandleRequest(Request) 方法逐一检查对应 RequestHandler，并创建 BitmapHunter 对象返回。然后将 hunter 提交到线程池并执行。submit(Runnable) 是接口 ExecutorService 里的方法，PicassoExecutorService 实现接口 ExecutorService，因此 submit(Runnable) 方法的实现逻辑在 PicassoExecutorService 类里面，具体实现如下： 123456@Override public Future&lt;?&gt; submit(Runnable task) &#123; PicassoFutureTask ftask = new PicassoFutureTask((BitmapHunter) task); execute(ftask); return ftask;&#125; execute(ftask) 执行任务，由于 BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务；而在该方法里会调用线程 start() 方法，意味着 BtimapHunter 中 run() 会被调用，真正执行任务逻辑在该方法里面实现，接下来的重点肯定是来研究该方法内部实现逻辑，在研究源代码之前，先来看该方法内部实现流程图： 同样结合流程图来解析 run() 内部实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; try &#123; updateThreadName(data); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this)); &#125; result = hunt(); if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125;&#125; 简要概括下该方法实现的主要功能： 更新线程名字。 返回 Bitmap 对象并赋值给 result。 判断返回结果 result 是否为 null，如果为 null，则调用 dispatcher.dispatchFailed(this)；否则调用 dispatcher.dispatchComplete(this) 各种异常处理。 从源代码可以看出，核心的逻辑在方法 hunt()，那么它的内部实现又是怎么呢？具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\"); &#125; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\"); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap;&#125; 代码实现确实很复杂，没事，先概括下其实现的主要小功能，再逐一解析： 根据缓存策略判断是否从内存缓存读取 bitmap，true 表示直接读取并返回 bitmap；否则继续执行。 根据不同请求资源调用相应 RequestHandler 中 load() 方法下载图片，这里以网络请求资源为例子来讲解，即 NetworkRequestHandler。 从下载返回结果 RequestHandler.Result 获取 bitmap，判断是否为 null 做出相应的处理。 重点来 NetworkRequestHandler 类 load() 方法具体实现： 1234567891011121314151617181920212223242526272829@Overridepublic Result load(Request request, int networkPolicy) throws IOException &#123; Response response = downloader.load(request.uri, request.networkPolicy); if (response == null) &#123; return null; &#125; Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; return new Result(bitmap, loadedFrom); &#125; InputStream is = response.getInputStream(); if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven't found // root cause to this but retrying the request seems safe to do so. if (loadedFrom == DISK &amp;&amp; response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new ContentLengthException(\"Received response with 0 content-length header.\"); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; return new Result(is, loadedFrom); &#125; 第 3 行代码实现图片下载，即客户端发送网络请求，服务端对客户端的请求作出响应，客户端根据服务端返回的结果作出处理。那么是如何实现下载的呢？downloader 是 Downloader 实例，而 Downloader 是接口，无法实例化，需要在子类实例化，而该接口有两个实现类：OkHttpDownloader 和 UrlConnectionDownloader。至于调用哪个类 load() 方法，取决于当前 sdk 最低版本是否在 API 14及以上。这里以 OkHttpDownloader 类 load() 方法为例来讲解是如何实现下载的，代码如下： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Response load(Uri uri, int networkPolicy) throws IOException &#123; CacheControl cacheControl = null; if (networkPolicy != 0) &#123; if (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; cacheControl = CacheControl.FORCE_CACHE; &#125; else &#123; CacheControl.Builder builder = new CacheControl.Builder(); if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; builder.noCache(); &#125; if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; builder.noStore(); &#125; cacheControl = builder.build(); &#125; &#125; Request.Builder builder = new Request.Builder().url(uri.toString()); if (cacheControl != null) &#123; builder.cacheControl(cacheControl); &#125; com.squareup.okhttp.Response response = client.newCall(builder.build()).execute(); int responseCode = response.code(); if (responseCode &gt;= 300) &#123; response.body().close(); throw new ResponseException(responseCode + \" \" + response.message(), networkPolicy, responseCode); &#125; boolean fromCache = response.cacheResponse() != null; ResponseBody responseBody = response.body(); return new Response(responseBody.byteStream(), fromCache, responseBody.contentLength()); &#125; 第 3 - 17 行代码主要是设置缓存策略；第 24 行通过调用 OkHttp 库 API 实现图片下载任务，并返回响应结果 com.squareup.okhttp.Response；最后对响应结果作出相应处理并创建 Response 对象返回。 再回到 NetworkRequestHandler 类 load() 方法，从返回 Response 对象调用 getBitmap() 方法获取 Bitmap 对象并判断其是否为 null，如果不为 null，则将 bitmap 和 loadedfrom 传入 Result 构造器方法中，创建 Result 对象并返回；否则调用 getInputStream() 方法获取输入流，不为 null 的话则创建 Result 对象并返回。 回到 hunt() 方法，从返回结果 result 获取数据类型为 Bitmap 对象 bitmap，并判断其是否为 null 作出不同的处理。如果 bitmap 不为 null，则判断原先发送加载图片请求 Request 是否需要对图片进行转换处理，即裁剪、缩放、重置大小等；不需要的话直接返回 bitmap；需要的话做转换处理后再返回 bitmap；如果 bitmap 为 null，则从 result 获取输入流 InputStream，并对 is 进行解析转换成 Bitmap 类型，将获取到的结果返回。 hunt() 方法解析完了，回到 run() 方法。根据调用方法 hunt() 返回结果 result，类型为 Bitmap，判断其是否为 null 并作出相应的处理。那么就来看下不为 null 的情况下又做了什么操作，即第 14 行代码，具体实现如下： 123void dispatchComplete(BitmapHunter hunter) &#123; handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));&#125; 很明显，又采用 Handler 消息机制处理，即 Dispatcher 类中 DispatcherHandler 发送消息 HUNTER_COMPLETE，其回调方法 handleMessage(final Message msg) 收到消息后并处理。说明一下，DispatcherHandler 所在的线程为子线程，即 DispatcherThread。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 在其回调方法中，核心代码是第 6 行，具体实现如下： 12345678910void performComplete(BitmapHunter hunter) &#123; if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; hunterMap.remove(hunter.getKey()); batch(hunter); if (hunter.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), \"for completion\"); &#125;&#125; 根据发送请求设置的内存缓存策略判断是否将其结果写入到内存中，并通过 key 从 hunterMap 移除 hunter，最后再对 hunter 作出处理，即 第 6 行代码，具体实现如下： 123456789private void batch(BitmapHunter hunter) &#123; if (hunter.isCancelled()) &#123; return; &#125; batch.add(hunter); if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123; handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY); &#125; &#125; 看第 7 行代码，同时采用 Handler 消息机制发送消息，跟上面一样。最终会转到 Dispatcher 类 performBatchComplete() 方法，具体实现如下： 123456void performBatchComplete() &#123; List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);&#125; 核心代码是第 4 行，同样才 Handler 消息机制发送消息，但是此时与之上有所不一样，即 mainThreadHandler 所在线程是主线程，也就是说，此时将任务从子线程切换到主线程，以便可以进行 UI 更新操作，那么赶快来看下在主线程是如何实现的？代码如下： 12345678910111213141516@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_BATCH_COMPLETE: @SuppressWarnings(\"unchecked\") List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = batch.size(); i &lt; n; i++) &#123; BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); &#125; break; default: throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125;&#125; 根据获取到 BitmapHunter 列表大小依次调用 Picasso 中 complete(BitmapHunter) 方法，那么又是怎样实现的呢，代码如下： 1234567891011121314151617181920212223242526272829303132void complete(BitmapHunter hunter) &#123; Action single = hunter.getAction(); List&lt;Action&gt; joined = hunter.getActions(); boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty(); boolean shouldDeliver = single != null || hasMultiple; if (!shouldDeliver) &#123; return; &#125; Uri uri = hunter.getData().uri; Exception exception = hunter.getException(); Bitmap result = hunter.getResult(); LoadedFrom from = hunter.getLoadedFrom(); if (single != null) &#123; deliverAction(result, from, single); &#125; if (hasMultiple) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = joined.size(); i &lt; n; i++) &#123; Action join = joined.get(i); deliverAction(result, from, join); &#125; &#125; if (listener != null &amp;&amp; exception != null) &#123; listener.onImageLoadFailed(this, uri, exception); &#125;&#125; 从 hunter 获取单个 action、合并 actions 以及其它信息，比如 uri、exception 等。如果获取到的 action 不为空，则派发 action，即第 18 行代码，具体实现如下： 12345678910111213141516171819202122private void deliverAction(Bitmap result, LoadedFrom from, Action action) &#123; if (action.isCancelled()) &#123; return; &#125; if (!action.willReplay()) &#123; targetToAction.remove(action.getTarget()); &#125; if (result != null) &#123; if (from == null) &#123; throw new AssertionError(\"LoadedFrom cannot be null.\"); &#125; action.complete(result, from); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), \"from \" + from); &#125; &#125; else &#123; action.error(); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_ERRORED, action.request.logId()); &#125; &#125;&#125; 从以上代码可以清晰地看出，根据 result 是否为空分别调用 Action 的回调方法，即 complete() 与 error()。先来看下 complete() 具体实现： 1234567891011121314151617181920@Overridepublic void complete(Bitmap result, Picasso.LoadedFrom from) &#123; if (result == null) &#123; throw new AssertionError( String.format(\"Attempted to complete action with no result!\\n%s\", this)); &#125; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; Context context = picasso.context; boolean indicatorsEnabled = picasso.indicatorsEnabled; PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled); if (callback != null) &#123; callback.onSuccess(); &#125;&#125; 逻辑很简单，前部分主要是做一些检查操作，真正核心代码是第 15 行代码，即将下载获取到的图片渲染到 UI 上，意味着成功地加载一张图片。那么 error() 方法又做了什么操作呢？具体实现如下： 123456789101112131415public void error() &#123; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; if (errorResId != 0) &#123; target.setImageResource(errorResId); &#125; else if (errorDrawable != null) &#123; target.setImageDrawable(errorDrawable); &#125; if (callback != null) &#123; callback.onError(); &#125;&#125; 逻辑也很简单，如果我们有设置错误时显示图片的话，该方法就将错误时显示图片渲染出来。 那么这是单个 action 的处理逻辑，如果有合并 actions 的，执行的逻辑也一样，即对其进行遍历，获取单个 action，再派发 action，实现的代码在 complete(BitmapHunter) 方法第 21 - 27 行。 好吧， 使用 Picasso 开源框架成功加载一张图片的具体流程大概就这样了。由于自己能力水平有限，在讲解过程中难免有错误，如果您看到了，欢迎指正出来，大家一起学习，共同进步 ！！！ 参考资料http://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"优秀开源框架","slug":"优秀开源框架","permalink":"https://panzeyong.github.io/tags/优秀开源框架/"}]},{"title":"JobScheduler 用法","slug":"JobScheduler-用法","date":"2017-05-21T04:28:37.000Z","updated":"2017-06-19T14:49:53.000Z","comments":true,"path":"2017/05/21/JobScheduler-用法/","link":"","permalink":"https://panzeyong.github.io/2017/05/21/JobScheduler-用法/","excerpt":"","text":"背景先来聊聊怎么会知道 JobSchduler 这神奇的东西。公司项目有这么一个需求：平板上实时记录小朋友的学习情况，然后生成学习报告上传到服务器，供手机端查看。原先的做法是开启服务，在服务里注册广播接收器，当广播接收器接收到 action，就会将数据上传，在网络正常的情况下，该做法是没有问题的；但是当网络很差的情况下，有可能造成上传失败，数据丢失。后来我采用一种方式：当上传失败时，开启定时器上传，直到成功为止。原本以为这样就解决问题，可是后来做后台的同事说由于设置时间短，访问量多，造成服务器流量过大，希望我能找另外一种解决方法。这时 Leader 跟我说采用 JobScheduler，它完全有系统控制，满足一定的条件时触发任务。于是我马上 Google，看看这玩意到底是啥？经过搜索一番，发现 JobScheduler 功能挺强大的。下面是自己学习 JobSchduler 小结。 JobScheduler 是在 Android 5.0 Google 推出的一个新组件，它的出现主要是为了解决某些任务需要在满足一个或多个条件的情况下才触发的需求，这些条件比如网络状态、电池充电、数据变化、自己设定的条件等，在满足条件时会触发相应的 JobScheduler 完成相应的任务。这个过程只需我们对要执行的任务设定条件，其它都由系统控制完成的，无需我们去控制任务。在学习 JobScheduler 的用法之前，先来了解相关的 API，这里涉及到 JobScheduler、JobInfo、JobParameters、JobService 这四个类。 API 讲解JobScheduler先来看下官方文档对 JobScheduler 的描述： 根据应用程序自己的进程中调度各种类型的任务。 关于可以运行的任务类型以及如何构建它们的更多描述，请参阅 JobInfo。你将构建这些 JobInfo 对象,并调用 JobScheduler 方法 schdule(JonInfo)) 将这些 JobInfo 对象传给它。当设定的条件满足时，系统将会在你应用程序 JobService 上执行相应的任务。当你使用 JobInfo.Builder(int, android.content.ComponentName)) 创建你的 JobInfo 时，意味着已经确定哪个 JobService 将执行你的任务逻辑。 框架对于你接收回调的时机很智能的，并且尝试尽可能地分批处理和延迟它们。通常来说，如果你没有为你的任务设置最后期限，那么就会根据 JobScheduler 内部队列当前的状态在任何时刻来执行它们；可是只要到下一次设备连接电源，那么任务就有可能被延迟。 你不能直接实例化 JobScheduler，而是需要通过 Context.getSystemService(Context.JOB_SCHEDULER_SERVICE)) 获取实例。 从官方文档可以知道，JobScheduler 的职责是调度任务、取消任务。JobScheduler 提供 2 个常量和 5 个方法，在了解它们之前，先来了解如何获取 JobScheduler 实例。正如官方文档所介绍的，通过获取系统服务来获取的，代码如下： 1JobScheduler jobScheduler = (JobScheduler) Context.getSystemService(Context.JOB_SCHEDULER_SERVICE); 接下来来了解两个常量的具体含义 RESULT_FAILURE：调度任务失败时返回值。 RESULT_SUCCESS：调度任务成功时返回值。 JobScheduler 提供 5 个方法供我们使用，让我们来了解下这 5 个方法的具体用法 cancel(int jobId)：取消 JobScheduler 内部队列 id 为 jobId 待处理任务。 cancelAll()：取消在这个应用程序上 JobScheduler 已经注册的所有任务。 getAllPendingJobs()：检索 JobScheduler 待处理所有任务。 getPendingJob(int jobId)：检索 JobScheduler 内部队列 id 为 jobId 待处理任务。 schedule(JobInfo job)：调度任务。 JobInfoJobInfo 对一个即将被执行的任务的信息进行封装，然后供 JobScheduler 调度。由于 JobInfo 包含的信息比较多，所有采用建造者模式来构建其实例，即 JobInfo.Builder 来创建。 来看下官方文档的描述： 将要调度的任务所需的参数（信息）封装为 JobInfo 对象传递给 JobScheduler。使用 JobInfo.Builder) 创建 JobInfo 实例。当你正在创建 JobInfo 对象时，你必须至少指定一项约束条件。这样做的目标是为你想完成的任务提供优先级高调度。如果你没有指定任何一项约束时，你的 app 会抛出异常。 那么来看下如何创建 JobInfo 实例 123JobInfo.Builder builder = new JobInfo.Builder(jobId, componentName);builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);JobInfo jobInfo = builder.build(); 由于创建 JobInfo 对象时至少指定一项约束条件，所以以上只是指定请求网络类型，至于其它属性可以根据自己的需求指定。那么 JobInfo 到底有哪些属性呢？下面一一揭晓。 先来看下 JobInfo 提供常量： BACKOFF_POLICY_EXPONENTIAL：退避策略，任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：退避策略，任务失败时等待间隔呈线性增长。 DEFAULT_INITIAL_BACKOFF_MILLIS：默认情况下任务的 backoff，以毫秒为单位。 MAX_BACKOFF_DELAY_MILLIS：允许任务最大 backoff，以毫秒为单位。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NONE：默认值，没联网。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 JobInfo 设置属性的方法由 JobInfo.Builder，那么来看下提供哪些方法设置属性 setRequiredNetworkType (int networkType)：设置网络类型。如果任务需要通过网络访问服务器，但是没有调用该方法设置网络类型时，那么任务不会被执行。提供四个参数可以设置： NETWORK_TYPE_NONE：默认值，不连接网络。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 setRequiresCharging (boolean requiresCharging)：设置是否连接电源，默认值为 false。 setRequiresDeviceIdle (boolean requiresDeviceIdle)：设置是否需要设备处于空闲模式，默认值为 false。空闲模式是系统提供的一种松散模式，意味着设备没有在使用或者已经有一段时间没有使用，这正是执行繁重任务的好时机。 addTriggerContentUri (JobInfo.TriggerContentUri uri)：API 24 支持使用 content provider 变化作为触发任务执行的时机。需要指定触发 URL，并通过 ContentObserver 监听 content provider 变化，从而触发任务的执行。注意设置该属性后，不能设置 setPeriodic(long) 或者 setPersisted(boolean) 属性，也就是说不能与他们任何一个一起使用。因为他们之间是不兼容的，如果一起使用的话，当 build() 被调用时，会抛出 IllegalArgumentException 异常。为了持续监听 content 变化，需要在 JobService 完成最近变化执行的任务之前，调用新的 JobInfo 观察相同的 URL。 setTriggerContentMaxDelay (long durationMs)：设置当第一次监听到 content 变化到任务执行时可以延迟的最大时间，以毫秒为单位。 setTriggerContentUpdateDelay (long durationMs)：设置当监听到 content 变化时到任务执行时可以延迟的时间，如果在这期间监听到更多变化，那么延迟时间的计时将被重置到最近一次更改开始。 setBackoffCriteria (long initialBackoffMillis, int backoffPolicy)：设置 back-off 或者 重试策略。注意尝试调用 setRequiresDeviceIdle(boolean) 为任务设置回退策略时，当 build() 被调用时会抛出异常。因为 back-off 对这些工作类型没意义。 第一个参数表示第一次失败时尝试的时间间隔，单位为毫秒，预设的参数有： DEFAULT_INITIAL_BACKOFF_MILLIS：30000 MAX_BACKOFF_DELAY_MILLIS：18000000 第二个参数表示退避策略 BACKOFF_POLICY_EXPONENTIAL：任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：任务失败时等待间隔呈线性增长。 setMinimumLatency (long minLatencyMillis)：指定任务延迟执行时间。 setOverrideDeadline (long maxExecutionDelayMillis)：设置任务执行最大的延迟时间。即使到了时间期限，条件还没满足，任务也会被执行。 setPeriodic (long intervalMillis)：指定任务在一定的周期内执行，并且每一个任务在周期内只执行一次。调用该方法设置后，不能再调用 setMinimumLatency (long minLatencyMillis) 或者 setOverrideDeadline (long maxExecutionDelayMillis) 方法，否则会抛出异常。 setPersisted (boolean isPersisted)：设置当设备重启，任务是否被重新调度。如果设置 true，必须申请权限 RECEIVE_BOOT_COMPLETED，否则运行时会报错。 setExtras (PersistableBundle extras)：设置额外参数，值允许原始数据类型。 JobServiceJobScheduler 所要调度的任务是在 JobService 定义的，而 JobService 是继承 Service；也就是说，JobService 也是服务，只是它与四大组件之一 Service 有所区别。JobService 有一大特点是无论你的 app 是否处于活跃状态，当你的任务满足特定的条件时，系统都会执行任务。我们可以编写多个 JobServices，而且每个 JobService 指定不同的任务，每个任务在某个时间点被执行。 来看下官方文档的描述 JobScheduler 回调的入口点。 JobService 是处理之前调度的异步请求的基类。你应该重写 onStartJob (JobParameters params)) 方法，将在该方法实现你的任务逻辑。 此服务运行在应用程序主线程处理传入的任务。这意味着你必须将执行逻辑放到子线程、handler、AsyncTask。如果不这样做的话会阻塞 JobManager 的回调，特别是 onStopJob(android.app.job.JobParameters))，这意味着将通知你不满足调度要求。 那么该如何实现 JobService 呢？必须创建一个新类，继承 JobService，并重写方法 onStartJob(JobParameters) 和 onStopJob(android.app.job.JobParameters)。下面给出一个模板： 123456789101112public class JobSchedulerService extends JobService &#123; @Override public boolean onStartJob(JobParameters params) &#123; return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; return false; &#125;&#125; 从以上可知，两个方法都返回 boolean 值，那么什么时候返回 true，什么时候返回 false 呢，返回值对 JobScheduler 任务调度又有什么影响呢？下面一一来解析： onStartJob(JobParameters)：在此方法实现任务的逻辑。由于 JobService 是在主线程运行，因此对于逻辑简单的可以直接写在该方法里，但是对于比较复杂任务，例如网络请求，那么就要开启子线程来操作，以免造成阻塞。当任务完成的时候返回 false，作用是通知系统任务已经完成；当有任务要执行的话返回 true，作用是让系统知道有任务即将执行或正在执行，并对该任务持有锁。因为任务一旦完成并通知系统，系统就释放持有该任务锁。 onStopJob (JobParameters params)：当任务未完成调用 jobFinished(JobParameters, boolean)) 取消任务时，此方法就会被调用。发生这种现象的原因大部分是调度的任务不满足所指定的条件，导致系统无法执行任务。当任务停止时，如果还想系统重新调度任务的话，那么返回 true；反之返回 false，此时系统会移除任务，导致所要调度的任务必须暂停。 除此之外，JobService 还提供了 jobFinished(JobParameters, boolean)) 这个方法，虽然不用重写该方法，但是该方法却有很大的作用。此回调方法用来通知 JobManager 任务已经完成。由于此方法最终在主线程调用，因此可以在任何线程调用该方法。当系统收到信息时，就会释放持有该任务锁。当 onStartJob(JobParameters) 返回 true，即表示任务正在执行或要被执行，在任务执行完成后需要调用 jobFinished(JobParameters, boolean) 方法来通知系统任务已经完成，此时系统才可以安全地释放持有该任务锁。如果忘记调用该方法的话，应用中其它任务就不会被执行。 jobFinished(JobParameters, boolean) 需要传入两个参数：第一个参数 JobParameters 表示当前任务的信息，以至于任务完成时系统知道释放哪个锁；第二个参数是 boolean 值，true 表示根据退避策略（back-off criteria）重新调度任务；false 则表示不调度任务。 跟四大组件之一 service 一样，都需要在 AndroidManifest.xml 声明，但是有一点不同的是需要添加权限 android:permission=”android.permission.BIND_JOB_SERVICE” 123&lt;service android:permission=\"android.permission.BIND_JOB_SERVICE\" android:name=\".service.JobSchedulerService\" &gt; JobParameters来看下官方文档描述 JobParameters 对任务的信息进行封装，当任务被调度时，系统就会创建该对象，包含任务的信息；自己是无法实例化该对象的。 PS：自己觉得是与 JobInfo 对应的，JobInfo 是设置属性，而 JobParameters 是获取相应属性。 那么来看下 JobParameters 提供的方法，只列出部分： getJobId ()：获取每个任务独一无二的 id。 getExtras ()：获取额外参数。 了解 API 之后，接下来的任务是学习 JobScheduler 用法。 JobScheduler 用法对于 JobScheduler 的用法，我打算用项目中使用到 JobScheduler 作为例子，前提是移除了业务逻辑，代码可能不太完整。换句话说吧，给个模板吧。 先给出例子，再来分步讲解吧。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class JobSchedulerService extends JobService &#123; private static final String TAG = JobSchedulerService.class.getCanonicalName(); public final static String TASK = \"com.demo.panju.task\"; private final static int JOB_ID = 1; private static ComponentName mComponentName; private static JobScheduler mJobScheduler; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case 1； task(); break; default: break; &#125; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mReceiver = new Receiver(); mFilter = new IntentFilter(); mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); registerReceiver(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; sendMessage(params); return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; mHandler.removeMessages(1)); return false; &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); stopSelf(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (null != mReceiver) &#123; unregisterReceiver(mReceiver); mReceiver = null; &#125; &#125; private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; private void sendMessage(JobParameters parameters) &#123; Message message = mHandler.obtainMessage(); message.what = 1; message.obj = parameters; mHandler.sendMessage(message); &#125; private void registerReceiver() &#123; mFilter.addAction(TASK); registerReceiver(mReceiver, mFilter); &#125; private void task() &#123; mApi.task(new Callback() &#123;&#125; @Override public void onSuccess(Object result) &#123; jobFinished(mJobParameters, false); &#125; @Override public void onError(Object e, int errno) &#123; jobFinished(mJobParameters, true); &#125; &#125;); &#125; private class Receiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (TASK.equals(action)) &#123; scheduleJob(JOB_ID); &#125; &#125; &#125; &#125; 以上例子应该不难理解，接下来分步讲解： 创建新类 JobSchedulerService 并继承 Service，重写方法 onStartJob(JobParameters params) 和 onStopJob(JobParameters params)。onStartJob(JobParameters params) 返回 true 表示任务将被执行；onStopJob(JobParameters params) 返回 false 表示当任务中途被取消而导致暂停任务，系统将会移除任务。 创建 JobScheduler 和 ComponentName 对象 12mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); 对调度任务所需要的属性进行封装 1234567private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; 编写广播接收器、注册接收器、重写 Handler 回调方法 handleMessage(Message msg) 并实现相应逻辑。 当注册的广播接收器收到相应 action 时，就会调用方法 scheduleJob(JOB_ID)，即调度任务，那么方法 onStartJob(JobParameters params) 就会被调用，在该方法里通过 Handler 机制发送消息，Handler 的回调方法 handleMessage(Message msg) 就会被调用，实现的逻辑主要是发起网络请求，即 task() 方法。task() 方法逻辑中有两个回调方法：onSuccess(Object result) 和 onError(Object e, int errno)。发起网络请求成功的话就会调用方法 onSuccess(Object result)，在该方法里又调用 jobFinished(mJobParameters, false)，传入的 boolean 值是 false，意味着任务已经成功完成，无需重新调度任务；发起网络请求失败的话就会调用 onError(Object e, int errno)，在该方法里又会调用 jobFinished(mJobParameters, true)，传入的 boolean 值是 true，意味着任务失败，根据重试策略重新调度任务。 由于自己的水平有限，若有些地方描述的不对或者翻译的不恰当（参考官方文档和国外博客），欢迎指出 ！ 大家一起学习，共同进步 ！ 参考链接官方文档 https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129 http://josiassena.com/the-jobscheduler-on-android/ http://blog.csdn.net/bboyfeiyu/article/details/44809395 http://zhanghuimin.com/2016/10/27/about-android-job-scheduler/ http://mahong978.top/2016/08/19/android-job-scheduler/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://panzeyong.github.io/tags/性能优化/"}]},{"title":"第二章 在 HTML 中使用 JavaScript","slug":"第二章-在-HTML-中使用-JavaScript","date":"2017-05-03T23:40:59.000Z","updated":"2017-06-19T15:25:28.000Z","comments":true,"path":"2017/05/04/第二章-在-HTML-中使用-JavaScript/","link":"","permalink":"https://panzeyong.github.io/2017/05/04/第二章-在-HTML-中使用-JavaScript/","excerpt":"","text":"标签script：表示向 HTML 页面插入 JavaScript。该元素定义 6 个属性： async：可选。表示应该立即下载脚本，但不应妨碍页面中的其它内容加载。只对外部脚本文件有效。标记为 async 的脚本并不能保证按照指定的的先后顺序执行，一定会在页面的 load 事件前执行，但是对于 DOMContentLoaded 事件就不一定了。建议异步脚本不要在加载期间修改 DOM。 charset：可选。表示通过 src 属性指定的代码的字符集。 defer：可选。表示所要加载的脚本可以延迟到文档完全被解析和显示之后再执行，即遇到 html 标签之后才执行；只对外部脚本文件有效。HTML 5 规范要求延迟脚本是按照出现的顺序执行的，并且先于 DOMContentLoaded 事件，但是现实是不一定的，因此最好只包含一个延迟脚本。 language：已经废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME 类型）。通常的默认值为 text/javascript。 noscript：在不支持 JavaScript 的浏览器中显示替代的内容。 123&lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript&lt;/p&gt;&lt;/noscript&gt; 注意点 解释器对 script 元素内代码的解析是从上往下，在该元素内的代码被解析完之前，页面其它内容是不会被浏览器加载或者显示的。（外部文件也一样） 通过 src 属性引入外部文件必须要包含开始的 script 和结束的 script，只是 HTML 规范。 1&lt;script type=\"text/javasript\" src=\"example.js\"&gt;&lt;/script&gt; 带有 src 属性的 script 元素不应该在其元素之间包含额外的 JavaScritp 代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 JavaScript 代码建议放在 body 元素中页面内容之后 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第二章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 高级程序设计》学习笔记","slug":"JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/JavaScript-高级程序设计》学习笔记/"}]},{"title":"AsnycTask 用法及源码解析","slug":"AsnycTask-用法及源码解析","date":"2017-05-01T09:49:39.000Z","updated":"2017-06-19T14:44:13.000Z","comments":true,"path":"2017/05/01/AsnycTask-用法及源码解析/","link":"","permalink":"https://panzeyong.github.io/2017/05/01/AsnycTask-用法及源码解析/","excerpt":"","text":"AsyncTask 是一种轻量级异步任务类，可以在线程池执行后台任务，获取到的结果传递给主线程并且在主线程中更新 UI。AsyncTask 比较适合执行短时间任务，对于长时间任务推荐使用 Executor，ThreadPoolExecutor 和 FutureTask。 AsyncTask 是一个抽象类，提供三个泛型参数，分别是 Params，Progress 和 Result；以及 4 个步骤：onPreExecute，doInBackground，onProgressUpdate 和 onPostExecute。 AsyncTask 三个泛型参数 Params：发送给执行任务的参数类型。 Progress：执行后台任务进度的类型。 Result：执行完后台任务返回的结果类型。 AsyncTask 四个核心方法 onPreExecute()：在任务执行之前调用，主线程执行；主要做一些初始化工作，比如在用户界面展示进度条。 doInBackground(Params…)：onPreExecute() 执行完成后被调用，在线程池执行；所有的异步操作都在这个方法执行，执行结果被返回时，onPostExecute(Result) 会被调用。如果在该方法中调用 publishProgress(Progress…)，那么方法 onProgressUpdate(Progress…) 也会被调用，主要用于更新后台任务进度。 onProgressUpdate(Progress…)：publishProgress(Progress…) 执行完之后被调用，在主线程执行；主要在用户界面显示后台任务执行进度。 onPostExecute(Result)：doInBackground(Params…) 执行完之后调用，在主线程执行；参数 Result 是 doInBackground(Params…) 的返回值。 一个异步任务可以通过调用 cancel(boolean) 随时取消，此时 isCancelled() 被调用，这就导致 doInBackground(Params…) 执行完后 onPostExecute(Result) 不会被调用。 在使用 AsyncTask 的过程中，要注意以下几点： AsyncTask 类必须在 UI 线程加载，Android 4.1 已经自动绑定了。 AsyncTask 实例必须在 UI 线程创建。 execute(Params…) 必须在 UI 线程调用。 不要手动调用 onPreExecute()、onPostExecute(Result)、doInBackground(Params…)、onProgressUpdate(Progress…)。 一个 AsyncTask 对象只能被执行一次；否则会抛异常。 以上是 AsnycTask 基本知识点，掌握知识点后就要学会如何使用它。那么接下来就来学习 AsyncTask 用法。 AsyncTask 用法AsyncTask 是抽象类，不能直接实例化，必须创建新类并继承它，抽象方法 doInBackground(Params…) 是一定要重写的，其它三个方法根据自己的需求确定。以下通过 URL 获取数据为例子来讲解 AsyncTask 的用法。代码如下： 12345678910111213141516171819public class AsyncTaskExample extends AsyncTask&lt;String, Integer, String&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); mLoad.setVisibility(View.VISIBLE); &#125; @Override protected String doInBackground(String... params) &#123; return getUrlResponse(params[0]); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); mLoad.setVisibility(View.GONE); mText.setText(s); &#125;&#125; 从代码中可以很清晰地看出，第 5 行是显示加载进度条，表示正在获取数据；第 10 行是核心代码，异步操作，网络请求数据并将结果返回；第 16 - 17 行代码主要操作是隐藏进度条，表示数据加载完毕，并将获取到的结果显示出来。这里主要给出核心代码，至于其它代码也就调用而已。 那么该如何调用呢？很简单，一行代码就搞定 1new AsyncTaskExample().execute(url); AsyncTask 源码解析知其然必知其所以然。对于新知识点，学会使用之后，就应该探究其原理。由于个人倾向于通过画图来理解知识点的流程，因此先简单地给出 AsyncTask 任务执行的流程图，再根据流程图和源码进行讲解。流程图如下： 对于源码的理解，一般是以最终调用的方法为入口，一步一步地理解整个流程。那么对于 AsyncTask 该从哪里入手呢？当然是从方法 execute(Params… params) 入手了，代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 对于 AsyncTask 不同版本，execute(Params… params) 方法的执行方式是不一样的。Android 1.6 以前，AsyncTask 是单线程串行执行任务的；Android 1.6，AsyncTask 是线程池多线程并行执行任务；但是到 Android 3.0，AsyncTask 又改为单线程串行执行任务的。该方法的逻辑很简单，直接调用方法 executeOnExecutor(Executor exec, Params… params)，将我们传入的参数 params 和 sDefaultExecutor 传到该方法里，并将的返回值返回。那么来看下该方法的具体实现，代码如下： 12345678910111213141516public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; executeOnExecutor(Executor exec, Params… params) 方法是在线程池 THREAD_POOL_EXECUTOR 执行，允许多任务并发执行，但是不推荐采用多任务并发执行；在主线程执行。该方法实现的主要功能是： 检查任务状态，并记录任务当前状态； 调用 onPreExecute() 方法，根据我们自己的需求可以重写该方法； 将我们传入的参数 params 赋值给 WorkRunnable 中字段 mParams(稍后解释)； 调用 SerialExecutor 中方法 execute(Runnable r) 执行任务。 mWorker 是 WorkerRunnable 实例，而 WorkerRunnable 是抽象类，实现 Callable 接口，并且该接口有一个回调方法 call()；同时抽象类有一个字段 Params []，第 13 行代码就是把我们传进来的参数 params 赋值给它的。mWorker 是在创建 AsyncTask 实例时被初始化的，即 AsyncTask 构造方法里，并重写回调方法 call()，那么接下来看回调方法 call() 的具体实现。 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 该回调方法实现的主要功能： 将 mTaskInvoked 设置为 true，表示任务已经被调用过； 设置线程优先级为后台线程； 调用 doInBackground(mParams) 方法，异步执行，后台执行的逻辑都写在这个方法里面，一定要被重写；如果任务执行抛出异常时，取消任务； 调用 postResult(result) 方法； postResult(result) 的具体实现如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 从代码里可以看出，将执行结果通过 sHandler 发送 MESSAGE_POST_RESULT 的消息，然后 handleMessage() 方法收到消息后进行相应的处理。sHandler 是 InternalHandler 实例，主要作用是将任务执行的环境从线程切换到主线程中，从 InternalHandler 的具体实现就可以看出了。代码如下： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 从构造函数 InternalHandler() 就可以看出了，获取主线程 Looper，而 Handler 必须与 Looper 进行绑定，因此可以断定是在主线程里。handleMessage() 函数对两种消息进行处理：MESSAGE_POST_RESULT 和 MESSAGE_POST_PROGRESS；而我们刚刚发送的消息是 MESSAGE_POST_RESULT，那就先来看该消息收到后会做什么处理吧？很显然，调用 finish(Result result)，具体实现如下： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 如果任务被取消了，直接调用 onCancelled(result) 方法，onPostExecute(result) 方法不会被调用；否则就调用 onPostExecute(result) 方法，该方法需要被重写，在主线程执行，根据返回的结果进行相应的处理；最后修改任务的状态。那么对于消息 MESSAGE_POST_PROGRESS 是从哪里发出来的呢？还记得在前面的知识点讲解中有提到过如果在 doInBackground(mParams) 方法中调用 publishProgress(Progress…) 方法时，方法 onProgressUpdate(Progress…) 也会被调用，用于后台任务进度更新。没错，消息 MESSAGE_POST_PROGRESS 就是用来处理进度更新的。先看下 publishProgress(Progress…) 具体实现： 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 很显然，如果任务没有被取消的话，就会发送消息 MESSAGE_POST_PROGRESS，那么来看下收到该消息后的处理逻辑，即调用 onProgressUpdate(Progress… values) 方法，该方法需要我们根据自己的需求进行重写。 再回到 executeOnExecutor(Executor exec, Params… params) 方法，第 14 行代码开始执行任务，在理解如何执行任务之前，先来理解参数 mFuture 和 sDefaultExecutor 的含义。 mFuture 是 FutureTask 实例，在 AsyncTask 构造方法中初始化。将 mWorker 作为参数传入 FutureTask 构造函数，个人认为传入该参数的作用是由于 FutureTask 中 run() 方法会被调用，而在该方法里会通过传入参数 mWorker 调用 call() 方法，进而使任务得到执行。FutureTask 是一个并发执行任务类，可以执行任务、取消任务、查询结果、获取结果；提交到线程池执行。实现的接口有 Future、Runnable。 对于传入的参数 sDefaultExecutor，究竟是什么啥玩意呢？让我们来探个究竟吧。sDefaultExecutor 是 SerialExecutor 的实例，而 SerialExecutor 实际上是一个串行的线程池，主要的功能是一个进程中所有的 AsyncTask 任务都在这个串行的线程池中排队执行。看到这里，是不是还不知道任务真正在哪里被开始执行？其实以上都只是铺垫，下面才真正拉开序幕。真正开始执行任务的逻辑是在 SerialExecutor 中 execute(Runnable r) 方法里，具体实现如下： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 首先将 AsyncTask 通过线程池 SerialExecutor 添加到队列里（从这里可以看出 SerialExecutor 的作用），然后重写 run() 方法，并判断 mActive 是否为 null，即当前是否有任务在执行，如果有任务执行的话就等待该任务执行完后再执行其他任务，否则就执行任务，即调用 scheduleNext() 方法，该方法的主要功能是从队列 mTasks 获取任务，任务不为空的话就直接提交到线程池 THREAD_POOL_EXECUTOR 里执行（任务真正开始执行），即启动任务，根据个人的理解，任务被启动后，会调用第 6 行代码，即 run() 方法，进而调用 FutureTask 中 run() 方法，从而会调用 WorkerRunnable 中 call() 方法，因此任务被执行，我们重写的方法也会被调用。结合以上流程图应该能更清晰地理解 AsyncTask 执行流程。 以上是自己在学习 《Android 开发艺术探索》 这本书第十一章关于 AsyncTask 这个主题的学习笔记，由于自己能力有限，有错误的地方欢迎指出。 参考资料https://developer.android.com/reference/android/os/AsyncTask.html 《Android 开发艺术探索》》中 第 11 章 Android 的线程和线程池","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/tags/《Android-开发艺术探索》学习笔记/"}]},{"title":"Python 学习笔记：字符串","slug":"Python-学习笔记：字符串","date":"2017-04-17T14:27:28.000Z","updated":"2017-06-19T15:22:47.000Z","comments":true,"path":"2017/04/17/Python-学习笔记：字符串/","link":"","permalink":"https://panzeyong.github.io/2017/04/17/Python-学习笔记：字符串/","excerpt":"","text":"定义：Python 的字符串是一种对象类型，这种类型用 str 表示，通常用双引号 “” 或者单引号 ‘’ 表示。 拼接字符串Python 的字符串是可以拼接，用符号 + 表示；但是与 Java 语言有一点不同的是拼接的两个对象必须是同类型，否则会报错。例子如下： 两个相同类型 str 拼接（正确） 12&gt;&gt;&gt; \"Hello \" + \"Python\"'Hello Python' 两个相同类型 int 拼接（正确） 12&gt;&gt;&gt; 5 + 38 两个不同类型 str 和 int 拼接（错误） 1234&gt;&gt;&gt; \"Python \" + 5Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 很显然，对于类型都是 str 将多个对象拼接起来；对于类型都是 int 则执行相加操作；对于不同类型则报错。那么对于不同类型的操作该如何转换呢？解决办法如下： str() 函数 12&gt;&gt;&gt; \"Python \" + str(3)'Python 3' repr() 函数（反引号的替代品） 12&gt;&gt;&gt; \"Python \" + repr(3)'Python 3' str() 与 repr() 区别 str() 将对象转化为可读性好的字符串，适合于 print 输出到终端，其返回值无法用于内建函数 eval。 repr() 返回对象的规范字符串表示形式；对于大多数对象而言，eval（repr（obj））== obj，也就是说，大多数情况下可以通过内建函数 eval 重新获取该对象。 大部分情况下 str() 用于终端输出，eval() 主要用于调试。 字符串格式化输出用于指定输出参数的格式与相对位置的字符串参数。通俗地讲，先定制模板，预留占位符，用对应类型的值填充；常用的占位符有 %s（字符串）、%d（整数）、%f（浮点数）。 以下通过例子说明 12&gt;&gt;&gt; \"I love my %s\" % \"job\" 'I love my job' 在这个字符串中，%s 是一个占位符，可以被其它字符串替换，这里替换的是 “job”。 12&gt;&gt;&gt; \"I'm %d years old\" % 20\"I'm 20 years old\" 不同占位符也可以混合使用，例子如下： 12&gt;&gt;&gt; \"What's your name ? My name is %s and I'm %d years old.\" % (\"John\", 15)\"What's your name ? My name is John and I'm 15 years old.\" 字符串常用方法index(…)：子字符串在整个字符串中的索引，即子字符串中第一个字符的位置。 123&gt;&gt;&gt; string = \"The programming language Python\"&gt;&gt;&gt; string.index(\"Python\")25 isalnum(…)：字符串中所有字符都是字母数字时返回 True，否则 False。 12345678910111213141516&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"199993\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalnum()True# 包含空格，并非全是字母数字，所以返回 False&gt;&gt;&gt; string = \"Python 3\"&gt;&gt;&gt; string.isalnum()False isalpha(…)：字符串中所有字符都是字母时返回 True，否则 False。 12345678910111213&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalpha()True# 包含数字&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalpha()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.isalpha()False isdecimal(…)：字符串中只有十进制字符时返回 True，否则返回 False。 12345678910111213141516171819202122232425262728293031# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdecimal()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isdecimal()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isdecimal'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdecimal()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdecimal()False# 包含字母&gt;&gt;&gt; string = \"Python1993\"&gt;&gt;&gt; string.isdecimal()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"1993 1993\"&gt;&gt;&gt; string.isdecimal()False isdigit(…)：字符串中所有字符都是数字 True，否则返回 False。 1234567891011121314151617181920212223# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdigit()True# byte数字（单字节）&gt;&gt;&gt; string =b\"1\"&gt;&gt;&gt; string.isdigit()True# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isdigit()False isnumeric(…)：字符串中只有数字字符时返回 True，否则返回 False。 123456789101112131415161718192021# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isnumeric()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isnumeric()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isnumeric'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isnumeric()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isnumeric()True 提示：isdecimal()、isdigit()、isnumeric() 三个函数区别如上。 islower(…)：字符串中所有字符都是小写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"python\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.islower()False isupper(…)：字符串中所有字符都是大写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"PYTHON\"&gt;&gt;&gt; string.isupper()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isupper()False join(…)：将序列中的元素以指定的字符连接成生成新的字符串。 123456789&gt;&gt;&gt; string = \"-\" # 指定的字符&gt;&gt;&gt; seq = \"Hello,Python\" # 序列&gt;&gt;&gt; string.join(seq)'H-e-l-l-o-,-P-y-t-h-o-n'&gt;&gt;&gt; string = \"-\"&gt;&gt;&gt; seq = ['Python', 'PHP']&gt;&gt;&gt; string.join(seq)'Python-PHP' lower(…)：返回字符串的副本并将其转换为小写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.lower()'welcome to python world !' upper(…)：返回字符串的副本并将其转换为大写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.upper()'WELCOME TO PYTHON WORLD !' capitalize(…)：字符串中首字母大写，其它都是小写。 123&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.capitalize()'Hello python' istitle(…)：字符串中所有单词的首字母大写，其它小写时返回 True，否则返回 False。 123456789101112131415&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"hello python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"HELLO PYTHON\"&gt;&gt;&gt; string.istitle()False split(…）：根据分隔符对字符串进行分割，返回列表。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string.split()['I', 'love', 'Python', '!'] strip(…)：去掉字符串左右空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.strip()'I love Python !' lstrip(…)：去掉字符串左边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.lstrip()'I love Python ! ' rstrip(…)：去掉字符串右边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.rstrip()&gt;&gt;&gt; ' I love Python !' len(…)：返回序列（字符串）的长度。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; len(string)15 in：判断字符串是否包含某个字符或子字符串，包含的话返回 True；否则返回 False。（区分大小写） 1234567&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"python\" in stringFalse&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"Python\" in stringTrue max：根据 ASCII 编码，求出字符串中最大值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; max(string)'y' min：根据 ASCII 编码，求出字符串中最小值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; min(string)' ' 索引与切片与其它编程一样，在 Python 中的字符串也可以通过索引获取相应的字符，唯一的区别是获取的方式不一样。在 Python 中，字符串是一种序列，以一种数组的形式存在，可以通过下标获取。最直接的方式还是通过例子来说明吧。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[7]'P' 这种形式很类似 Java 语言中数组，但是 Java 语言中通过索引获取字符串中某个字符是通过调用 charAt(index) 方法获取到；获取子字符串是通过调用 subString(start, end) 方法，但是在 Python 获取子字符串称为切片，获取方式跟字符类似。例子如下： 1234# 得到从字符串索引为 2 到 7 的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:8]'love P' 1234得到从字符串索引为 2 到末尾的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:]'love Python !' 1234# 获取全部字符&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:]'I love Python !' 1234# 获取从第一个字符到 9 之前的字符串&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:9]'I love Py' 从以上例子可以看出字符串切片的使用用法，以下做下简单的总结： [a : b]：表示从索引为 a 起到索引 b 之前字符串。 [:a]：从第一个字符到索引 a 之前的所有字符串。 [a : ]：表示从索引为 a 到末尾字符串。 [:]：表示原始字符串，但不是复制一份，只是两个变量指向同一个对象。 以上只是最近在学 Python 中字符串的小结，也可以说是学习笔记，方便以后查找。（基于 Python3） 参考资料http://docs.pythontab.com/learnpython/106/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"https://panzeyong.github.io/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://panzeyong.github.io/tags/学习笔记/"}]},{"title":"第一章 Activity 的生命周期和启动模式","slug":"第一章-Activity-的生命周期和启动模式","date":"2017-03-26T08:41:15.000Z","updated":"2017-06-19T14:43:39.000Z","comments":true,"path":"2017/03/26/第一章-Activity-的生命周期和启动模式/","link":"","permalink":"https://panzeyong.github.io/2017/03/26/第一章-Activity-的生命周期和启动模式/","excerpt":"","text":"Activity 正常情况下生命周期 生命周期方法分析 onCreate()：Activity 创建时调用，可以做一些初始化工作。 onRestart()：Activity 正在重新启动，由不可见状态变为可见状态。 onStart()：Activity 正在被启动，这时已经处于可见状态，但是还没出现在前台，而是在后台，无法与用户交互。 onResume()：Activity 已经处于可见状态，并且出现在前台。 onPause()：Activity 暂停，位于后台，可以做一些存储数据、停止动画等工作，但是不能太耗时。 onStop()：Activity 停止，不可见状态，可以做一些资源回收工作，但不能太耗时。 onDestroy()：Activity 销毁，可以做一些回收工作和资源释放。 Activity 生命周期方法不同情况下调用 Activity 第一次启动：onCreate() —&gt; onStart() —&gt; onResume()。 打开新的 Activity 或者切换到桌面：onPause() —&gt; onStop()。 回到原来 Activity：onRestart() —&gt; onStart() —&gt; onResume()。 按 back 键：onPause() —&gt; onStop() —&gt; onDestroy()。 注意（提示、问题） onCreate() 与 onDestroy() 是配对的，表示 Activity 的创建和销毁,并且只有可能一次调用。 onStart() 与 onStop() 是配对的，从是否可见这个角度来回调。 onResume() 与 onPause() 是配对的，从是否位于前台这个角度来回调。 如果新 Activity 采用了透明主题，那么当前 Activity 不会回到 onStop()（原因：处于可见状态，但是失去焦点，无法与用户进行交互）。 假设当前 Activity A，用户打开新的 Activity B，此时 A 的 onPause() 先调用，再调用 B 的 onResume()。 Activity异常情况下生命周期 系统配置发生改变导致 Activity 被杀死并重新创建 系统配置文件发生改变时，Activity 会被重新创建，生命周期方法调用顺序 onPause() —&gt; onSaveInstanceState() —&gt; onStop() —&gt; onDestroy() —&gt; onCreate() —&gt; onStart() —&gt; onRestoreInstanceState() —&gt; onResume()。 Activity 被异常终止情况下，onSaveInstanceState() 方法才会被调用，正常情况下是不会的；该方法调用时机是在 onStop() 之前，至于在 onPause() 之前或者之后并不确定。 Activity 被异常终止情况下，Activity 会被重建，此时 onRestoreInstanceState() 会被调用，调用时机在 onStart() 之后。 onCreate() 与 onRestoreInstanceState() 区别：onRestoreInstanceState() 一旦被调用，其参数 savedInstanceState 一定是有值的，不用判断是否为空；但 onCreate() 不一样，如果是正常启动时，其参数 savedInstanceState 为 null，所以需要额外判空。 可以通过设置android:configChanges属性让屏幕旋转时不重新创建。 资源内存不足导致低优先级的 Activity 被杀死 前台 Activity：正在和用户交互的 Activity，优先级最高。 可见但非前台 Activity：可见但是位于后台无法与用户进行交互，优先级次之。 后台 Activity：优先级最低。 Activity四种启动模式 启动模式 standard：标准模式，这也是系统默认模式。每当启动一个 Activity 创建一个实例，谁启动谁就在谁任务栈。 singleTop：栈顶复用模式。如果新 Activity 已经位于任务栈栈顶，那么此 Activity 不会被创建，同时 onNewIntent() 方法被调用，随后 onResume() 方法也被调用；反之则会重新创建 Activity。 singleTask：栈内复用模式，这是一种实例模式。 singleInstance：单实例模式，singleTask 加强版。Activity 启动时，系统会单独为其创建任务栈，然后此 Activity 就在这个任务栈中，后续跟 singleTask 相同。 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 启动模式。 FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 启动模式。 FLAG_ACTIVITY_CLEAR_TOP：与 singleTask 启动模式异同出现，作用相同。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有该标记的 Activity 不会出现在历史 Activity 列表中。 注意点 TaskAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用才起作用，其它情况下没用。 TaskAffinity 与 singleTask 启动模式配对使用时，此时 Activity 运行 TaskAffinity 属性所指定的任务栈。 TaskAffinity 与 allowTaskReparenting 配对使用时，情况比较复杂，会产生特殊效果。 IntentFilter 匹配规则 action 的匹配规则 匹配规则：Intent 中的 action 必须能够和过滤规则中的任何一个action 匹配。 区分大小写。 注意与 category 匹配规则不一样。 category 的匹配规则 匹配规则：Intent 所包含的 category 必须与过滤规则中的任何一个 category 相同（可理解为一对一关系）。 特殊情况是 Intent 可以没有 category，但是系统默认会加上android.intent.category.DEFAULT，这也是隐式调用所要求的。 data 匹配规则 data 的结构 android:scheme：URI 模式，比如 http、file、content 等。 android:port：URI 中的端口号，需要指定 scheme 和 host 才有作用。 android:host：URI 主机名。 android:path：完整的路径。 android:pathPattern：完整的路径信息，也可以包含通配符 *。 android:pathPrefix：路径的前缀信息。 android:mimeType：媒体类型。 匹配规则：Intent 包含的 data 数据必须与过滤规则中某一个匹配（Intent 是过滤规则的子集），与 action 类似。 过滤规则有默认URI值：content 和 file。 注意点 判断是否能匹配隐式 Intent 方法 调用 PackageManager 的 resolveActivity 方法。 Intent 的 resolveActivity 方法。 PackageManager 中 queryIntentActivies 方法。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/tags/《Android-开发艺术探索》学习笔记/"}]}]}