{"meta":{"title":"PANJU's Note","subtitle":"故不积跬步，无以至千里；不积小流，无以成江海。","description":"笔记——记录工作和学习中的点点滴滴","author":"PANJU","url":"https://panzeyong.github.io"},"pages":[{"title":"about","date":"2017-03-11T15:18:09.000Z","updated":"2017-03-11T15:18:09.000Z","comments":true,"path":"about/index.html","permalink":"https://panzeyong.github.io/about/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-06-19T04:52:59.000Z","updated":"2017-06-19T04:52:59.000Z","comments":true,"path":"categories/index.html","permalink":"https://panzeyong.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-06-19T04:52:00.000Z","updated":"2017-06-19T04:52:00.000Z","comments":true,"path":"tags/index.html","permalink":"https://panzeyong.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"第 六 章 面向对象的程序设计","slug":"第-6-章-面向对象的程序设计","date":"2017-06-25T23:56:20.000Z","updated":"2017-07-07T00:03:24.000Z","comments":true,"path":"2017/06/26/第-6-章-面向对象的程序设计/","link":"","permalink":"https://panzeyong.github.io/2017/06/26/第-6-章-面向对象的程序设计/","excerpt":"","text":"一、理解对象1、属性类型 数据属性：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。有以下 4 个描述其行为的特性： [[Configurable]]：表示是否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。一旦该属性定义为不可配置，即 false，那么就再也不可能设置为可配置了，即 true。此时，再调用 Object.defineProperty() 方法修改除 writable 之外的属性都会导致错。在非严格模式下什么也不会发生，而在严格模式下会导致错误。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Writable]]：表示能否修改属性的值。在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致错误。（在对象上直接定义的属性，默认值为 true） [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认属性，必须调用 ECMAScript5 的 Object.defineProperty() 方法。该方法接收三个参数：属性所在的对象、属性的名字、和一个描述符对象。描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。例子如下： 将属性特性 writable 改为只读 12345678910111213141516var person = new Object();person.name = \"Julian\";person.age = 22;person.job = \"Software Engineer\";person.sayName = function() &#123; alert(this.name);&#125;;Object.defineProperty(person, \"name\", &#123; writable : false&#125;);person.sayName(); // 修改之前：Julianperson.name = \"Jack\";person.sayName(); // 修改之后：Julian 将属性特性 configurable 改为不可配置（对象 person 使用上面代码）。 1234567Object.defineProperty(person, \"name\", &#123;configurable : false&#125;);person.sayName(); // 修改之前：Juliandelete persion.name;person.sayName(); // 修改之后：Julian 在将属性特性 configurable 改为不可配置时再修改其它属性特性（writable 除外），抛出错误。 1234567Object.defineProperty(person, \"name\", &#123; value : \"Marry\"&#125;);// 错误提示Uncaught TypeError: Cannot redefine property: name at Function.defineProperty (&lt;anonymous&gt;) 访问器属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。（在对象上直接定义的属性，默认值为 true） [[Enumerable]]：表示能否通过 for-in 循环返回属性。（在对象上直接定义的属性，默认值为 true） [[Get]]：在读取属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能写入，在非严格模式下写入属性会被忽略；在严格模式下写入属性会抛出错误。 [[Set]]：在写入属性时调用的函数。默认值为 undefined。只指定该属性时意味着不能读取，在非严格模式下读取时返回 undefined；在严格模式下会抛出错误。 访问器不能直接定义，必须使用 Object.defineProperty() 定义。 书中例子，代码如下 123456789101112131415161718192021222324252627282930var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; console.log(\"get\"); return this._year; &#125;, set: function(value) &#123; if (value &gt; 2004) &#123; console.log(\"set\"); this._year = value; this.edition += value - 2004; &#125; &#125;&#125;);// 调用访问器 setbook.year = 2007; alert(book.edition); // 调用访问器 getalert(book.year);// 如果将属性名 “year” 改为 \"_year\"，并设置 book._year = 2007，则会导致无限递归，最终导致错误。// 注：_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问属性。 2、定义多个属性调用方法 Object.defineProperties() 可以为一个对象定义多个属性，该方法接收两个对象参数：第一个对象参数是要添加和修改其属性的对象；第二个对象参数是第二个对象的属性与第一个对象中要添加或修改的属性一一对应。 书中例子，代码如下： 12345678910111213141516171819202122232425262728var book = &#123;&#125;;Object.defineProperties(book, &#123; // 数据属性 _year: &#123; value: 2005 &#125;, // 数据属性 edition: &#123; value: 1 &#125;, // 访问器属性 year: &#123; get: function() &#123; return this._year; &#125;, set: function(value) &#123; if (value &gt; 2005) &#123; this._year = value; this.edition += value - 2005; &#125; &#125; &#125;&#125;); 3、读取属性的特性调用 Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取器描述符的属性名称。返回一个对象。 书中例子，代码如下：（基于以上代码） 123456789101112131415// 数据属性var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");alert(descriptor.value); // 2005alert(descriptor.configurable); // falsealert(descriptor.writable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // undefined// 访问器属性var descriptor = Object.getOwnPropertyDescriptor(book, \"year\");alert(descriptor.value); // undefined alert(descriptor.configurable); // falsealert(descriptor.enumerable); // falsealert(typeof descriptor.get); // functionalert(typeof descriptor.set); // function 二、创建对象1、工厂模式用函数来封装以特定接口创建对象的细节，与 Java 中 class 类似，即将对象类型的属性和方法进行封装。 2、构造函数模式可用来创建特定类型的对象，用 new 操作符来调用，这是与普通函数唯一的区别。 3、原型模式在 JavaScript 中，我们创建的每个函数都包含一个（原型）属性：prototype。prototype 属性是一个指针，指向一个对象，即原型对象，该原型对象包含可由特定类型的所有实例共享的属性和方法。换句话说，该原型对象可以说是调用构造函数而创建的对象实例的原型对象。使用原型对象的好处是让所有对象实例共享它包含的属性和方法。 书中例子，代码如下：（1） 1234567891011121314151617function Person() &#123;&#125;Person.prototype.name = \"Marry\";Person.prototype.age = 22;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName();var person2 = new Person();person2.sayName();alert(person1.sayName == person2.sayName); // true 理解原型对象 每当我们创建新函数时，就会根据特定规则为该函数创建一个 prototype 属性，该属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获取 constructor （构造函数）属性，该属性包含一个指向 prototype 属性所在函数的指针。 prototype 这个属性连接在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 读取对象属性的原则：先从对象实例进行搜索，搜索不到的话再从原型对象进行搜索。 虽然可以通过对象实例访问保存在原型对象中的值，但是却不能通过对象实例修改原型对象中的值。如果我们在对象实例定义与原型对象中同名的属性，则对象实例中的属性会屏蔽原型对象中的属性。 使用 delete 操作符可以则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。 原型与 in 操作符 使用 in 操作符方式：单独使用和在 for-in 循环中使用。 单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 同时使用 hasOwnProperty() 方法和 in 操作符，就可以确定该属性到底是存在于对象，还是存在于原型中。 在 for-in 中，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将 [[Enumerable]]）标记为 false 属性）的实例属性也会在 for-in 循环中返回。（例子如下） 123456789101112131415161718192021222324252627282930313233343536var object = &#123; toString : function() &#123; return \"toString\"; &#125;, hasOwnProperty : function() &#123; return \"hasOwnProperty\"; &#125;, propertyIsEnumerable : function() &#123; return \"propertyIsEnumerable\"; &#125;, toLocaleString : function() &#123; return \"toLocaleString\"; &#125;, valueOf : function() &#123; return \"valueOf\"; &#125;&#125;;for(var o in object) &#123; if (o == \"toString\") &#123; alert(\"toString\"); alert(o); &#125; else if (o == \"toLocaleString\") &#123; alert(\"toLocaleString\"); &#125; else if (o == \"valueOf\") &#123; alert(\"valueOf\"); &#125; else if (o == \"hasOwnProperty\") &#123; alert(\"hasOwnProperty\"); &#125; else if (o == \"propertyIsEnumerable\") &#123; alert(\"propertyIsEnumerable\"); &#125;&#125; 更简单的原型语法 用一个包含所有属性和方法的对象字面量来重写整个原型对象。需要注意的是 constructor 属性不再指向 prototype 属性所在函数（比如 Person），而是指向 Object 构造函数。 12345678910function Person() &#123;&#125;Person.prototype = &#123; name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; - 如果要重新设置 constructor 属性所指向的函数，则可以添加constructor : Person。不过值得注意的是这样设置会导致 **[[Enumerable]]** 特性被设置为 true。默认情况下，原生的 **constructor** 属性是不可枚举的。 原型的动态性 对原型对象的任何修改都能够立即从实例上反映出来，原因是实例与原型之间的松散连接关系。 123456789function Person() &#123;&#125; var person = new Person(); Person.prototype.sayHi = function() &#123; alert(\"Hi\");&#125;; person.sayHi(); 如果对原型对象进行重写，那情况就不一样。这时存在两个对象，并且毫无关联。 123456789101112131415function Person() &#123;&#125; var friend = new Person(); Person.prototype = &#123; constructor : Person, name : \"Jack\", age : 22, job : \"Software Engineer\", sayName : function() &#123; alert(this.name); &#125;&#125;; friend.sayName(); // error 实例中的指针仅指向原型，而不指向构造函数。 构造函数、原型与实例之间关系 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 4、组合使用构造函数模式和原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。好处是最大限度地节省了内存。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.language = [\"JavaScript\", \"Java\", \"PHP\"];&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.language.push(\"Python\");alert(person1.language); // \"JavaScript, Java, PHP, Python\"alert(person2.language); // \"JavaScript, Java, PHP\"alert(person1.language == person2.language); // falsealert(person1.sayName == person2.sayName); // true 5、动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 123456789101112function Person(name, age, job) &#123; // 属性 this.name = name; this.age = age; this.job = job; if(typeof this.sayName != \"function\") &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125; &#125;&#125; 6、寄生构造函数模式创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。（与工厂模式类似） 12345678910functuon Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; retrun o;&#125; 7、稳妥构造函数模式稳妥对象：指的是没有公共属性，而且其方法也不引用 this 的对象。 适用场景：一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其它应用程序（如 Mashup 程序）改动时使用。 稳妥构造函数与寄生构造函数模式区别： 稳妥构造函数新创建对象的实例方法不引用 this； 稳妥构造函数不使用 new 操作符调用构造函数。 1234567891011121314function Person(name, age, job) &#123; // 创建要返回的对象 var o = new Object(); // 可以在这里定义私有变量和函数 // 添加方法 o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 继承继承有两种方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际方法。ECMAScript 只支持实现继承，并且主要依靠原型链来实现。 1、原型链让一个引用类型继承另一个引用类型的属性和方法。可以简单概括地说：有一个超类，具有属性和方法；通过 new 操作符创建超类实例赋值给子类，即子类的原型指向超类的原型，创建子类实例，指向子类的原型。例子如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function SuperType() &#123; console.log(\"SuperType\"); this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; console.log(\"getSuperValue\"); return this.property;&#125;;function SubType() &#123; console.log(\"SubType\"); this.subproperty = false;&#125;// 继承 SuperTypeSubType.prototype = new SuperType();// 使用字面量添加新方法，会导致上一行代码无效（17）SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;;// 添加新方法SubType.prototype.getSubValue = function() &#123; console.log(\"getSubValue\"); return this.subproperty;&#125;;// 覆盖方法SubType.prototype.getSuperValue = function() &#123; return false;&#125;;var instance = new SubType();alert(instance.getSuperValue());alert(instance.getSubValue());alert(instance.property); 需要注意的要点： 所有引用类型默认继承 Object，而且这个继承也是通过原型链实现的。也就是说，所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。 在给原型添加新方法或覆盖方法的代码一定要放在替换原型语句之后。 在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。（ps：还不是很理解） 原型链存在问题： 包含引用类型值所带来的问题，即引用类型值的所有属性是被共享的，这就导致一个实例修改其中属性，也会影响到其它实例。 在创建子类型的实例时，不能向超类型的构造函数中传递参数。 2、借用构造函数（伪造对象或经典继承）在子类型构造函数的内部调用超类型构造函数。可以这样说，在子类创建新对象时执行超类构造函数中初始化代码，使子类实例各具有自己的一份副本。（ps：纯属自己理解） 1234567891011121314function SuperType() &#123; this.colors = [\"red\", \"blue\", \"green\"];&#125;function SubType() &#123; SuperType.call(this);&#125;var instance = new SubType();instance.colors.push(\"pink\");alert(instance.colors); // \"red, blue, green, pink\"var instance = new SubType();alert(instance.colors); // \"red, blue, green\" 相对于原型链优势：在子类构造函数中向超类型构造函数传递参数。 借用构造函数存在问题：方法都在构造函数中定义，函数复用无从谈起。 3、组合继承（伪经典继承）使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance = new SubType(\"Jack\", 22);instance.colors.push(\"black\");alert(instance.colors); // \"red, blue, green, pink\" instance.sayName(); // Jackinstance.sayAge(); // 22var instance = new SubType(\"John\", 21); alert(instance.colors); // \"red, blue, green\"instance.sayAge(); // Johninstance.sayName(); // 21 4、原型式继承在函数先创建一个临时构造函数，将传入的对象作为这个构造函数的原型，最终返回该类型的新实例。 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 5、寄生式继承（parasitic）创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。与寄生构造函数和工厂模式类型。 1234567function create(original) &#123; var clone = object(original); // object() 原型式继承函数 clone.sayHi = function() &#123; alert(\"hi\"); &#125;; return clone;&#125; 6、寄生组合式继承通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需要的无非就是超类型原型的副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。(主要是为了避免调用两次超类型构造函数) 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象&#125; 方法 isPrototypeOf()：确定对象之间是否存在关系，即如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象，则返回 true。 12alert(Person.prototype.isPrototypeOf(person1)); // truealert(Person.prototype.isPrototypeOf(person2)); // true Object.getPrototypeOf()：返回 [[Prototype]] 的值。 12alert(Object.getPrototypeOf(person1) == Person.prototype); // truealert(Object.getPrototypeOf(person1).name); // Marry hasOwnProperty()：可以检测一个属性是存在于实例中，还是存在于原型中。如果给定属性存在于实例对象中，则返回 true；否则返回 false。 12345678910111213alert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // falseperson2.name = \"John\";person1.sayName(); // Marryperson2.sayName(); // Johnalert(person1.hasOwnProperty(\"name\")); // falsealert(person2.hasOwnProperty(\"name\")); // truedelete person2.namealert(person2.name); // Maryalert(person2.hasOwnProperty(\"name\")); // false Object.keys()：获取对象上所有可枚举的实例属性。该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 Object.getOwnPropertyNames()：获取所有实例属性，无论是否可枚举。 Object.create()：该方法用于规范化原型式继承。接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 12345678910var person = &#123; name : \"Julian\", friends : [\"Ruby\", \"Java\", \"JavaScript\", \"Python\"]&#125;;var person1 = Object.create(person, &#123; name : &#123; value : \"John\" &#125;&#125;); 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第六章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。（未完待续）","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"《JavaScript 高级程序设计》学习笔记","slug":"《JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/《JavaScript-高级程序设计》学习笔记/"}]},{"title":"Picasso 用法及源码解析","slug":"Picasso-用法及源码解析","date":"2017-06-06T23:47:21.000Z","updated":"2017-06-19T15:22:12.000Z","comments":true,"path":"2017/06/07/Picasso-用法及源码解析/","link":"","permalink":"https://panzeyong.github.io/2017/06/07/Picasso-用法及源码解析/","excerpt":"","text":"Picasso 是 Square 公司开源的一个 Android 平台优秀图片加载框架，易用、代码简洁、可读性高。自己接触的第一个开源图片加载框架也是 Picasso，以前只停留在会用阶段，根本不知道是如何实现的，最近花了点时间看了 Picasso 源码，学到的东西还是蛮多；大概理解实现基本流程。 对于看源码这事，一开始真不知从哪里下手。于是 Google 了，发现很多都是从使用方法入手，理清方法间是如何调用，最后形成自己的线索。本文也是按照这种方式来分析 Picasso 源码。 Picasso 使用方法 使用 Picasso 加载一张图片很简单，一行代码就搞定 12345Picasso.whth(context) .load(R.mipmap.ic_default) .placeholder(R.mipmap.ic_default) .error(R.mipmap.ic_default) .into(imageView); 加载一张图片并且按照指定尺寸以 centerCrop 形式对图片进行缩放 12345Picasso.with(this) .load(R.mipmap.ic_default) .resize(200, 200) .centerCrop() .into(imageView); 加载一张图片并且按照指定尺寸以 centerInside 形式图片进行缩放（注：对图片进行处理时，centerCrop 或 centerInside 只能选择一种方式，并且必须调用方法 resize(targetWidth, targetHeight) 或者 resizeDimen(targetWidthResId, targetHeightResId) 设置大小） 12345Picasso.with(this) .load(R.mipmap.ic_default) .resizeDimen(R.dimen.width, R.dimen.height) .centerInside() .into(imageView); 加载一张图片并且按照一定角度对其进行旋转 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .rotate(20) .into(imageView); 加载一张图片自适应目标视图（由于调整大小适应目标视图，结果导致请求被延迟，直到调整完毕才会发送请求；目标视图只能是 ImageView） 1234Picasso.with(this) .load(R.mipmap.ic_launcher) .fit() .into(imageView); 加载一张图片并设置回调接口 12345678910Picasso.with(this) .load(R.mipmap.ic_launcher) .into(mImageView, new Callback() &#123; @Override public void onSuccess() &#123; &#125; @Override public void onError() &#123; &#125; &#125;); 以上只是 Picasso 简单的用法，至于其它用法看API；接下来分析下源码。 Picasso 源码解析Picasso.with() 方法解析为了探究 Picasso.with() 方法如何实现，唯独从源代码找答案。代码如下： 123456789101112131415161718192021222324252627282930/** * The global default &#123;@link Picasso&#125; instance. * &lt;p&gt; * This instance is automatically initialized with defaults that are suitable to most * implementations. * &lt;ul&gt; * &lt;li&gt;LRU memory cache of 15% the available application RAM&lt;/li&gt; * &lt;li&gt;Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only * available on API 14+ &lt;em&gt;or&lt;/em&gt; if you are using a standalone library that provides a disk * cache on all API levels like OkHttp)&lt;/li&gt; * &lt;li&gt;Three download threads for disk and network access.&lt;/li&gt; * &lt;/ul&gt; * &lt;p&gt; * If these settings do not meet the requirements of your application you can construct your own * with full control over the configuration by using &#123;@link Picasso.Builder&#125; to create a * &#123;@link Picasso&#125; instance. You can either use this directly or by setting it as the global * instance with &#123;@link #setSingletonInstance&#125;. */ public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton;&#125; 从注释中可以得到以下几点： 全局默认实例，也就是说只有一个实例存在，从使用单例模式可以看出。 Picasso 采用两级缓存：内存缓存和磁盘缓存。 LRU 内存缓存大小占整个应用可用 RAM 容量的 15%。 磁盘缓存大小占存储空间的 2%，不少于 5 MB，不超过 50 MB。（注：仅适于 API 14+ 或者所使用的第三方库包含 API，比如 OkHttp）。 为磁盘访问和网络访问提供 3 个线程。 这些配置是 Picasso 默认配置的，如果不满足自己的需求，可以自己定制。通过 Picasso.Builder 创建 Picasson 实例，根据自己需要配置相关属性，并调用方法 setSingletonInstance(picasso) 设置为全局实例。 很明显可以看到，使用单例模式来创建 Picasso 实例，保证全局只有一个实例存在。简单说下 with() 方法的实现，singleton 为 null 时调用 Builder 类中 build() 方法创建 singleton 实例并返回，那么接下来就来看 Builder 类中 build() 方法是如何实现的？ Picasso.Builder 中 build() 方法解析源码如下： 12345678910111213141516171819202122public Picasso build() &#123; Context context = this.context; if (downloader == null) &#123; downloader = Utils.createDefaultDownloader(context); &#125; if (cache == null) &#123; cache = new LruCache(context); &#125; if (service == null) &#123; service = new PicassoExecutorService(); &#125; if (transformer == null) &#123; transformer = RequestTransformer.IDENTITY; &#125; Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled);&#125; Builder 类是 Picasso 这个类中的静态内部类，而 build() 方法是 Builder 类中的成员方法，可以看出采用建造者模式。那么 build() 方法实现的功能主要有： 创建默认下载器 Downloader 创建默认内存缓存 LruCache （由于接口 Cache 支持多线程访问，所以实现该接口时需确保线程安全） 创建默认线程池 PicassoExecutorService 创建默认请求转发器 RequestTransformer 创建默认统计 Stats 创建默认调度器 Dispatcher 创建 Picasso 实例 那么这些实例是如何创建的，下面主要通过流程图来解析（主要是方法间的调用以及方法内部部分细节）。 Downloader 是一个接口，无法实例化，需要通过实现类创建实例，该接口的功能主要从磁盘缓存加载图片或网络下载图片。OkHttpDownloader 和 UrlConnectionDownloader 分别实现该接口，那么创建实例也是通过这两个实现类来创建的，那么来看下实例化 Downloader 流程。 LruCache 是内存缓存类，实现接口 Cache，采用最近最少使用算法。 PicassoExecutorService 继承 ThreadPoolExecutor，是线程池，供图片下载，线程数根据不同网络类型设置，默认的线程数是 3 个，直接通过 new 操作符实例化对象。 RequestTransformer 是一个接口，功能是在发送请求之前对图片进行转换处理。从源码中可以看出，这是一个测试功能，在后续版本可能不兼容，使用该功能时得谨慎。 对于 Stats 实例的创建，直接 new 一个对象，那么主要来看该构造方法做了哪些操作？代码如下： 1234567Stats(Cache cache) &#123; this.cache = cache; this.statsThread = new HandlerThread(STATS_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); this.statsThread.start(); Utils.flushStackLocalLeaks(statsThread.getLooper()); this.handler = new StatsHandler(statsThread.getLooper(), this);&#125; 主要是实例化对象，结合注释应该不难理解。 Dispatcher 实例的创建与 Stats 类似，代码如下： 12345678910111213141516171819202122232425Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler, Downloader downloader, Cache cache, Stats stats) &#123; // dispatcherThread 是子线程，注意记得调用 start() 方法 this.dispatcherThread = new DispatcherThread(); this.dispatcherThread.start(); Utils.flushStackLocalLeaks(dispatcherThread.getLooper()); this.context = context; this.service = service; this.hunterMap = new LinkedHashMap&lt;String, BitmapHunter&gt;(); this.failedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedTags = new HashSet&lt;Object&gt;(); // 注意该 handler 是在子线程的 this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this); this.downloader = downloader; // 在主线程 this.mainThreadHandler = mainThreadHandler; this.cache = cache; this.stats = stats; this.batch = new ArrayList&lt;BitmapHunter&gt;(4); this.airplaneMode = Utils.isAirplaneModeOn(this.context); this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE); this.receiver = new NetworkBroadcastReceiver(this); receiver.register();&#125; 最后，也是最重要的一点，那就是 Picasso 实例的创建，先看下代码吧 1234567891011121314151617181920212223242526272829303132333435363738Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) &#123; this.context = context; this.dispatcher = dispatcher; this.cache = cache; this.listener = listener; this.requestTransformer = requestTransformer; this.defaultBitmapConfig = defaultBitmapConfig; int builtInHandlers = 7; // Adjust this as internal handlers are added or removed. int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0); List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); this.stats = stats; this.targetToAction = new WeakHashMap&lt;Object, Action&gt;(); this.targetToDeferredRequestCreator = new WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;(); this.indicatorsEnabled = indicatorsEnabled; this.loggingEnabled = loggingEnabled; this.referenceQueue = new ReferenceQueue&lt;Object&gt;(); this.cleanupThread = new CleanupThread(referenceQueue, HANDLER); this.cleanupThread.start();&#125; 除了对一些对象赋值外，重要的一点就是创建和添加 RequestHandler，代码主要在 19 ~ 29 行，比如文件、网络、资源等处理器。至此，Picasso 实例也就创建完毕了，那么接下来看 load() 方法是如何实现的。 Picasso.load() 方法解析load() 有多个重载方法，可以传入 resourceId、string、file、uri，但是最后都是返回 RequestCreator 实例，接下来就来看该方法如何实现？代码如下： 1234567public RequestCreator load(int resourceId) &#123; if (resourceId == 0) &#123; throw new IllegalArgumentException(\"Resource ID must not be zero.\"); &#125; return new RequestCreator(this, null, resourceId);&#125; 很明显地看出，调用 load() 方法后返回的是 RequestCreator 实例，那么来看下 RequestCreator 构造方法是咋样的，代码如下： 123456RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123; if (picasso.shutdown) &#123; throw new IllegalStateException(\"Picasso instance already shut down. Cannot submit new requests.\"); &#125; this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig); &#125; 创建 Request.Builder 对象，并将需要加载图片信息封装到该对象里，采用建造者模式。对于一些操作比如 rotate、centerCrop、centerInside、resize 等，其实只是修改其状态，真正执行操作是方法 into，该方法是核心方法，以下重点分析。 into() 方法解析into() 有 5 个重载方法，每个方法实现的主要功能基本相同，但是稍微还是有点不一样的。以常用 into(ImageView target) 这个方法为例子来讲解下内部是如何实现的？由于个人比较喜欢画流程图来理清方法之间调用关系，于是就有下面的流程图： 结合流程图再来看源码应该会比较好理解，代码如下： 123public void into(ImageView target) &#123; into(target, null);&#125; 该方法所持有的 ImageView 实例是一个弱引用，内存不足情况下可以自动被垃圾回收器回收。很明显，该方法调用重载方法 into(target, null)，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void into(ImageView target, Callback callback) &#123; long started = System.nanoTime(); checkMain(); if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; if (deferred) &#123; if (data.hasSize()) &#123; throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; Request request = createRequest(started); String requestKey = createKey(request); if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); picasso.enqueueAndSubmit(action);&#125; 参数 Callback 是一个强引用，将会阻止 Activity 或者 Fragment 被回收，从而导致内存泄漏。如果使用该方法，在释放资源时最好调用 Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求，以免造成内存泄漏。从源码可以清晰地看出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 判断目标组件 ImageView 是否为 null；如果不为 null，则继续执行；否则抛出异常。 检查发送请求是否包含要加载图片 uri 或 resourceId；如果没有，则调用Picasso 类 cancelRequest(android.widget.ImageView) 方法取消请求（后面讲解该方法），并检查是否设置默认图片；否则继续执行。 检查是否调用方法 fit()，即 deferred 是否为 true，true 表示调用，false 表示调用 unfit() 方法；调用该方法意味着延迟加载图片，并且不能与方法 resize() 同时使用。 为加载图片创建请求。 为每个请求创建 key，主要是为了方便存储。 根据缓存策略判断是否从内存缓存读取。 是否设置默认图片。 创建对应的 Action 实例，在这里是 ImageViewAction。 入队和提交 action。 以上是总体概括，接下来逐一看具体实现。 那么先来看下 cancelRequest(android.widget.ImageView) 具体实现，代码如下： 123public void cancelRequest(ImageView view) &#123; cancelExistingRequest(view);&#125; 只有一行代码，调用 cancelExistingRequest(view) 方法，看下具体实现： 12345678910111213141516private void cancelExistingRequest(Object target) &#123; checkMain(); Action action = targetToAction.remove(target); if (action != null) &#123; action.cancel(); dispatcher.dispatchCancel(action); &#125; if (target instanceof ImageView) &#123; ImageView targetImageView = (ImageView) target; DeferredRequestCreator deferredRequestCreator = targetToDeferredRequestCreator.remove(targetImageView); if (deferredRequestCreator != null) &#123; deferredRequestCreator.cancel(); &#125; &#125; &#125; 按照惯例，先列出该方法实现的主要功能： 检查当前线程是否为主线程；如果是主线程，则继续执行；否则抛出异常。 通过 key 从 targetToAction 移除对应 action。 如果 action 不为 null，执行一些取消操作，相当于释放资源。 如果目标组件是 ImageView，则检查是否调用 fit() 方法，是的话就执行一些取消操作。 接着来看下取消操作方法 dispatcher.dispatchCancel(action) 具体实现： 123void dispatchCancel(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_CANCEL, action));&#125; 很明显是通过 Handler 消息机制来处理的。即 Dispatcher 类中 DispatcherHandler 发送消息 REQUEST_CANCEL，并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performCancel(action) 具体实现： 1234567891011121314151617181920212223242526void performCancel(Action action) &#123; String key = action.getKey(); BitmapHunter hunter = hunterMap.get(key); if (hunter != null) &#123; hunter.detach(action); if (hunter.cancel()) &#123; hunterMap.remove(key); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId()); &#125; &#125; &#125; if (pausedTags.contains(action.getTag())) &#123; pausedActions.remove(action.getTarget()); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId(), \"because paused request got canceled\"); &#125; &#125; Action remove = failedActions.remove(action.getTarget()); if (remove != null &amp;&amp; remove.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_CANCELED, remove.getRequest().logId(), \"from replaying\"); &#125;&#125; 从以上代码很清晰地看出该方法主要做一些取消、移除操作，即释放资源。以上就是 cancelExistingRequest(view) 内部实现解析。 回到 into(target, null) 内部实现，看下创建请求 createRequest(started) 具体实现： 12345678910111213141516171819202122232425private Request createRequest(long started) &#123; int id = nextId.getAndIncrement(); Request request = data.build(); request.id = id; request.started = started; boolean loggingEnabled = picasso.loggingEnabled; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString()); &#125; Request transformed = picasso.transformRequest(request); if (transformed != request) &#123; // If the request was changed, copy over the id and timestamp from the original. transformed.id = id; transformed.started = started; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), \"into \" + transformed); &#125; &#125; return transformed;&#125; 其实实现逻辑很简单，对要加载图片的具体信息封装成 Request；通过 Request 创建对应 key，那么来看下是如何创建的，即 createKey(request) 方法具体实现： 12345static String createKey(Request data) &#123; String result = createKey(data, MAIN_THREAD_KEY_BUILDER); MAIN_THREAD_KEY_BUILDER.setLength(0); return result;&#125; 逻辑很简单，调用方法 createKey(data, MAIN_THREAD_KEY_BUILDER)，看下具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041static String createKey(Request data, StringBuilder builder) &#123; if (data.stableKey != null) &#123; builder.ensureCapacity(data.stableKey.length() + KEY_PADDING); builder.append(data.stableKey); &#125; else if (data.uri != null) &#123; String path = data.uri.toString(); builder.ensureCapacity(path.length() + KEY_PADDING); builder.append(path); &#125; else &#123; builder.ensureCapacity(KEY_PADDING); builder.append(data.resourceId); &#125; builder.append(KEY_SEPARATOR); if (data.rotationDegrees != 0) &#123; builder.append(\"rotation:\").append(data.rotationDegrees); if (data.hasRotationPivot) &#123; builder.append('@').append(data.rotationPivotX).append('x').append(data.rotationPivotY); &#125; builder.append(KEY_SEPARATOR); &#125; if (data.hasSize()) &#123; builder.append(\"resize:\").append(data.targetWidth).append('x').append(data.targetHeight); builder.append(KEY_SEPARATOR); &#125; if (data.centerCrop) &#123; builder.append(\"centerCrop\").append(KEY_SEPARATOR); &#125; else if (data.centerInside) &#123; builder.append(\"centerInside\").append(KEY_SEPARATOR); &#125; if (data.transformations != null) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, count = data.transformations.size(); i &lt; count; i++) &#123; builder.append(data.transformations.get(i).key()); builder.append(KEY_SEPARATOR); &#125; &#125; return builder.toString();&#125; 很简单，根据 Request 设置的属性拼接为字符串，作为最终的 key 并返回。 当我们调用不同 into() 方法时，Picasso 就会实例化不同的 Action，而这里我们是以 into(ImageView) 为例子，因此会实例化 ImageViewAction，在 ImageView 有回调方法，供我们使用，后续会看到。一切都准备就绪，那么就可以入队和提交 action。那么是如何实现的呢？来看下具体实现： 123456789void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // This will also check we are on the main thread. cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action);&#125; 通过 key 从 targetToAction 获取 action，不存在的话就执行检查操作并将 action 插入到 targetToAction，最后调用 submit(action)，具体实现如下： 123void submit(Action action) &#123; dispatcher.dispatchSubmit(action);&#125; 最后还是回到 Dispatcher，通过 DispatcherHandler 消息机制发送消息 REQUEST_SUBMIT，并在其回调方法 并在其回调方法 handleMessage(final Message msg) 实现具体逻辑，注意是在子线程执行的。 123456789101112131415161718@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 接着来看下 dispatcher.performSubmit(action) 具体实现： 123void performSubmit(Action action) &#123; performSubmit(action, true);&#125; 只有一行代码，调用方法 performSubmit(action, true)，具体实现如下： 12345678910111213141516171819202122232425262728293031323334void performSubmit(Action action, boolean dismissFailed) &#123; if (pausedTags.contains(action.getTag())) &#123; pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), \"because tag '\" + action.getTag() + \"' is paused\"); &#125; return; &#125; BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\"); &#125; return; &#125; hunter = forRequest(action.getPicasso(), this, cache, stats, action); hunter.future = service.submit(hunter); hunterMap.put(action.getKey(), hunter); if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); &#125;&#125; 简要概括下该方法实现的主要功能： 检查标记 tag 请求是否被取消，如果被取消，则将对应 action 插入到 pausedActions 并退出程序；否则继续执行。 通过 key 从 hunterMap 获取相应 BitmapHunter 并判断其是否为 null，如果不为 null，则调用其方法 attach(Action) 并结束退出程序；否则继续执行。简要说明下，BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务。 检查线程池是否停止工作。 创建 BitmapHunter 实例，即调用方法 forRequest(action.getPicasso(), this, cache, stats, action) 将 hunter 提交到线程池并执行，即调用 service.submit(hunter) 看下 forRequest() 方法具体实现： 12345678910111213141516static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) &#123; Request request = action.getRequest(); List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers(); // Index-based loop to avoid allocating an iterator. //noinspection ForLoopReplaceableByForEach for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);&#125; 通过调用 RequestHandler 中 canHandleRequest(Request) 方法逐一检查对应 RequestHandler，并创建 BitmapHunter 对象返回。然后将 hunter 提交到线程池并执行。submit(Runnable) 是接口 ExecutorService 里的方法，PicassoExecutorService 实现接口 ExecutorService，因此 submit(Runnable) 方法的实现逻辑在 PicassoExecutorService 类里面，具体实现如下： 123456@Override public Future&lt;?&gt; submit(Runnable task) &#123; PicassoFutureTask ftask = new PicassoFutureTask((BitmapHunter) task); execute(ftask); return ftask;&#125; execute(ftask) 执行任务，由于 BitmapHunter 实现接口 Runnable，意味着开启线程在后台执行任务；而在该方法里会调用线程 start() 方法，意味着 BtimapHunter 中 run() 会被调用，真正执行任务逻辑在该方法里面实现，接下来的重点肯定是来研究该方法内部实现逻辑，在研究源代码之前，先来看该方法内部实现流程图： 同样结合流程图来解析 run() 内部实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; try &#123; updateThreadName(data); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(this)); &#125; result = hunt(); if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125;&#125; 简要概括下该方法实现的主要功能： 更新线程名字。 返回 Bitmap 对象并赋值给 result。 判断返回结果 result 是否为 null，如果为 null，则调用 dispatcher.dispatchFailed(this)；否则调用 dispatcher.dispatchComplete(this) 各种异常处理。 从源代码可以看出，核心的逻辑在方法 hunt()，那么它的内部实现又是怎么呢？具体实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), \"from cache\"); &#125; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; RequestHandler.Result result = requestHandler.load(data, networkPolicy); if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); bitmap = result.getBitmap(); // If there was no Bitmap then we need to decode it from the stream. if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; stats.dispatchBitmapDecoded(bitmap); if (data.needsTransformation() || exifRotation != 0) &#123; synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); &#125; &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), \"from custom transformations\"); &#125; &#125; &#125; if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; &#125; &#125; return bitmap;&#125; 代码实现确实很复杂，没事，先概括下其实现的主要小功能，再逐一解析： 根据缓存策略判断是否从内存缓存读取 bitmap，true 表示直接读取并返回 bitmap；否则继续执行。 根据不同请求资源调用相应 RequestHandler 中 load() 方法下载图片，这里以网络请求资源为例子来讲解，即 NetworkRequestHandler。 从下载返回结果 RequestHandler.Result 获取 bitmap，判断是否为 null 做出相应的处理。 重点来 NetworkRequestHandler 类 load() 方法具体实现： 1234567891011121314151617181920212223242526272829@Overridepublic Result load(Request request, int networkPolicy) throws IOException &#123; Response response = downloader.load(request.uri, request.networkPolicy); if (response == null) &#123; return null; &#125; Picasso.LoadedFrom loadedFrom = response.cached ? DISK : NETWORK; Bitmap bitmap = response.getBitmap(); if (bitmap != null) &#123; return new Result(bitmap, loadedFrom); &#125; InputStream is = response.getInputStream(); if (is == null) &#123; return null; &#125; // Sometimes response content length is zero when requests are being replayed. Haven't found // root cause to this but retrying the request seems safe to do so. if (loadedFrom == DISK &amp;&amp; response.getContentLength() == 0) &#123; Utils.closeQuietly(is); throw new ContentLengthException(\"Received response with 0 content-length header.\"); &#125; if (loadedFrom == NETWORK &amp;&amp; response.getContentLength() &gt; 0) &#123; stats.dispatchDownloadFinished(response.getContentLength()); &#125; return new Result(is, loadedFrom); &#125; 第 3 行代码实现图片下载，即客户端发送网络请求，服务端对客户端的请求作出响应，客户端根据服务端返回的结果作出处理。那么是如何实现下载的呢？downloader 是 Downloader 实例，而 Downloader 是接口，无法实例化，需要在子类实例化，而该接口有两个实现类：OkHttpDownloader 和 UrlConnectionDownloader。至于调用哪个类 load() 方法，取决于当前 sdk 最低版本是否在 API 14及以上。这里以 OkHttpDownloader 类 load() 方法为例来讲解是如何实现下载的，代码如下： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Response load(Uri uri, int networkPolicy) throws IOException &#123; CacheControl cacheControl = null; if (networkPolicy != 0) &#123; if (NetworkPolicy.isOfflineOnly(networkPolicy)) &#123; cacheControl = CacheControl.FORCE_CACHE; &#125; else &#123; CacheControl.Builder builder = new CacheControl.Builder(); if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) &#123; builder.noCache(); &#125; if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) &#123; builder.noStore(); &#125; cacheControl = builder.build(); &#125; &#125; Request.Builder builder = new Request.Builder().url(uri.toString()); if (cacheControl != null) &#123; builder.cacheControl(cacheControl); &#125; com.squareup.okhttp.Response response = client.newCall(builder.build()).execute(); int responseCode = response.code(); if (responseCode &gt;= 300) &#123; response.body().close(); throw new ResponseException(responseCode + \" \" + response.message(), networkPolicy, responseCode); &#125; boolean fromCache = response.cacheResponse() != null; ResponseBody responseBody = response.body(); return new Response(responseBody.byteStream(), fromCache, responseBody.contentLength()); &#125; 第 3 - 17 行代码主要是设置缓存策略；第 24 行通过调用 OkHttp 库 API 实现图片下载任务，并返回响应结果 com.squareup.okhttp.Response；最后对响应结果作出相应处理并创建 Response 对象返回。 再回到 NetworkRequestHandler 类 load() 方法，从返回 Response 对象调用 getBitmap() 方法获取 Bitmap 对象并判断其是否为 null，如果不为 null，则将 bitmap 和 loadedfrom 传入 Result 构造器方法中，创建 Result 对象并返回；否则调用 getInputStream() 方法获取输入流，不为 null 的话则创建 Result 对象并返回。 回到 hunt() 方法，从返回结果 result 获取数据类型为 Bitmap 对象 bitmap，并判断其是否为 null 作出不同的处理。如果 bitmap 不为 null，则判断原先发送加载图片请求 Request 是否需要对图片进行转换处理，即裁剪、缩放、重置大小等；不需要的话直接返回 bitmap；需要的话做转换处理后再返回 bitmap；如果 bitmap 为 null，则从 result 获取输入流 InputStream，并对 is 进行解析转换成 Bitmap 类型，将获取到的结果返回。 hunt() 方法解析完了，回到 run() 方法。根据调用方法 hunt() 返回结果 result，类型为 Bitmap，判断其是否为 null 并作出相应的处理。那么就来看下不为 null 的情况下又做了什么操作，即第 14 行代码，具体实现如下： 123void dispatchComplete(BitmapHunter hunter) &#123; handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));&#125; 很明显，又采用 Handler 消息机制处理，即 Dispatcher 类中 DispatcherHandler 发送消息 HUNTER_COMPLETE，其回调方法 handleMessage(final Message msg) 收到消息后并处理。说明一下，DispatcherHandler 所在的线程为子线程，即 DispatcherThread。 1234567891011121314151617@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125; &#125;); &#125; &#125;&#125; 在其回调方法中，核心代码是第 6 行，具体实现如下： 12345678910void performComplete(BitmapHunter hunter) &#123; if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; hunterMap.remove(hunter.getKey()); batch(hunter); if (hunter.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), \"for completion\"); &#125;&#125; 根据发送请求设置的内存缓存策略判断是否将其结果写入到内存中，并通过 key 从 hunterMap 移除 hunter，最后再对 hunter 作出处理，即 第 6 行代码，具体实现如下： 123456789private void batch(BitmapHunter hunter) &#123; if (hunter.isCancelled()) &#123; return; &#125; batch.add(hunter); if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123; handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY); &#125; &#125; 看第 7 行代码，同时采用 Handler 消息机制发送消息，跟上面一样。最终会转到 Dispatcher 类 performBatchComplete() 方法，具体实现如下： 123456void performBatchComplete() &#123; List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);&#125; 核心代码是第 4 行，同样才 Handler 消息机制发送消息，但是此时与之上有所不一样，即 mainThreadHandler 所在线程是主线程，也就是说，此时将任务从子线程切换到主线程，以便可以进行 UI 更新操作，那么赶快来看下在主线程是如何实现的？代码如下： 12345678910111213141516@Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; case HUNTER_BATCH_COMPLETE: @SuppressWarnings(\"unchecked\") List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = batch.size(); i &lt; n; i++) &#123; BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); &#125; break; default: throw new AssertionError(\"Unknown handler message received: \" + msg.what); &#125;&#125; 根据获取到 BitmapHunter 列表大小依次调用 Picasso 中 complete(BitmapHunter) 方法，那么又是怎样实现的呢，代码如下： 1234567891011121314151617181920212223242526272829303132void complete(BitmapHunter hunter) &#123; Action single = hunter.getAction(); List&lt;Action&gt; joined = hunter.getActions(); boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty(); boolean shouldDeliver = single != null || hasMultiple; if (!shouldDeliver) &#123; return; &#125; Uri uri = hunter.getData().uri; Exception exception = hunter.getException(); Bitmap result = hunter.getResult(); LoadedFrom from = hunter.getLoadedFrom(); if (single != null) &#123; deliverAction(result, from, single); &#125; if (hasMultiple) &#123; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = joined.size(); i &lt; n; i++) &#123; Action join = joined.get(i); deliverAction(result, from, join); &#125; &#125; if (listener != null &amp;&amp; exception != null) &#123; listener.onImageLoadFailed(this, uri, exception); &#125;&#125; 从 hunter 获取单个 action、合并 actions 以及其它信息，比如 uri、exception 等。如果获取到的 action 不为空，则派发 action，即第 18 行代码，具体实现如下： 12345678910111213141516171819202122private void deliverAction(Bitmap result, LoadedFrom from, Action action) &#123; if (action.isCancelled()) &#123; return; &#125; if (!action.willReplay()) &#123; targetToAction.remove(action.getTarget()); &#125; if (result != null) &#123; if (from == null) &#123; throw new AssertionError(\"LoadedFrom cannot be null.\"); &#125; action.complete(result, from); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), \"from \" + from); &#125; &#125; else &#123; action.error(); if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_ERRORED, action.request.logId()); &#125; &#125;&#125; 从以上代码可以清晰地看出，根据 result 是否为空分别调用 Action 的回调方法，即 complete() 与 error()。先来看下 complete() 具体实现： 1234567891011121314151617181920@Overridepublic void complete(Bitmap result, Picasso.LoadedFrom from) &#123; if (result == null) &#123; throw new AssertionError( String.format(\"Attempted to complete action with no result!\\n%s\", this)); &#125; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; Context context = picasso.context; boolean indicatorsEnabled = picasso.indicatorsEnabled; PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled); if (callback != null) &#123; callback.onSuccess(); &#125;&#125; 逻辑很简单，前部分主要是做一些检查操作，真正核心代码是第 15 行代码，即将下载获取到的图片渲染到 UI 上，意味着成功地加载一张图片。那么 error() 方法又做了什么操作呢？具体实现如下： 123456789101112131415public void error() &#123; ImageView target = this.target.get(); if (target == null) &#123; return; &#125; if (errorResId != 0) &#123; target.setImageResource(errorResId); &#125; else if (errorDrawable != null) &#123; target.setImageDrawable(errorDrawable); &#125; if (callback != null) &#123; callback.onError(); &#125;&#125; 逻辑也很简单，如果我们有设置错误时显示图片的话，该方法就将错误时显示图片渲染出来。 那么这是单个 action 的处理逻辑，如果有合并 actions 的，执行的逻辑也一样，即对其进行遍历，获取单个 action，再派发 action，实现的代码在 complete(BitmapHunter) 方法第 21 - 27 行。 好吧， 使用 Picasso 开源框架成功加载一张图片的具体流程大概就这样了。由于自己能力水平有限，在讲解过程中难免有错误，如果您看到了，欢迎指正出来，大家一起学习，共同进步 ！！！ 参考资料http://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"优秀开源框架","slug":"优秀开源框架","permalink":"https://panzeyong.github.io/tags/优秀开源框架/"}]},{"title":"JobScheduler 用法","slug":"JobScheduler-用法","date":"2017-05-21T04:28:37.000Z","updated":"2017-06-19T14:49:53.000Z","comments":true,"path":"2017/05/21/JobScheduler-用法/","link":"","permalink":"https://panzeyong.github.io/2017/05/21/JobScheduler-用法/","excerpt":"","text":"背景先来聊聊怎么会知道 JobSchduler 这神奇的东西。公司项目有这么一个需求：平板上实时记录小朋友的学习情况，然后生成学习报告上传到服务器，供手机端查看。原先的做法是开启服务，在服务里注册广播接收器，当广播接收器接收到 action，就会将数据上传，在网络正常的情况下，该做法是没有问题的；但是当网络很差的情况下，有可能造成上传失败，数据丢失。后来我采用一种方式：当上传失败时，开启定时器上传，直到成功为止。原本以为这样就解决问题，可是后来做后台的同事说由于设置时间短，访问量多，造成服务器流量过大，希望我能找另外一种解决方法。这时 Leader 跟我说采用 JobScheduler，它完全有系统控制，满足一定的条件时触发任务。于是我马上 Google，看看这玩意到底是啥？经过搜索一番，发现 JobScheduler 功能挺强大的。下面是自己学习 JobSchduler 小结。 JobScheduler 是在 Android 5.0 Google 推出的一个新组件，它的出现主要是为了解决某些任务需要在满足一个或多个条件的情况下才触发的需求，这些条件比如网络状态、电池充电、数据变化、自己设定的条件等，在满足条件时会触发相应的 JobScheduler 完成相应的任务。这个过程只需我们对要执行的任务设定条件，其它都由系统控制完成的，无需我们去控制任务。在学习 JobScheduler 的用法之前，先来了解相关的 API，这里涉及到 JobScheduler、JobInfo、JobParameters、JobService 这四个类。 API 讲解JobScheduler先来看下官方文档对 JobScheduler 的描述： 根据应用程序自己的进程中调度各种类型的任务。 关于可以运行的任务类型以及如何构建它们的更多描述，请参阅 JobInfo。你将构建这些 JobInfo 对象,并调用 JobScheduler 方法 schdule(JonInfo)) 将这些 JobInfo 对象传给它。当设定的条件满足时，系统将会在你应用程序 JobService 上执行相应的任务。当你使用 JobInfo.Builder(int, android.content.ComponentName)) 创建你的 JobInfo 时，意味着已经确定哪个 JobService 将执行你的任务逻辑。 框架对于你接收回调的时机很智能的，并且尝试尽可能地分批处理和延迟它们。通常来说，如果你没有为你的任务设置最后期限，那么就会根据 JobScheduler 内部队列当前的状态在任何时刻来执行它们；可是只要到下一次设备连接电源，那么任务就有可能被延迟。 你不能直接实例化 JobScheduler，而是需要通过 Context.getSystemService(Context.JOB_SCHEDULER_SERVICE)) 获取实例。 从官方文档可以知道，JobScheduler 的职责是调度任务、取消任务。JobScheduler 提供 2 个常量和 5 个方法，在了解它们之前，先来了解如何获取 JobScheduler 实例。正如官方文档所介绍的，通过获取系统服务来获取的，代码如下： 1JobScheduler jobScheduler = (JobScheduler) Context.getSystemService(Context.JOB_SCHEDULER_SERVICE); 接下来来了解两个常量的具体含义 RESULT_FAILURE：调度任务失败时返回值。 RESULT_SUCCESS：调度任务成功时返回值。 JobScheduler 提供 5 个方法供我们使用，让我们来了解下这 5 个方法的具体用法 cancel(int jobId)：取消 JobScheduler 内部队列 id 为 jobId 待处理任务。 cancelAll()：取消在这个应用程序上 JobScheduler 已经注册的所有任务。 getAllPendingJobs()：检索 JobScheduler 待处理所有任务。 getPendingJob(int jobId)：检索 JobScheduler 内部队列 id 为 jobId 待处理任务。 schedule(JobInfo job)：调度任务。 JobInfoJobInfo 对一个即将被执行的任务的信息进行封装，然后供 JobScheduler 调度。由于 JobInfo 包含的信息比较多，所有采用建造者模式来构建其实例，即 JobInfo.Builder 来创建。 来看下官方文档的描述： 将要调度的任务所需的参数（信息）封装为 JobInfo 对象传递给 JobScheduler。使用 JobInfo.Builder) 创建 JobInfo 实例。当你正在创建 JobInfo 对象时，你必须至少指定一项约束条件。这样做的目标是为你想完成的任务提供优先级高调度。如果你没有指定任何一项约束时，你的 app 会抛出异常。 那么来看下如何创建 JobInfo 实例 123JobInfo.Builder builder = new JobInfo.Builder(jobId, componentName);builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY);JobInfo jobInfo = builder.build(); 由于创建 JobInfo 对象时至少指定一项约束条件，所以以上只是指定请求网络类型，至于其它属性可以根据自己的需求指定。那么 JobInfo 到底有哪些属性呢？下面一一揭晓。 先来看下 JobInfo 提供常量： BACKOFF_POLICY_EXPONENTIAL：退避策略，任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：退避策略，任务失败时等待间隔呈线性增长。 DEFAULT_INITIAL_BACKOFF_MILLIS：默认情况下任务的 backoff，以毫秒为单位。 MAX_BACKOFF_DELAY_MILLIS：允许任务最大 backoff，以毫秒为单位。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NONE：默认值，没联网。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 JobInfo 设置属性的方法由 JobInfo.Builder，那么来看下提供哪些方法设置属性 setRequiredNetworkType (int networkType)：设置网络类型。如果任务需要通过网络访问服务器，但是没有调用该方法设置网络类型时，那么任务不会被执行。提供四个参数可以设置： NETWORK_TYPE_NONE：默认值，不连接网络。 NETWORK_TYPE_ANY：连接任何网络。 NETWORK_TYPE_NOT_ROAMING：连接非漫游网络。 NETWORK_TYPE_UNMETERED：连接非计量网络。 setRequiresCharging (boolean requiresCharging)：设置是否连接电源，默认值为 false。 setRequiresDeviceIdle (boolean requiresDeviceIdle)：设置是否需要设备处于空闲模式，默认值为 false。空闲模式是系统提供的一种松散模式，意味着设备没有在使用或者已经有一段时间没有使用，这正是执行繁重任务的好时机。 addTriggerContentUri (JobInfo.TriggerContentUri uri)：API 24 支持使用 content provider 变化作为触发任务执行的时机。需要指定触发 URL，并通过 ContentObserver 监听 content provider 变化，从而触发任务的执行。注意设置该属性后，不能设置 setPeriodic(long) 或者 setPersisted(boolean) 属性，也就是说不能与他们任何一个一起使用。因为他们之间是不兼容的，如果一起使用的话，当 build() 被调用时，会抛出 IllegalArgumentException 异常。为了持续监听 content 变化，需要在 JobService 完成最近变化执行的任务之前，调用新的 JobInfo 观察相同的 URL。 setTriggerContentMaxDelay (long durationMs)：设置当第一次监听到 content 变化到任务执行时可以延迟的最大时间，以毫秒为单位。 setTriggerContentUpdateDelay (long durationMs)：设置当监听到 content 变化时到任务执行时可以延迟的时间，如果在这期间监听到更多变化，那么延迟时间的计时将被重置到最近一次更改开始。 setBackoffCriteria (long initialBackoffMillis, int backoffPolicy)：设置 back-off 或者 重试策略。注意尝试调用 setRequiresDeviceIdle(boolean) 为任务设置回退策略时，当 build() 被调用时会抛出异常。因为 back-off 对这些工作类型没意义。 第一个参数表示第一次失败时尝试的时间间隔，单位为毫秒，预设的参数有： DEFAULT_INITIAL_BACKOFF_MILLIS：30000 MAX_BACKOFF_DELAY_MILLIS：18000000 第二个参数表示退避策略 BACKOFF_POLICY_EXPONENTIAL：任务失败时等待间隔呈指数增长。 BACKOFF_POLICY_LINEAR：任务失败时等待间隔呈线性增长。 setMinimumLatency (long minLatencyMillis)：指定任务延迟执行时间。 setOverrideDeadline (long maxExecutionDelayMillis)：设置任务执行最大的延迟时间。即使到了时间期限，条件还没满足，任务也会被执行。 setPeriodic (long intervalMillis)：指定任务在一定的周期内执行，并且每一个任务在周期内只执行一次。调用该方法设置后，不能再调用 setMinimumLatency (long minLatencyMillis) 或者 setOverrideDeadline (long maxExecutionDelayMillis) 方法，否则会抛出异常。 setPersisted (boolean isPersisted)：设置当设备重启，任务是否被重新调度。如果设置 true，必须申请权限 RECEIVE_BOOT_COMPLETED，否则运行时会报错。 setExtras (PersistableBundle extras)：设置额外参数，值允许原始数据类型。 JobServiceJobScheduler 所要调度的任务是在 JobService 定义的，而 JobService 是继承 Service；也就是说，JobService 也是服务，只是它与四大组件之一 Service 有所区别。JobService 有一大特点是无论你的 app 是否处于活跃状态，当你的任务满足特定的条件时，系统都会执行任务。我们可以编写多个 JobServices，而且每个 JobService 指定不同的任务，每个任务在某个时间点被执行。 来看下官方文档的描述 JobScheduler 回调的入口点。 JobService 是处理之前调度的异步请求的基类。你应该重写 onStartJob (JobParameters params)) 方法，将在该方法实现你的任务逻辑。 此服务运行在应用程序主线程处理传入的任务。这意味着你必须将执行逻辑放到子线程、handler、AsyncTask。如果不这样做的话会阻塞 JobManager 的回调，特别是 onStopJob(android.app.job.JobParameters))，这意味着将通知你不满足调度要求。 那么该如何实现 JobService 呢？必须创建一个新类，继承 JobService，并重写方法 onStartJob(JobParameters) 和 onStopJob(android.app.job.JobParameters)。下面给出一个模板： 123456789101112public class JobSchedulerService extends JobService &#123; @Override public boolean onStartJob(JobParameters params) &#123; return false; &#125; @Override public boolean onStopJob(JobParameters params) &#123; return false; &#125;&#125; 从以上可知，两个方法都返回 boolean 值，那么什么时候返回 true，什么时候返回 false 呢，返回值对 JobScheduler 任务调度又有什么影响呢？下面一一来解析： onStartJob(JobParameters)：在此方法实现任务的逻辑。由于 JobService 是在主线程运行，因此对于逻辑简单的可以直接写在该方法里，但是对于比较复杂任务，例如网络请求，那么就要开启子线程来操作，以免造成阻塞。当任务完成的时候返回 false，作用是通知系统任务已经完成；当有任务要执行的话返回 true，作用是让系统知道有任务即将执行或正在执行，并对该任务持有锁。因为任务一旦完成并通知系统，系统就释放持有该任务锁。 onStopJob (JobParameters params)：当任务未完成调用 jobFinished(JobParameters, boolean)) 取消任务时，此方法就会被调用。发生这种现象的原因大部分是调度的任务不满足所指定的条件，导致系统无法执行任务。当任务停止时，如果还想系统重新调度任务的话，那么返回 true；反之返回 false，此时系统会移除任务，导致所要调度的任务必须暂停。 除此之外，JobService 还提供了 jobFinished(JobParameters, boolean)) 这个方法，虽然不用重写该方法，但是该方法却有很大的作用。此回调方法用来通知 JobManager 任务已经完成。由于此方法最终在主线程调用，因此可以在任何线程调用该方法。当系统收到信息时，就会释放持有该任务锁。当 onStartJob(JobParameters) 返回 true，即表示任务正在执行或要被执行，在任务执行完成后需要调用 jobFinished(JobParameters, boolean) 方法来通知系统任务已经完成，此时系统才可以安全地释放持有该任务锁。如果忘记调用该方法的话，应用中其它任务就不会被执行。 jobFinished(JobParameters, boolean) 需要传入两个参数：第一个参数 JobParameters 表示当前任务的信息，以至于任务完成时系统知道释放哪个锁；第二个参数是 boolean 值，true 表示根据退避策略（back-off criteria）重新调度任务；false 则表示不调度任务。 跟四大组件之一 service 一样，都需要在 AndroidManifest.xml 声明，但是有一点不同的是需要添加权限 android:permission=”android.permission.BIND_JOB_SERVICE” 123&lt;service android:permission=\"android.permission.BIND_JOB_SERVICE\" android:name=\".service.JobSchedulerService\" &gt; JobParameters来看下官方文档描述 JobParameters 对任务的信息进行封装，当任务被调度时，系统就会创建该对象，包含任务的信息；自己是无法实例化该对象的。 PS：自己觉得是与 JobInfo 对应的，JobInfo 是设置属性，而 JobParameters 是获取相应属性。 那么来看下 JobParameters 提供的方法，只列出部分： getJobId ()：获取每个任务独一无二的 id。 getExtras ()：获取额外参数。 了解 API 之后，接下来的任务是学习 JobScheduler 用法。 JobScheduler 用法对于 JobScheduler 的用法，我打算用项目中使用到 JobScheduler 作为例子，前提是移除了业务逻辑，代码可能不太完整。换句话说吧，给个模板吧。 先给出例子，再来分步讲解吧。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class JobSchedulerService extends JobService &#123; private static final String TAG = JobSchedulerService.class.getCanonicalName(); public final static String TASK = \"com.demo.panju.task\"; private final static int JOB_ID = 1; private static ComponentName mComponentName; private static JobScheduler mJobScheduler; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what) &#123; case 1； task(); break; default: break; &#125; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mReceiver = new Receiver(); mFilter = new IntentFilter(); mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); registerReceiver(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; sendMessage(params); return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; mHandler.removeMessages(1)); return false; &#125; @Override public void onLowMemory() &#123; super.onLowMemory(); stopSelf(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (null != mReceiver) &#123; unregisterReceiver(mReceiver); mReceiver = null; &#125; &#125; private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; private void sendMessage(JobParameters parameters) &#123; Message message = mHandler.obtainMessage(); message.what = 1; message.obj = parameters; mHandler.sendMessage(message); &#125; private void registerReceiver() &#123; mFilter.addAction(TASK); registerReceiver(mReceiver, mFilter); &#125; private void task() &#123; mApi.task(new Callback() &#123;&#125; @Override public void onSuccess(Object result) &#123; jobFinished(mJobParameters, false); &#125; @Override public void onError(Object e, int errno) &#123; jobFinished(mJobParameters, true); &#125; &#125;); &#125; private class Receiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (TASK.equals(action)) &#123; scheduleJob(JOB_ID); &#125; &#125; &#125; &#125; 以上例子应该不难理解，接下来分步讲解： 创建新类 JobSchedulerService 并继承 Service，重写方法 onStartJob(JobParameters params) 和 onStopJob(JobParameters params)。onStartJob(JobParameters params) 返回 true 表示任务将被执行；onStopJob(JobParameters params) 返回 false 表示当任务中途被取消而导致暂停任务，系统将会移除任务。 创建 JobScheduler 和 ComponentName 对象 12mComponentName = new ComponentName(getPackageName(), JobSchedulerService.class.getName()); mJobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); 对调度任务所需要的属性进行封装 1234567private static void scheduleJob(int jobId) &#123; JobInfo.Builder builder = new JobInfo.Builder(jobId, mComponentName); builder.setPersisted(true); builder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY); builder.setOverrideDeadline(500); mJobScheduler.schedule(builder.build()); &#125; 编写广播接收器、注册接收器、重写 Handler 回调方法 handleMessage(Message msg) 并实现相应逻辑。 当注册的广播接收器收到相应 action 时，就会调用方法 scheduleJob(JOB_ID)，即调度任务，那么方法 onStartJob(JobParameters params) 就会被调用，在该方法里通过 Handler 机制发送消息，Handler 的回调方法 handleMessage(Message msg) 就会被调用，实现的逻辑主要是发起网络请求，即 task() 方法。task() 方法逻辑中有两个回调方法：onSuccess(Object result) 和 onError(Object e, int errno)。发起网络请求成功的话就会调用方法 onSuccess(Object result)，在该方法里又调用 jobFinished(mJobParameters, false)，传入的 boolean 值是 false，意味着任务已经成功完成，无需重新调度任务；发起网络请求失败的话就会调用 onError(Object e, int errno)，在该方法里又会调用 jobFinished(mJobParameters, true)，传入的 boolean 值是 true，意味着任务失败，根据重试策略重新调度任务。 由于自己的水平有限，若有些地方描述的不对或者翻译的不恰当（参考官方文档和国外博客），欢迎指出 ！ 大家一起学习，共同进步 ！ 参考链接官方文档 https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129 http://josiassena.com/the-jobscheduler-on-android/ http://blog.csdn.net/bboyfeiyu/article/details/44809395 http://zhanghuimin.com/2016/10/27/about-android-job-scheduler/ http://mahong978.top/2016/08/19/android-job-scheduler/","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://panzeyong.github.io/tags/性能优化/"}]},{"title":"第二章 在 HTML 中使用 JavaScript","slug":"第二章-在-HTML-中使用-JavaScript","date":"2017-05-03T23:40:59.000Z","updated":"2017-06-19T15:25:28.000Z","comments":true,"path":"2017/05/04/第二章-在-HTML-中使用-JavaScript/","link":"","permalink":"https://panzeyong.github.io/2017/05/04/第二章-在-HTML-中使用-JavaScript/","excerpt":"","text":"标签script：表示向 HTML 页面插入 JavaScript。该元素定义 6 个属性： async：可选。表示应该立即下载脚本，但不应妨碍页面中的其它内容加载。只对外部脚本文件有效。标记为 async 的脚本并不能保证按照指定的的先后顺序执行，一定会在页面的 load 事件前执行，但是对于 DOMContentLoaded 事件就不一定了。建议异步脚本不要在加载期间修改 DOM。 charset：可选。表示通过 src 属性指定的代码的字符集。 defer：可选。表示所要加载的脚本可以延迟到文档完全被解析和显示之后再执行，即遇到 html 标签之后才执行；只对外部脚本文件有效。HTML 5 规范要求延迟脚本是按照出现的顺序执行的，并且先于 DOMContentLoaded 事件，但是现实是不一定的，因此最好只包含一个延迟脚本。 language：已经废弃。 src：可选。表示包含要执行代码的外部文件。 type：可选。language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME 类型）。通常的默认值为 text/javascript。 noscript：在不支持 JavaScript 的浏览器中显示替代的内容。 123&lt;noscript&gt; &lt;p&gt;本页面需要浏览器支持（启用）JavaScript&lt;/p&gt;&lt;/noscript&gt; 注意点 解释器对 script 元素内代码的解析是从上往下，在该元素内的代码被解析完之前，页面其它内容是不会被浏览器加载或者显示的。（外部文件也一样） 通过 src 属性引入外部文件必须要包含开始的 script 和结束的 script，只是 HTML 规范。 1&lt;script type=\"text/javasript\" src=\"example.js\"&gt;&lt;/script&gt; 带有 src 属性的 script 元素不应该在其元素之间包含额外的 JavaScritp 代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 JavaScript 代码建议放在 body 元素中页面内容之后 以上是在学习 《JavaScript 高级程序设计》（第 3 版）这本书第二章的学习笔记，主要把书中讲到的要点记录下来，方便自己查找。","raw":null,"content":null,"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://panzeyong.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 高级程序设计》学习笔记","slug":"JavaScript-高级程序设计》学习笔记","permalink":"https://panzeyong.github.io/tags/JavaScript-高级程序设计》学习笔记/"}]},{"title":"AsnycTask 用法及源码解析","slug":"AsnycTask-用法及源码解析","date":"2017-05-01T09:49:39.000Z","updated":"2017-06-19T14:44:13.000Z","comments":true,"path":"2017/05/01/AsnycTask-用法及源码解析/","link":"","permalink":"https://panzeyong.github.io/2017/05/01/AsnycTask-用法及源码解析/","excerpt":"","text":"AsyncTask 是一种轻量级异步任务类，可以在线程池执行后台任务，获取到的结果传递给主线程并且在主线程中更新 UI。AsyncTask 比较适合执行短时间任务，对于长时间任务推荐使用 Executor，ThreadPoolExecutor 和 FutureTask。 AsyncTask 是一个抽象类，提供三个泛型参数，分别是 Params，Progress 和 Result；以及 4 个步骤：onPreExecute，doInBackground，onProgressUpdate 和 onPostExecute。 AsyncTask 三个泛型参数 Params：发送给执行任务的参数类型。 Progress：执行后台任务进度的类型。 Result：执行完后台任务返回的结果类型。 AsyncTask 四个核心方法 onPreExecute()：在任务执行之前调用，主线程执行；主要做一些初始化工作，比如在用户界面展示进度条。 doInBackground(Params…)：onPreExecute() 执行完成后被调用，在线程池执行；所有的异步操作都在这个方法执行，执行结果被返回时，onPostExecute(Result) 会被调用。如果在该方法中调用 publishProgress(Progress…)，那么方法 onProgressUpdate(Progress…) 也会被调用，主要用于更新后台任务进度。 onProgressUpdate(Progress…)：publishProgress(Progress…) 执行完之后被调用，在主线程执行；主要在用户界面显示后台任务执行进度。 onPostExecute(Result)：doInBackground(Params…) 执行完之后调用，在主线程执行；参数 Result 是 doInBackground(Params…) 的返回值。 一个异步任务可以通过调用 cancel(boolean) 随时取消，此时 isCancelled() 被调用，这就导致 doInBackground(Params…) 执行完后 onPostExecute(Result) 不会被调用。 在使用 AsyncTask 的过程中，要注意以下几点： AsyncTask 类必须在 UI 线程加载，Android 4.1 已经自动绑定了。 AsyncTask 实例必须在 UI 线程创建。 execute(Params…) 必须在 UI 线程调用。 不要手动调用 onPreExecute()、onPostExecute(Result)、doInBackground(Params…)、onProgressUpdate(Progress…)。 一个 AsyncTask 对象只能被执行一次；否则会抛异常。 以上是 AsnycTask 基本知识点，掌握知识点后就要学会如何使用它。那么接下来就来学习 AsyncTask 用法。 AsyncTask 用法AsyncTask 是抽象类，不能直接实例化，必须创建新类并继承它，抽象方法 doInBackground(Params…) 是一定要重写的，其它三个方法根据自己的需求确定。以下通过 URL 获取数据为例子来讲解 AsyncTask 的用法。代码如下： 12345678910111213141516171819public class AsyncTaskExample extends AsyncTask&lt;String, Integer, String&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); mLoad.setVisibility(View.VISIBLE); &#125; @Override protected String doInBackground(String... params) &#123; return getUrlResponse(params[0]); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); mLoad.setVisibility(View.GONE); mText.setText(s); &#125;&#125; 从代码中可以很清晰地看出，第 5 行是显示加载进度条，表示正在获取数据；第 10 行是核心代码，异步操作，网络请求数据并将结果返回；第 16 - 17 行代码主要操作是隐藏进度条，表示数据加载完毕，并将获取到的结果显示出来。这里主要给出核心代码，至于其它代码也就调用而已。 那么该如何调用呢？很简单，一行代码就搞定 1new AsyncTaskExample().execute(url); AsyncTask 源码解析知其然必知其所以然。对于新知识点，学会使用之后，就应该探究其原理。由于个人倾向于通过画图来理解知识点的流程，因此先简单地给出 AsyncTask 任务执行的流程图，再根据流程图和源码进行讲解。流程图如下： 对于源码的理解，一般是以最终调用的方法为入口，一步一步地理解整个流程。那么对于 AsyncTask 该从哪里入手呢？当然是从方法 execute(Params… params) 入手了，代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 对于 AsyncTask 不同版本，execute(Params… params) 方法的执行方式是不一样的。Android 1.6 以前，AsyncTask 是单线程串行执行任务的；Android 1.6，AsyncTask 是线程池多线程并行执行任务；但是到 Android 3.0，AsyncTask 又改为单线程串行执行任务的。该方法的逻辑很简单，直接调用方法 executeOnExecutor(Executor exec, Params… params)，将我们传入的参数 params 和 sDefaultExecutor 传到该方法里，并将的返回值返回。那么来看下该方法的具体实现，代码如下： 12345678910111213141516public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; executeOnExecutor(Executor exec, Params… params) 方法是在线程池 THREAD_POOL_EXECUTOR 执行，允许多任务并发执行，但是不推荐采用多任务并发执行；在主线程执行。该方法实现的主要功能是： 检查任务状态，并记录任务当前状态； 调用 onPreExecute() 方法，根据我们自己的需求可以重写该方法； 将我们传入的参数 params 赋值给 WorkRunnable 中字段 mParams(稍后解释)； 调用 SerialExecutor 中方法 execute(Runnable r) 执行任务。 mWorker 是 WorkerRunnable 实例，而 WorkerRunnable 是抽象类，实现 Callable 接口，并且该接口有一个回调方法 call()；同时抽象类有一个字段 Params []，第 13 行代码就是把我们传进来的参数 params 赋值给它的。mWorker 是在创建 AsyncTask 实例时被初始化的，即 AsyncTask 构造方法里，并重写回调方法 call()，那么接下来看回调方法 call() 的具体实现。 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125;&#125;; 该回调方法实现的主要功能： 将 mTaskInvoked 设置为 true，表示任务已经被调用过； 设置线程优先级为后台线程； 调用 doInBackground(mParams) 方法，异步执行，后台执行的逻辑都写在这个方法里面，一定要被重写；如果任务执行抛出异常时，取消任务； 调用 postResult(result) 方法； postResult(result) 的具体实现如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 从代码里可以看出，将执行结果通过 sHandler 发送 MESSAGE_POST_RESULT 的消息，然后 handleMessage() 方法收到消息后进行相应的处理。sHandler 是 InternalHandler 实例，主要作用是将任务执行的环境从线程切换到主线程中，从 InternalHandler 的具体实现就可以看出了。代码如下： 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 从构造函数 InternalHandler() 就可以看出了，获取主线程 Looper，而 Handler 必须与 Looper 进行绑定，因此可以断定是在主线程里。handleMessage() 函数对两种消息进行处理：MESSAGE_POST_RESULT 和 MESSAGE_POST_PROGRESS；而我们刚刚发送的消息是 MESSAGE_POST_RESULT，那就先来看该消息收到后会做什么处理吧？很显然，调用 finish(Result result)，具体实现如下： 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 如果任务被取消了，直接调用 onCancelled(result) 方法，onPostExecute(result) 方法不会被调用；否则就调用 onPostExecute(result) 方法，该方法需要被重写，在主线程执行，根据返回的结果进行相应的处理；最后修改任务的状态。那么对于消息 MESSAGE_POST_PROGRESS 是从哪里发出来的呢？还记得在前面的知识点讲解中有提到过如果在 doInBackground(mParams) 方法中调用 publishProgress(Progress…) 方法时，方法 onProgressUpdate(Progress…) 也会被调用，用于后台任务进度更新。没错，消息 MESSAGE_POST_PROGRESS 就是用来处理进度更新的。先看下 publishProgress(Progress…) 具体实现： 123456protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 很显然，如果任务没有被取消的话，就会发送消息 MESSAGE_POST_PROGRESS，那么来看下收到该消息后的处理逻辑，即调用 onProgressUpdate(Progress… values) 方法，该方法需要我们根据自己的需求进行重写。 再回到 executeOnExecutor(Executor exec, Params… params) 方法，第 14 行代码开始执行任务，在理解如何执行任务之前，先来理解参数 mFuture 和 sDefaultExecutor 的含义。 mFuture 是 FutureTask 实例，在 AsyncTask 构造方法中初始化。将 mWorker 作为参数传入 FutureTask 构造函数，个人认为传入该参数的作用是由于 FutureTask 中 run() 方法会被调用，而在该方法里会通过传入参数 mWorker 调用 call() 方法，进而使任务得到执行。FutureTask 是一个并发执行任务类，可以执行任务、取消任务、查询结果、获取结果；提交到线程池执行。实现的接口有 Future、Runnable。 对于传入的参数 sDefaultExecutor，究竟是什么啥玩意呢？让我们来探个究竟吧。sDefaultExecutor 是 SerialExecutor 的实例，而 SerialExecutor 实际上是一个串行的线程池，主要的功能是一个进程中所有的 AsyncTask 任务都在这个串行的线程池中排队执行。看到这里，是不是还不知道任务真正在哪里被开始执行？其实以上都只是铺垫，下面才真正拉开序幕。真正开始执行任务的逻辑是在 SerialExecutor 中 execute(Runnable r) 方法里，具体实现如下： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 首先将 AsyncTask 通过线程池 SerialExecutor 添加到队列里（从这里可以看出 SerialExecutor 的作用），然后重写 run() 方法，并判断 mActive 是否为 null，即当前是否有任务在执行，如果有任务执行的话就等待该任务执行完后再执行其他任务，否则就执行任务，即调用 scheduleNext() 方法，该方法的主要功能是从队列 mTasks 获取任务，任务不为空的话就直接提交到线程池 THREAD_POOL_EXECUTOR 里执行（任务真正开始执行），即启动任务，根据个人的理解，任务被启动后，会调用第 6 行代码，即 run() 方法，进而调用 FutureTask 中 run() 方法，从而会调用 WorkerRunnable 中 call() 方法，因此任务被执行，我们重写的方法也会被调用。结合以上流程图应该能更清晰地理解 AsyncTask 执行流程。 以上是自己在学习 《Android 开发艺术探索》 这本书第十一章关于 AsyncTask 这个主题的学习笔记，由于自己能力有限，有错误的地方欢迎指出。 参考资料https://developer.android.com/reference/android/os/AsyncTask.html 《Android 开发艺术探索》》中 第 11 章 Android 的线程和线程池","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/tags/《Android-开发艺术探索》学习笔记/"}]},{"title":"Python 学习笔记：字符串","slug":"Python-学习笔记：字符串","date":"2017-04-17T14:27:28.000Z","updated":"2017-06-19T15:22:47.000Z","comments":true,"path":"2017/04/17/Python-学习笔记：字符串/","link":"","permalink":"https://panzeyong.github.io/2017/04/17/Python-学习笔记：字符串/","excerpt":"","text":"定义：Python 的字符串是一种对象类型，这种类型用 str 表示，通常用双引号 “” 或者单引号 ‘’ 表示。 拼接字符串Python 的字符串是可以拼接，用符号 + 表示；但是与 Java 语言有一点不同的是拼接的两个对象必须是同类型，否则会报错。例子如下： 两个相同类型 str 拼接（正确） 12&gt;&gt;&gt; \"Hello \" + \"Python\"'Hello Python' 两个相同类型 int 拼接（正确） 12&gt;&gt;&gt; 5 + 38 两个不同类型 str 和 int 拼接（错误） 1234&gt;&gt;&gt; \"Python \" + 5Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: Can't convert 'int' object to str implicitly 很显然，对于类型都是 str 将多个对象拼接起来；对于类型都是 int 则执行相加操作；对于不同类型则报错。那么对于不同类型的操作该如何转换呢？解决办法如下： str() 函数 12&gt;&gt;&gt; \"Python \" + str(3)'Python 3' repr() 函数（反引号的替代品） 12&gt;&gt;&gt; \"Python \" + repr(3)'Python 3' str() 与 repr() 区别 str() 将对象转化为可读性好的字符串，适合于 print 输出到终端，其返回值无法用于内建函数 eval。 repr() 返回对象的规范字符串表示形式；对于大多数对象而言，eval（repr（obj））== obj，也就是说，大多数情况下可以通过内建函数 eval 重新获取该对象。 大部分情况下 str() 用于终端输出，eval() 主要用于调试。 字符串格式化输出用于指定输出参数的格式与相对位置的字符串参数。通俗地讲，先定制模板，预留占位符，用对应类型的值填充；常用的占位符有 %s（字符串）、%d（整数）、%f（浮点数）。 以下通过例子说明 12&gt;&gt;&gt; \"I love my %s\" % \"job\" 'I love my job' 在这个字符串中，%s 是一个占位符，可以被其它字符串替换，这里替换的是 “job”。 12&gt;&gt;&gt; \"I'm %d years old\" % 20\"I'm 20 years old\" 不同占位符也可以混合使用，例子如下： 12&gt;&gt;&gt; \"What's your name ? My name is %s and I'm %d years old.\" % (\"John\", 15)\"What's your name ? My name is John and I'm 15 years old.\" 字符串常用方法index(…)：子字符串在整个字符串中的索引，即子字符串中第一个字符的位置。 123&gt;&gt;&gt; string = \"The programming language Python\"&gt;&gt;&gt; string.index(\"Python\")25 isalnum(…)：字符串中所有字符都是字母数字时返回 True，否则 False。 12345678910111213141516&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"199993\"&gt;&gt;&gt; string.isalnum()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalnum()True# 包含空格，并非全是字母数字，所以返回 False&gt;&gt;&gt; string = \"Python 3\"&gt;&gt;&gt; string.isalnum()False isalpha(…)：字符串中所有字符都是字母时返回 True，否则 False。 12345678910111213&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isalpha()True# 包含数字&gt;&gt;&gt; string = \"Python3\"&gt;&gt;&gt; string.isalpha()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.isalpha()False isdecimal(…)：字符串中只有十进制字符时返回 True，否则返回 False。 12345678910111213141516171819202122232425262728293031# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdecimal()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isdecimal()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isdecimal'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdecimal()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdecimal()False# 包含字母&gt;&gt;&gt; string = \"Python1993\"&gt;&gt;&gt; string.isdecimal()False# 包含空格（其它符号也一样，比如 \"\\\"、\"%\"等）&gt;&gt;&gt; string = \"1993 1993\"&gt;&gt;&gt; string.isdecimal()False isdigit(…)：字符串中所有字符都是数字 True，否则返回 False。 1234567891011121314151617181920212223# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isdigit()True# byte数字（单字节）&gt;&gt;&gt; string =b\"1\"&gt;&gt;&gt; string.isdigit()True# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isdigit()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isdigit()False&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isdigit()False isnumeric(…)：字符串中只有数字字符时返回 True，否则返回 False。 123456789101112131415161718192021# Unicode 数字&gt;&gt;&gt; string = \"1\"&gt;&gt;&gt; string.isnumeric()True# byte数字（单字节）&gt;&gt;&gt; string = b\"1\"&gt;&gt;&gt; string.isnumeric()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'bytes' object has no attribute 'isnumeric'# 全角数字（双字节)&gt;&gt;&gt; string =\"1\"&gt;&gt;&gt; string.isnumeric()True# 汉字数字&gt;&gt;&gt; string = \"五\"&gt;&gt;&gt; string.isnumeric()True 提示：isdecimal()、isdigit()、isnumeric() 三个函数区别如上。 islower(…)：字符串中所有字符都是小写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"python\"&gt;&gt;&gt; string.islower()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.islower()False isupper(…)：字符串中所有字符都是大写时返回 True，否则返回 False。 1234567&gt;&gt;&gt; string = \"PYTHON\"&gt;&gt;&gt; string.isupper()True&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string.isupper()False join(…)：将序列中的元素以指定的字符连接成生成新的字符串。 123456789&gt;&gt;&gt; string = \"-\" # 指定的字符&gt;&gt;&gt; seq = \"Hello,Python\" # 序列&gt;&gt;&gt; string.join(seq)'H-e-l-l-o-,-P-y-t-h-o-n'&gt;&gt;&gt; string = \"-\"&gt;&gt;&gt; seq = ['Python', 'PHP']&gt;&gt;&gt; string.join(seq)'Python-PHP' lower(…)：返回字符串的副本并将其转换为小写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.lower()'welcome to python world !' upper(…)：返回字符串的副本并将其转换为大写。 123&gt;&gt;&gt; string = \"Welcome to Python World !\"&gt;&gt;&gt; string.upper()'WELCOME TO PYTHON WORLD !' capitalize(…)：字符串中首字母大写，其它都是小写。 123&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.capitalize()'Hello python' istitle(…)：字符串中所有单词的首字母大写，其它小写时返回 True，否则返回 False。 123456789101112131415&gt;&gt;&gt; string = \"Hello Python\"&gt;&gt;&gt; string.istitle()True&gt;&gt;&gt; string = \"hello Python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"hello python\"&gt;&gt;&gt; string.istitle()False&gt;&gt;&gt; string = \"HELLO PYTHON\"&gt;&gt;&gt; string.istitle()False split(…）：根据分隔符对字符串进行分割，返回列表。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string.split()['I', 'love', 'Python', '!'] strip(…)：去掉字符串左右空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.strip()'I love Python !' lstrip(…)：去掉字符串左边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.lstrip()'I love Python ! ' rstrip(…)：去掉字符串右边空格。 123&gt;&gt;&gt; string = \" I love Python ! \"&gt;&gt;&gt; string.rstrip()&gt;&gt;&gt; ' I love Python !' len(…)：返回序列（字符串）的长度。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; len(string)15 in：判断字符串是否包含某个字符或子字符串，包含的话返回 True；否则返回 False。（区分大小写） 1234567&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"python\" in stringFalse&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; \"Python\" in stringTrue max：根据 ASCII 编码，求出字符串中最大值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; max(string)'y' min：根据 ASCII 编码，求出字符串中最小值。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; min(string)' ' 索引与切片与其它编程一样，在 Python 中的字符串也可以通过索引获取相应的字符，唯一的区别是获取的方式不一样。在 Python 中，字符串是一种序列，以一种数组的形式存在，可以通过下标获取。最直接的方式还是通过例子来说明吧。 123&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[7]'P' 这种形式很类似 Java 语言中数组，但是 Java 语言中通过索引获取字符串中某个字符是通过调用 charAt(index) 方法获取到；获取子字符串是通过调用 subString(start, end) 方法，但是在 Python 获取子字符串称为切片，获取方式跟字符类似。例子如下： 1234# 得到从字符串索引为 2 到 7 的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:8]'love P' 1234得到从字符串索引为 2 到末尾的子字符串。&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[2:]'love Python !' 1234# 获取全部字符&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:]'I love Python !' 1234# 获取从第一个字符到 9 之前的字符串&gt;&gt;&gt; string = \"I love Python !\"&gt;&gt;&gt; string[:9]'I love Py' 从以上例子可以看出字符串切片的使用用法，以下做下简单的总结： [a : b]：表示从索引为 a 起到索引 b 之前字符串。 [:a]：从第一个字符到索引 a 之前的所有字符串。 [a : ]：表示从索引为 a 到末尾字符串。 [:]：表示原始字符串，但不是复制一份，只是两个变量指向同一个对象。 以上只是最近在学 Python 中字符串的小结，也可以说是学习笔记，方便以后查找。（基于 Python3） 参考资料http://docs.pythontab.com/learnpython/106/","raw":null,"content":null,"categories":[{"name":"Python","slug":"Python","permalink":"https://panzeyong.github.io/categories/Python/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://panzeyong.github.io/tags/学习笔记/"}]},{"title":"第一章 Activity 的生命周期和启动模式","slug":"第一章-Activity-的生命周期和启动模式","date":"2017-03-26T08:41:15.000Z","updated":"2017-06-19T14:43:39.000Z","comments":true,"path":"2017/03/26/第一章-Activity-的生命周期和启动模式/","link":"","permalink":"https://panzeyong.github.io/2017/03/26/第一章-Activity-的生命周期和启动模式/","excerpt":"","text":"Activity 正常情况下生命周期 生命周期方法分析 onCreate()：Activity 创建时调用，可以做一些初始化工作。 onRestart()：Activity 正在重新启动，由不可见状态变为可见状态。 onStart()：Activity 正在被启动，这时已经处于可见状态，但是还没出现在前台，而是在后台，无法与用户交互。 onResume()：Activity 已经处于可见状态，并且出现在前台。 onPause()：Activity 暂停，位于后台，可以做一些存储数据、停止动画等工作，但是不能太耗时。 onStop()：Activity 停止，不可见状态，可以做一些资源回收工作，但不能太耗时。 onDestroy()：Activity 销毁，可以做一些回收工作和资源释放。 Activity 生命周期方法不同情况下调用 Activity 第一次启动：onCreate() —&gt; onStart() —&gt; onResume()。 打开新的 Activity 或者切换到桌面：onPause() —&gt; onStop()。 回到原来 Activity：onRestart() —&gt; onStart() —&gt; onResume()。 按 back 键：onPause() —&gt; onStop() —&gt; onDestroy()。 注意（提示、问题） onCreate() 与 onDestroy() 是配对的，表示 Activity 的创建和销毁,并且只有可能一次调用。 onStart() 与 onStop() 是配对的，从是否可见这个角度来回调。 onResume() 与 onPause() 是配对的，从是否位于前台这个角度来回调。 如果新 Activity 采用了透明主题，那么当前 Activity 不会回到 onStop()（原因：处于可见状态，但是失去焦点，无法与用户进行交互）。 假设当前 Activity A，用户打开新的 Activity B，此时 A 的 onPause() 先调用，再调用 B 的 onResume()。 Activity异常情况下生命周期 系统配置发生改变导致 Activity 被杀死并重新创建 系统配置文件发生改变时，Activity 会被重新创建，生命周期方法调用顺序 onPause() —&gt; onSaveInstanceState() —&gt; onStop() —&gt; onDestroy() —&gt; onCreate() —&gt; onStart() —&gt; onRestoreInstanceState() —&gt; onResume()。 Activity 被异常终止情况下，onSaveInstanceState() 方法才会被调用，正常情况下是不会的；该方法调用时机是在 onStop() 之前，至于在 onPause() 之前或者之后并不确定。 Activity 被异常终止情况下，Activity 会被重建，此时 onRestoreInstanceState() 会被调用，调用时机在 onStart() 之后。 onCreate() 与 onRestoreInstanceState() 区别：onRestoreInstanceState() 一旦被调用，其参数 savedInstanceState 一定是有值的，不用判断是否为空；但 onCreate() 不一样，如果是正常启动时，其参数 savedInstanceState 为 null，所以需要额外判空。 可以通过设置android:configChanges属性让屏幕旋转时不重新创建。 资源内存不足导致低优先级的 Activity 被杀死 前台 Activity：正在和用户交互的 Activity，优先级最高。 可见但非前台 Activity：可见但是位于后台无法与用户进行交互，优先级次之。 后台 Activity：优先级最低。 Activity四种启动模式 启动模式 standard：标准模式，这也是系统默认模式。每当启动一个 Activity 创建一个实例，谁启动谁就在谁任务栈。 singleTop：栈顶复用模式。如果新 Activity 已经位于任务栈栈顶，那么此 Activity 不会被创建，同时 onNewIntent() 方法被调用，随后 onResume() 方法也被调用；反之则会重新创建 Activity。 singleTask：栈内复用模式，这是一种实例模式。 singleInstance：单实例模式，singleTask 加强版。Activity 启动时，系统会单独为其创建任务栈，然后此 Activity 就在这个任务栈中，后续跟 singleTask 相同。 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK：为 Activity 指定 singleTask 启动模式。 FLAG_ACTIVITY_SINGLE_TOP：为 Activity 指定 singleTop 启动模式。 FLAG_ACTIVITY_CLEAR_TOP：与 singleTask 启动模式异同出现，作用相同。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有该标记的 Activity 不会出现在历史 Activity 列表中。 注意点 TaskAffinity 属性主要和 singleTask 启动模式或者 allowTaskReparenting 属性配对使用才起作用，其它情况下没用。 TaskAffinity 与 singleTask 启动模式配对使用时，此时 Activity 运行 TaskAffinity 属性所指定的任务栈。 TaskAffinity 与 allowTaskReparenting 配对使用时，情况比较复杂，会产生特殊效果。 IntentFilter 匹配规则 action 的匹配规则 匹配规则：Intent 中的 action 必须能够和过滤规则中的任何一个action 匹配。 区分大小写。 注意与 category 匹配规则不一样。 category 的匹配规则 匹配规则：Intent 所包含的 category 必须与过滤规则中的任何一个 category 相同（可理解为一对一关系）。 特殊情况是 Intent 可以没有 category，但是系统默认会加上android.intent.category.DEFAULT，这也是隐式调用所要求的。 data 匹配规则 data 的结构 android:scheme：URI 模式，比如 http、file、content 等。 android:port：URI 中的端口号，需要指定 scheme 和 host 才有作用。 android:host：URI 主机名。 android:path：完整的路径。 android:pathPattern：完整的路径信息，也可以包含通配符 *。 android:pathPrefix：路径的前缀信息。 android:mimeType：媒体类型。 匹配规则：Intent 包含的 data 数据必须与过滤规则中某一个匹配（Intent 是过滤规则的子集），与 action 类似。 过滤规则有默认URI值：content 和 file。 注意点 判断是否能匹配隐式 Intent 方法 调用 PackageManager 的 resolveActivity 方法。 Intent 的 resolveActivity 方法。 PackageManager 中 queryIntentActivies 方法。","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"https://panzeyong.github.io/categories/Android/"}],"tags":[{"name":"《Android 开发艺术探索》学习笔记","slug":"《Android-开发艺术探索》学习笔记","permalink":"https://panzeyong.github.io/tags/《Android-开发艺术探索》学习笔记/"}]}]}