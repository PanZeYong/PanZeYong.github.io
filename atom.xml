<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PANJU&#39;s Note</title>
  <subtitle>故不积跬步，无以至千里；不积小流，无以成江海。</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://panzeyong.com/"/>
  <updated>2020-09-04T15:13:43.179Z</updated>
  <id>http://panzeyong.com/</id>
  
  <author>
    <name>PANJU</name>
    <email>04120513panzeyong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>createComponent 实现原理</title>
    <link href="http://panzeyong.com/2020/09/02/createComponent-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/09/02/createComponent-实现原理/</id>
    <published>2020-09-02T15:59:17.000Z</published>
    <updated>2020-09-04T15:13:43.179Z</updated>
    
    <content type="html"><![CDATA[<p>在《render 实现原理》这一节中，有分析到 <code>createElement</code> 的实现过程，其最终调用的是 <code>_createElement</code>；而在该方法里有一段逻辑对 <code>tag</code> 的判断，如果 <code>tag</code> 类型为 <code>string</code> 时，则进入处理 <code>string</code> 类型的逻辑，前面已经分析过；否则则进入创建组件 Vnode 的逻辑，即要分析 <code>createComponent</code> 的实现过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params"></span></span></div><div class="line">    Ctor,</div><div class="line">    data,</div><div class="line">    context,</div><div class="line">    children,</div><div class="line">    tag</div><div class="line">) &#123;</div><div class="line">    <span class="keyword">if</span> (isUndef(Ctor)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> baseCtor = context.$options._base;</div><div class="line"></div><div class="line">    <span class="comment">// plain options object: turn it into a constructor</span></div><div class="line">    <span class="keyword">if</span> (isObject(Ctor)) &#123;</div><div class="line">        Ctor = baseCtor.extend(Ctor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// if at this stage it's not a constructor or an async component factory,</span></div><div class="line">    <span class="comment">// reject.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Ctor !== <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">            warn((<span class="string">"Invalid Component definition: "</span> + (<span class="built_in">String</span>(Ctor))), context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// async component</span></div><div class="line">    <span class="keyword">var</span> asyncFactory;</div><div class="line">    <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</div><div class="line">        asyncFactory = Ctor;</div><div class="line">        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</div><div class="line">        <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</div><div class="line">            <span class="comment">// return a placeholder node for async component, which is rendered</span></div><div class="line">            <span class="comment">// as a comment node but preserves all the raw information for the node.</span></div><div class="line">            <span class="comment">// the information will be used for async server-rendering and hydration.</span></div><div class="line">            <span class="keyword">return</span> createAsyncPlaceholder(</div><div class="line">                asyncFactory,</div><div class="line">                data,</div><div class="line">                context,</div><div class="line">                children,</div><div class="line">                tag</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = data || &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// resolve constructor options in case global mixins are applied after</span></div><div class="line">    <span class="comment">// component constructor creation</span></div><div class="line">    resolveConstructorOptions(Ctor);</div><div class="line"></div><div class="line">    <span class="comment">// transform component v-model data into props &amp; events</span></div><div class="line">    <span class="keyword">if</span> (isDef(data.model)) &#123;</div><div class="line">        transformModel(Ctor.options, data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// extract props</span></div><div class="line">    <span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag);</div><div class="line"></div><div class="line">    <span class="comment">// functional component</span></div><div class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</div><div class="line">        <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// extract listeners, since these needs to be treated as</span></div><div class="line">    <span class="comment">// child component listeners instead of DOM listeners</span></div><div class="line">    <span class="keyword">var</span> listeners = data.on;</div><div class="line">    <span class="comment">// replace with listeners with .native modifier</span></div><div class="line">    <span class="comment">// so it gets processed during parent component patch.</span></div><div class="line">    data.on = data.nativeOn;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.abstract)) &#123;</div><div class="line">        <span class="comment">// abstract components do not keep anything</span></div><div class="line">        <span class="comment">// other than props &amp; listeners &amp; slot</span></div><div class="line"></div><div class="line">        <span class="comment">// work around flow</span></div><div class="line">        <span class="keyword">var</span> slot = data.slot;</div><div class="line">        data = &#123;&#125;;</div><div class="line">        <span class="keyword">if</span> (slot) &#123;</div><div class="line">            data.slot = slot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// install component management hooks onto the placeholder node</span></div><div class="line">    installComponentHooks(data);</div><div class="line"></div><div class="line">    <span class="comment">// return a placeholder vnode</span></div><div class="line">    <span class="keyword">var</span> name = Ctor.options.name || tag;</div><div class="line">    <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</div><div class="line">        (<span class="string">"vue-component-"</span> + (Ctor.cid) + (name ? (<span class="string">"-"</span> + name) : <span class="string">''</span>)),</div><div class="line">        data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,</div><div class="line">        asyncFactory</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法接收 5 个参数：</p>
<ul>
<li><p><code>Ctor</code>：表示一个组件对象；</p>
<p>  <img src="/images/vue/create_component_ctor.png" alt="init 逻辑实现"></p>
</li>
<li><p><code>data</code>：表示 vnode 数据；</p>
</li>
<li><p><code>context</code>：表示 Vue 实例；</p>
</li>
<li><p><code>children</code>：表示 vnode 子节点；</p>
</li>
<li><p><code>tag</code>：表示标签。</p>
</li>
</ul>
<p>其逻辑实现如下：</p>
<ul>
<li><p>第 <code>8</code> ~ <code>10</code> ：判断 <code>Ctor</code> 是否为 <code>null</code>。如果为 <code>null</code> 的话则返回，否则继续执行。</p>
</li>
<li><p>第 <code>12</code> ~ <code>17</code> 行：基于 Vue 构造函数<strong>构造子类构造函数</strong>。<code>baseCtor</code> 指向 Vue 构造函数，原因是在初始化 Vue 阶段时，在 <code>src/core/global-api/index.js</code> 文件有这么一段逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></div><div class="line"><span class="comment">// components with in Weex's multi-instance scenarios.</span></div><div class="line">Vue.options._base = Vue</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>可能你会发现 `_base` 是在定义在 `Vue.options`，而使用的是 `Vue.$options._base`，究竟是怎么回事呢？其实在创建 Vue 实例时调用的方法 `_init` 里，有这么一段逻辑：

 将用户传入的 `options` 和 Vue 构造函数的 `options` 进行合并，最后将合并后的 `options` 赋值给 `vm.$options`，因此能访问到。

`baseCtor.extend(Ctor)` 即 `Vue.extend(Ctor)`，构造子类构造函数。
</code></pre><ul>
<li><p>第 <code>29</code> ~ <code>45</code> 行：异步组件处理。</p>
</li>
<li><p>第 <code>54</code> ~ <code>56</code> 行：把组件 <code>v-model</code> 转换为 <code>props</code>  和 <code>events</code>。</p>
</li>
<li><p>第 <code>59</code> 行：提取 <code>props</code>。</p>
</li>
<li><p>第 <code>61</code> ~ <code>64</code> 行：存在函数式组件的则创建函数式组件。</p>
</li>
<li><p>第 <code>68</code> 行：提取监听器，因为 <code>data.on</code> 需要被作为子组件的监听器以代替 DOM 监听器。</p>
</li>
<li><p>第 <code>71</code> 行：用 <code>.native</code> 代替监听器 <code>data.on</code>。（在父组件 patch 过程会被处理）</p>
</li>
<li><p>第 <code>73</code> ~ <code>83</code>：存在抽象组件的话则处理抽象组件。</p>
</li>
<li><p>第 <code>86</code> 行：安装组件钩子函数 <code>installComponentHooks</code>。</p>
</li>
<li><p>第 <code>90</code> ~ <code>94</code> 行：实例化组件 Vnode</p>
</li>
<li><p>返回组件 vnode。</p>
</li>
</ul>
<p>在创建组件的过程中，核心的逻辑有三步：</p>
<ul>
<li><p><strong>构造子类构造函数</strong>：<code>Ctor = baseCtor.extend(Ctor)</code>。</p>
</li>
<li><p><strong>安装组件钩子函数</strong>：<code>installComponentHooks(data)</code>。</p>
</li>
<li><p><strong>实例化组件 Vnode</strong>：<code>var vnode = new VNode( (&quot;vue-component-&quot; + (Ctor.cid) + (name ? (&quot;-&quot; + name) : &#39;&#39;)), data, undefined, undefined, undefined, context,{ Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children:children },asyncFactory);</code></p>
</li>
</ul>
<p>注意点：<strong>创建组件时 <code>children</code> 为 <code>undefined</code>。</strong></p>
<p>那么接下来对核心三个步骤进行简要分析，先来看下 <code>baseCtor.extend(Ctor)</code> 的具体实现，位于 <code>src/core/global-api/extend.js</code> 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Class inheritance</div><div class="line">   */</div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</div><div class="line">      validateComponentName(name)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></div><div class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></div><div class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></div><div class="line">    Sub.extend = Super.extend</div><div class="line">    Sub.mixin = Super.mixin</div><div class="line">    Sub.use = Super.use</div><div class="line"></div><div class="line">    <span class="comment">// create asset registers, so extended classes</span></div><div class="line">    <span class="comment">// can have their private assets too.</span></div><div class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">      Sub[type] = Super[type]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// enable recursive self-lookup</span></div><div class="line">    <span class="keyword">if</span> (name) &#123;</div><div class="line">      Sub.options.components[name] = Sub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// keep a reference to the super options at extension time.</span></div><div class="line">    <span class="comment">// later at instantiation we can check if Super's options have</span></div><div class="line">    <span class="comment">// been updated.</span></div><div class="line">    Sub.superOptions = Super.options</div><div class="line">    Sub.extendOptions = extendOptions</div><div class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</div><div class="line"></div><div class="line">    <span class="comment">// cache constructor</span></div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法接收一个参数：<code>extendOptions</code>，指向 <code>export default {}</code> 即平时我们在编写 Vue 组件时导出的对象。</p>
<ul>
<li><p>第 <code>6</code> 行：<code>Super</code> 指向的是 Vue 构造函数。</p>
</li>
<li><p>第 <code>8</code> ~ <code>11</code> 行：变量 <code>cachedCtors</code> 通过 <code>SuperId</code> 来缓存组件，即同一个组件在多个地方导入，只会创建一次，其余都是直接从缓存获取。</p>
</li>
<li><p>第 <code>14</code> ~ <code>16</code> 行：在非生产环境对组件名称做校验。</p>
</li>
<li><p>第 <code>18</code> ~ <code>20</code> 行：声明 VueComponent 构造函数赋值给 <code>Sub</code>。</p>
</li>
<li><p>第 <code>21</code> ~ <code>22</code> 行：采用经典的原型继承方式把一个纯对象转换为一个继承于 Vue 的 <code>Sub</code>，并在后续对 <code>Sub</code> 进行扩展。</p>
</li>
<li><p>第 <code>24</code> ~ <code>27</code> 行：对 <code>Super</code> 构造函数自带的 <code>options</code> 和用户传进来的 <code>options</code> 进行合并，并赋值给 <code>Sub.options</code>。</p>
</li>
<li><p>第 <code>33</code> ~ <code>35</code> 行：如果存在 <code>props</code> 的话，则初始化 <code>props</code>。</p>
</li>
<li><p>第 <code>36</code> ~ <code>38</code> 行：如果存在 <code>computed</code> 的话，则初始化 <code>computed</code>。</p>
</li>
<li><p>第 <code>63</code> 行：缓存 <code>Sub</code> 构造函数。</p>
</li>
<li><p>返回 <code>Sub</code> 构造函数。</p>
</li>
</ul>
<p>接着来看下安装组件钩子函数的具体实现，即 <code>installComponentHooks</code> 方法，位于 <code>src/core/vdom/create-component.js</code> 中</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span> (<span class="params">data: VNodeData</span>) </span>&#123;</div><div class="line"> 	<span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;)</div><div class="line"> 	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</div><div class="line"> 		<span class="keyword">const</span> key = hooksToMerge[i]</div><div class="line"> 		<span class="keyword">const</span> existing = hooks[key]</div><div class="line"> 		<span class="keyword">const</span> toMerge = componentVNodeHooks[key]</div><div class="line"> 		<span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</div><div class="line"> 			hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge</div><div class="line"> 		&#125;</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看下两个变量：<code>hooksToMerge</code> 和 <code>componentVNodeHooks</code> 具体指的是什么？</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// inline hooks to be invoked on component VNodes during patch</span></div><div class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</div><div class="line">  init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;</div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      vnode.componentInstance &amp;&amp;</div><div class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</div><div class="line">      vnode.data.keepAlive</div><div class="line">    ) &#123;</div><div class="line">      <span class="comment">// kept-alive components, treat as a patch</span></div><div class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></div><div class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</div><div class="line">        vnode,</div><div class="line">        activeInstance</div><div class="line">      )</div><div class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> options = vnode.componentOptions</div><div class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</div><div class="line">    updateChildComponent(</div><div class="line">      child,</div><div class="line">      options.propsData, <span class="comment">// updated props</span></div><div class="line">      options.listeners, <span class="comment">// updated listeners</span></div><div class="line">      vnode, <span class="comment">// new parent vnode</span></div><div class="line">      options.children <span class="comment">// new children</span></div><div class="line">    )</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  insert (vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</div><div class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</div><div class="line">      componentInstance._isMounted = <span class="literal">true</span></div><div class="line">      callHook(componentInstance, <span class="string">'mounted'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</div><div class="line">      <span class="keyword">if</span> (context._isMounted) &#123;</div><div class="line">        <span class="comment">// vue-router#1212</span></div><div class="line">        <span class="comment">// During updates, a kept-alive component's child components may</span></div><div class="line">        <span class="comment">// change, so directly walking the tree here may call activated hooks</span></div><div class="line">        <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></div><div class="line">        <span class="comment">// be processed after the whole patch process ended.</span></div><div class="line">        queueActivatedComponent(componentInstance)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        activateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  destroy (vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</div><div class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</div><div class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</div><div class="line">        componentInstance.$destroy()</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> hooksToMerge = <span class="built_in">Object</span>.keys(componentVNodeHooks)</div></pre></td></tr></table></figure>
<p><code>componentVNodeHooks</code> 是一个对象，定义了四个钩子函数：<code>init</code>、<code>prepatch</code>、<code>insert</code>、<code>destroy</code>；而 <code>hooksToMerge</code> 是一个数组，数组元素是这 4 个钩子函数。</p>
<p>回到 <code>installComponentHooks</code> 方法，其逻辑是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code>，然后在 VNode 执行 <code>patch</code> 过程中会执行相应的钩子函数。需要注意下合并策略，如果 <code>data.hook</code> 已经存在相应的钩子函数，则调用 <code>mergeHook</code> 函数进行合并。</p>
<p>最后通过一一张流程图简单地概括下其主线逻辑：</p>
<p><img src="/images/vue/create_component.png" alt="init 逻辑实现"></p>
<p>以上对组件创建的过程做了简要分析，随着不断地学习以及更进一步地加深理解，会继承完善。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/components/create-component.html#%E6%9E%84%E9%80%A0%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" target="_blank" rel="external">createComponent</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《render 实现原理》这一节中，有分析到 &lt;code&gt;createElement&lt;/code&gt; 的实现过程，其最终调用的是 &lt;code&gt;_createElement&lt;/code&gt;；而在该方法里有一段逻辑对 &lt;code&gt;tag&lt;/code&gt; 的判断，如果 &lt;code&gt;t
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>update 实现原理</title>
    <link href="http://panzeyong.com/2020/08/30/update-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/08/30/update-实现原理/</id>
    <published>2020-08-30T09:44:17.000Z</published>
    <updated>2020-09-01T14:53:23.020Z</updated>
    
    <content type="html"><![CDATA[<p>在 <strong>《Vue 实例挂载实现原理》</strong> 这一节中分析了 Vue 实例挂载实现逻辑中，得知有这么一行核心代码：<code>vm._update(vm._render(), hydrating)</code>。上一节 <strong>《render 实现原理》</strong> 中对 <code>vm._render</code> 进行了分析；那么这一节将要分析 <code>vm._update</code> 的实现原理。</p>
<p><code>_update</code> 是 Vue 实例的一个私有方法，有两个时机被调用：<strong>一个是首次渲染；一个是数据更新时触发调用。（响应式原理分析涉及）</strong>作用的是将 <code>render</code> 渲染生成的 VNode 转换为真实的 DOM 节点。</p>
<p>那么该方法是定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="keyword">const</span> prevEl = vm.$el</div><div class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</div><div class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</div><div class="line">  vm._vnode = vnode</div><div class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></div><div class="line">  <span class="comment">// based on the rendering backend used.</span></div><div class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">    <span class="comment">// initial render</span></div><div class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// updates</span></div><div class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">  &#125;</div><div class="line">  restoreActiveInstance()</div><div class="line">  <span class="comment">// update __vue__ reference</span></div><div class="line">  <span class="keyword">if</span> (prevEl) &#123;</div><div class="line">    prevEl.__vue__ = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (vm.$el) &#123;</div><div class="line">    vm.$el.__vue__ = vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</div><div class="line">    vm.$parent.$el = vm.$el</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></div><div class="line">  <span class="comment">// updated in a parent's updated hook.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面结合例子来分析<strong>首次渲染</strong>调用时的实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    render: h =&gt; h(<span class="string">'div'</span>, &#123;</div><div class="line">        attrs: &#123;</div><div class="line">            id: <span class="string">'content'</span></div><div class="line">        &#125;</div><div class="line">    &#125;, [</div><div class="line">        h(<span class="string">'h1'</span>, <span class="string">'我是标题1'</span>),</div><div class="line">        h(<span class="string">'h2'</span>, <span class="string">'我是标题2'</span>)</div><div class="line">    ]),</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<ul>
<li><p>第 <code>3</code> 行将在 <code>mountComponent</code> 方法获取到 <code>vm.$el</code> 赋值给变量 <code>prevEl</code>，它是一个真实的 DOM 节点，即 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>；</p>
</li>
<li><p>第 <code>4</code> 行 <code>vm._vnode</code> 为 <code>null</code>，赋值给变量 <code>prevVnode</code>；</p>
</li>
<li><p>由于 <code>prevVnode</code> 为 <code>null</code>，逻辑进入到第 <code>11</code> 行代码，也是该方法的核心逻辑实现。</p>
</li>
</ul>
<p>接下来重点来分析 <code>vm.__patch__</code> 的实现，该方法定义在 <code>src/platform/web/runtime/index.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</div></pre></td></tr></table></figure>
<p>这个方法实际上在不同的平台，其定义是不一样的。上面是在 Web 平台的定义；Weex 平台的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.__patch__ = patch</div></pre></td></tr></table></figure>
<p>在 Web 平台中，是否是服务端渲染对其也产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 渲染环境，不需要将 VNode 转换成真实 DOM，调用的是空函数；而在浏览器环境中，有真实的 DOM 渲染环境，需要将 VNode 转换成真实的 DOM，指向方法 <code>patch</code>。</p>
<p>方法 <code>patch</code> 定义在 <code>`src/platform/web/runtime/patch.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</div></pre></td></tr></table></figure>
<p>调用 <code>createPatchFunction</code> 方法，传入一个对象，包含两个参数：<code>nodeOps</code> 封装了一系列操作 DOM 的方法；<code>modules</code> 定义了一些模块（<code>attrs</code>、<code>style</code>、<code>class</code>、<code>event</code>、<code>transition</code>）钩子函数的实现，此处不展开分析。</p>
<p>那么再来看 <code>createPatchFunction</code> 是如何实现的？该方法定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> i, j</div><div class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</div><div class="line">    cbs[hooks[i]] = []</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</div><div class="line">      <span class="keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;</div><div class="line">        cbs[hooks[i]].push(modules[j][hooks[i]])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ......（此处省略定义一系列辅助方法的实现）</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</div><div class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></div><div class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</div><div class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></div><div class="line">      isInitialPatch = <span class="literal">true</span></div><div class="line">      createElm(vnode, insertedVnodeQueue)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</div><div class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</div><div class="line">        <span class="comment">// patch existing root node</span></div><div class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (isRealElement) &#123;</div><div class="line">          <span class="comment">// mounting to a real element</span></div><div class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></div><div class="line">          <span class="comment">// a successful hydration.</span></div><div class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</div><div class="line">            oldVnode.removeAttribute(SSR_ATTR)</div><div class="line">            hydrating = <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</div><div class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</div><div class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</div><div class="line">              <span class="keyword">return</span> oldVnode</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">              warn(</div><div class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</div><div class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</div><div class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</div><div class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</div><div class="line">                <span class="string">'full client-side render.'</span></div><div class="line">              )</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></div><div class="line">          <span class="comment">// create an empty node and replace it</span></div><div class="line">          oldVnode = emptyNodeAt(oldVnode)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// replacing existing element</span></div><div class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</div><div class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</div><div class="line"></div><div class="line">        <span class="comment">// create new node</span></div><div class="line">        createElm(</div><div class="line">          vnode,</div><div class="line">          insertedVnodeQueue,</div><div class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></div><div class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></div><div class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></div><div class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</div><div class="line">          nodeOps.nextSibling(oldElm)</div><div class="line">        )</div><div class="line"></div><div class="line">        <span class="comment">// update parent placeholder node element, recursively</span></div><div class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</div><div class="line">          <span class="keyword">let</span> ancestor = vnode.parent</div><div class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</div><div class="line">          <span class="keyword">while</span> (ancestor) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</div><div class="line">              cbs.destroy[i](ancestor)</div><div class="line">            &#125;</div><div class="line">            ancestor.elm = vnode.elm</div><div class="line">            <span class="keyword">if</span> (patchable) &#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</div><div class="line">                cbs.create[i](emptyNode, ancestor)</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// #6513</span></div><div class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></div><div class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></div><div class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</div><div class="line">              <span class="keyword">if</span> (insert.merged) &#123;</div><div class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</div><div class="line">                  insert.fns[i]()</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              registerRef(ancestor)</div><div class="line">            &#125;</div><div class="line">            ancestor = ancestor.parent</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// destroy old node</span></div><div class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</div><div class="line">          removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</div><div class="line">          invokeDestroyHook(oldVnode)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</div><div class="line">    <span class="keyword">return</span> vnode.elm</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>第 <code>7</code> ~ <code>14</code> 行循环遍历 <code>hooks</code>，其定义如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> hooks = [<span class="string">'create'</span>, <span class="string">'activate'</span>, <span class="string">'update'</span>, <span class="string">'remove'</span>, <span class="string">'destroy'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<p> 和 <code>modules</code>，用遍历 <code>cbs</code> 来保存每个 <code>hook</code> 对应的钩子函数；</p>
<ul>
<li><p>省略一系列辅助方法；</p>
</li>
<li><p>返回函数 <code>patch</code>，也就是说，调用 <code>vm.__patch__</code> 方法时，其实调用的是 <code>patch</code> 方法。</p>
</li>
</ul>
<p><code>patch</code> 方法接收 4 个参数：</p>
<ul>
<li><p><code>oldVnode</code>：表示旧的 Vnode，它可以是一个 DOM 对象，也可以是不存在的；</p>
</li>
<li><p><code>vnode</code>：表示执行 <code>vm._render</code> 返回的 VNode 节点；</p>
</li>
<li><p><code>hydrating</code>：表示是否服务端渲染；</p>
</li>
<li><p><code>removeOnly</code>：表示给 <code>transition-group</code> 使用的。</p>
</li>
</ul>
<p>结合上面给出的例子来分析 <code>patch</code> 的实现：</p>
<ul>
<li><p>第 <code>19</code> ~ <code>22</code> 行代码中，由于传入的参数是 <code>vnode</code> 是上一步 <code>vm._render</code> 渲染生成的 vnode，不为 <code>null</code>，此逻辑跳过；</p>
<p>  <img src="/images/vue/param_vnode.png" alt=""></p>
</li>
<li><p>传入参数 <code>oldVnode</code> 是一个真实的 DOM 节点，即 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，没有进入到第 <code>27</code> ~ <code>30</code> 行代码，而是进入到 <code>else</code> 里面的逻辑了；</p>
<p>  <img src="/images/vue/param_old_vnode.png" alt=""></p>
</li>
<li><p>由于 <code>oldVnode</code> 是真实 DOM 节点，<code>isRealElement</code> 为 <code>true</code>，因此逻辑进入到第 <code>37</code> ~ <code>115</code> 里。其中有几处比较关键的代码实现：</p>
<ul>
<li><p>通过方法 <code>emptyNodeAt</code> 把 <code>oldVnode</code> 转换成虚拟 VNode，即</p>
<p><code>oldVnode = emptyNodeAt(oldVnode)</code></p>
</li>
<li><p>声明变量保存值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// replacing existing element</span></div><div class="line"><span class="keyword">const</span> oldElm = oldVnode.elm  <span class="comment">// 保存真实 DOM 节点 div#app</span></div><div class="line"><span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)（保存当前节的父节点，此处指的是 body）</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- 第 `69` ~ `77` 调用方法 `createElm` 创建新节点，此方法是核心方法，稍后分析；

- 第 `110` ~ `112` 行由于创建了新节点，需要将旧节点删除。

 ![](/images/vue/create_vnode.png)
</code></pre><p>接着再来看核心方法 <code>createElm</code> 的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></div><div class="line">    vnode,</div><div class="line">    insertedVnodeQueue,</div><div class="line">    parentElm,</div><div class="line">    refElm,</div><div class="line">    nested,</div><div class="line">    ownerArray,</div><div class="line">    index</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</div><div class="line">      <span class="comment">// This vnode was used in a previous render!</span></div><div class="line">      <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></div><div class="line">      <span class="comment">// potential patch errors down the road when it's used as an insertion</span></div><div class="line">      <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></div><div class="line">      <span class="comment">// associated DOM element for it.</span></div><div class="line">      vnode = ownerArray[index] = cloneVNode(vnode)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></div><div class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> data = vnode.data</div><div class="line">    <span class="keyword">const</span> children = vnode.children</div><div class="line">    <span class="keyword">const</span> tag = vnode.tag</div><div class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</div><div class="line">          creatingElmInVPre++</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</div><div class="line">          warn(</div><div class="line">            <span class="string">'Unknown custom element: &lt;'</span> + tag + <span class="string">'&gt; - did you '</span> +</div><div class="line">            <span class="string">'register the component correctly? For recursive components, '</span> +</div><div class="line">            <span class="string">'make sure to provide the "name" option.'</span>,</div><div class="line">            vnode.context</div><div class="line">          )</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      vnode.elm = vnode.ns</div><div class="line">        ? nodeOps.createElementNS(vnode.ns, tag)</div><div class="line">        : nodeOps.createElement(tag, vnode)</div><div class="line">      setScope(vnode)</div><div class="line"></div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> (__WEEX__) &#123;</div><div class="line">        <span class="comment">// in Weex, the default insertion order is parent-first.</span></div><div class="line">        <span class="comment">// List items can be optimized to use children-first insertion</span></div><div class="line">        <span class="comment">// with append="tree".</span></div><div class="line">        <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</div><div class="line">        <span class="keyword">if</span> (!appendAsTree) &#123;</div><div class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">          &#125;</div><div class="line">          insert(parentElm, vnode.elm, refElm)</div><div class="line">        &#125;</div><div class="line">        createChildren(vnode, children, insertedVnodeQueue)</div><div class="line">        <span class="keyword">if</span> (appendAsTree) &#123;</div><div class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">          &#125;</div><div class="line">          insert(parentElm, vnode.elm, refElm)</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        createChildren(vnode, children, insertedVnodeQueue)</div><div class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">        &#125;</div><div class="line">        insert(parentElm, vnode.elm, refElm)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</div><div class="line">        creatingElmInVPre--</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</div><div class="line">      vnode.elm = nodeOps.createComment(vnode.text)</div><div class="line">      insert(parentElm, vnode.elm, refElm)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vnode.elm = nodeOps.createTextNode(vnode.text)</div><div class="line">      insert(parentElm, vnode.elm, refElm)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>该方法接收 7 个参数：</p>
<ul>
<li><p><code>vnode</code>：表示执行 <code>vm._render</code> 返回的 VNode 节点；</p>
</li>
<li><p><code>insertedVnodeQueue</code>：用来保存 vnode 已经转换为真实 DOM 的 vnode 队列；</p>
</li>
<li><p><code>parentElm</code>：表示父节点；</p>
</li>
<li><p><code>refElm</code>：表示参考节点；</p>
</li>
</ul>
<p><strong>作用是把虚拟节点 VNode 转换为真实的 DOM 节点，并且插入它的父节点。</strong></p>
<p>简单分析其逻辑实现：</p>
<ul>
<li><p>第 <code>10</code> ~ <code>17</code> 行，不满足条件判断，跳过此处逻辑；</p>
</li>
<li><p>第 <code>20</code> 行尝试创建子组件，此处返回  <code>false</code>；</p>
</li>
<li><p>接着判断 vnode 是否包含 <code>tag</code> 标签，此 case 中，<code>tag</code> 为 <code>div</code>，因此满足条件，进入到逻辑里面，对其在开发环境做合法性校验，然后再调用平台 DOM 的操作去创建一个占位符元素，即 第 <code>42</code> ~ <code>45</code>；</p>
</li>
<li><p>第 <code>48</code> ~ <code>65</code> 是对 <code>weex</code> 平台的逻辑处理，暂时忽略；</p>
</li>
<li><p>接着进入到第 <code>67</code> ~ <code>71</code> 行的实现逻辑里，调用方法 <code>createChildren</code>，具体实现如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      checkDuplicateKeys(children)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</div><div class="line">      createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i)</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(vnode.text)) &#123;</div><div class="line">    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(<span class="built_in">String</span>(vnode.text)))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的作用遍历子虚拟节点，递归调用方法 <code>createElm</code> 创建真实 DOM，采用的是深度优先遍历的算法。</p>
<p>接着调用 <code>invokeCreateHooks</code> 方法执行所有的 <code>create</code> 的钩子函数并把 <code>vnode</code> push 到 <code>insertedVnodeQueue</code> 中。</p>
<p>最后调用方法 <code>insert</code> <strong>将真实 DOM 插入到父节点中，由于是递归调用，子节点会优先于父节点 <code>insert</code></strong>，所以整个 <code>vnode</code> 树的插入顺序是<strong>先子后父</strong>。 看下方法 <code>insert</code> 的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isDef(parent)) &#123;</div><div class="line">     <span class="keyword">if</span> (isDef(ref)) &#123;</div><div class="line">       <span class="keyword">if</span> (nodeOps.parentNode(ref) === parent) &#123;</div><div class="line">         nodeOps.insertBefore(parent, elm, ref)</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       nodeOps.appendChild(parent, elm)</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>该方法的实现逻辑挺简单，即在满足判断条件时，调用 <code>nodeOps</code> 的辅助方法将子节点插入到父节点中，我们来看下这些辅助方法是如何定义的，位于 <code>src/platform/web/runtime/node-ops.js</code> 中</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parentNode</span> (<span class="params">node: Node</span>): ?<span class="title">Node</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> node.parentNode</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</div><div class="line">	parentNode.insertBefore(newNode, referenceNode)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</div><div class="line">	node.appendChild(child)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p> 从源码实现可以看出，创建真实 DOM 的过程中，其实调用的是原生 DOM 的 API 来操作的。</p>
<ul>
<li>除了 vnode 包含 <code>tag</code> 外，vnode 还可以是注释节点或者文本节点，如果是这两者之一，则直接创建注释节点或者文本节点，并插入到其父节点中，即 第 <code>77</code> ~ <code>83</code>。</li>
</ul>
<p>那么至此简单分析了 <code>update</code> 的实现过程，下面再通过一张流程图简单地描述其主线：</p>
<p><img src="/images/vue/update.png" alt=""></p>
<p>那么至此把数据和模板如何渲染成最终 DOM 的过程分析完了，借助 <a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" target="_blank" rel="external">update</a> 里提供的图片更直观地来描述从初始化 Vue 到整个渲染完成的过程：</p>
<p><img src="/images/vue/init_to_render.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" target="_blank" rel="external">update</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;strong&gt;《Vue 实例挂载实现原理》&lt;/strong&gt; 这一节中分析了 Vue 实例挂载实现逻辑中，得知有这么一行核心代码：&lt;code&gt;vm._update(vm._render(), hydrating)&lt;/code&gt;。上一节 &lt;strong&gt;《render 
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue 入口初始化</title>
    <link href="http://panzeyong.com/2020/03/29/Vue-%E5%85%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://panzeyong.com/2020/03/29/Vue-入口初始化/</id>
    <published>2020-03-29T13:32:55.000Z</published>
    <updated>2020-08-29T08:52:49.147Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要介绍 Vue 是如何初始化以及初始化过程中做了哪些事情。通过自己整理出来的流程图来说明其主线：</p>
<p><img src="/images/vue/vue_init.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/entrance.html#vue-%E7%9A%84%E5%85%A5%E5%8F%A3" target="_blank" rel="external">从入口开始</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这节主要介绍 Vue 是如何初始化以及初始化过程中做了哪些事情。通过自己整理出来的流程图来说明其主线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vue/vue_init.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; 
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 之原型及原型链</title>
    <link href="http://panzeyong.com/2019/11/19/Javascript-%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://panzeyong.com/2019/11/19/Javascript-之原型及原型链/</id>
    <published>2019-11-18T23:53:16.000Z</published>
    <updated>2019-11-23T09:29:09.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Javascript 函数有一个 <code>prototype</code> 属性，该属性是一个指针，指向一个对象，该对象包含特定类型的所有实例共享的属性和方法，称为实例对象的<strong>原型对象</strong>。</p>
<p>简单来说，在 JavaScript 中创建一个新函数，就会自动获取 <code>prototype</code> 属性，通过 <code>new</code> 命令创建实例对象，实例对象会获取 <code>prototype</code> 属性所指向的原型对象的属性和方法。打个比方，在 Java 中有类和继承的概念，<code>prototype</code> 所指向的原型对象就好比 Java 中的基类，而新函数好比是 Java 中的新类，继承基类中的属性和方法，那么创建实例后，除了能访问到本身的属性和方法外，还能访问到基类中的属性和方法。</p>
<h1 id="构造函数与原型对象之间的关系"><a href="#构造函数与原型对象之间的关系" class="headerlink" title="构造函数与原型对象之间的关系"></a>构造函数与原型对象之间的关系</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.age = <span class="number">12</span>;</div><div class="line"><span class="built_in">console</span>.log(person.age);    <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>以上例子，Person 是一个构造函数，通过 <code>new</code> 命令实例化对象。通过构造函数实例化对象的方式，如果多个实例对象都拥有属性 <code>age</code> 时，则需要在每个实例对象本身设置该属性，这样的操作显得有点冗余。那么有没有一种方式可以把属性 <code>age</code> 设置为公有，实例化对象时就自动拥有公共的属性呢，而对于实例对象本身只需要添加自己需要的属性即可。答案是有的。</p>
<p>这里就需要引出 <code>prototype</code> 属性，那么 <code>prototype</code> 属性是什么呢？除了<strong>bind 函数</strong>、<strong>箭头函数</strong>以及 <strong>Function.prototype</strong> 外，每个函数都有一个属性 <strong>prototype</strong>，该属性是一个指针，指向一个对象，该对象是函数的<strong>原型对象</strong>，原型对象包含了公共的属性和方法，实例化的所有对象都共享原型对象的属性和方法。<em>需要注意的是 <em>*<code>prototype</code> 属性是函数才拥有的。</em></em> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Person.prototype.age = <span class="number">12</span>;</div><div class="line">Person.prototype.name = <span class="string">"Jack"</span>;</div><div class="line"></div><div class="line">Person.prototype.say = () =&gt; &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello World !"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.age);    <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(person2.age);    <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(person1.say());  <span class="comment">// Hello World</span></div><div class="line"><span class="built_in">console</span>.log(person2.say());  <span class="comment">// Hello World</span></div><div class="line"></div><div class="line">person1.job = <span class="string">"test"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.job);    <span class="comment">// test</span></div><div class="line"><span class="built_in">console</span>.log(person2.job);    <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>从以上例子可以得知，通过 <code>prototype</code> 属性添加 <code>age</code> 和 <code>name</code> 属性，然后实例化两个对象，分别打印出两个属性是有值的，说明实例对象拥有了原型对象的属性和方法。</p>
<p>现在我们已经知道构造函数与原型对象的单向关系，即构造函数通过 <code>prototype</code> 属性指向原型对象。那么原型对象能反过来通过某种方式指向原先的构造函数吗？答案是可以的，这时就需要 <code>constructor</code> 派上场了。</p>
<p>每个原型对象都会有一个 <code>constructor</code> 属性，而 <code>constructor</code> 属性包含一个指向 <code>prototype</code> 属性所在函数的指针。以上面例子为例，即</p>
<p><code>Person.prototype.constructor === Person</code>（<code>true</code>）。</p>
<p>至此，我们理清了构造函数与原型对象之间的关系，关系图如下：</p>
<p><img src="/images/javascript/prototype/constructor_prototype_object_relation.png" alt=""></p>
<h1 id="实例对象与原型对象之间的关系"><a href="#实例对象与原型对象之间的关系" class="headerlink" title="实例对象与原型对象之间的关系"></a>实例对象与原型对象之间的关系</h1><p>当读取实例对象属性时，首先会在实例对象本身查找该属性是否存在，不存在的话，就会往实例对象与之关联的原型对象查找，再查找不到时，直向原型的原型查找，查找到最上层为止。</p>
<p>例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Jack"</span>;</div><div class="line">Person.prototype.desc = <span class="string">"desc"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// Jack</span></div></pre></td></tr></table></figure>
<p>可见，实例对象 <code>person</code> 本身没有属性 <code>name</code>，但是还能查找到该属性，这是通过原型对象找到的。那么实例对象是通过什么方式与原型对象关联呢？其实实例对象有一个属性 <code>__proto__</code>，指向原型对象，即 </p>
<p><code>person.__proto__ === Person.prototype</code>（<code>true</code>）。</p>
<p><img src="/images/javascript/prototype/proto_to_prototype.png" alt=""></p>
<h1 id="原型对象的原型对象"><a href="#原型对象的原型对象" class="headerlink" title="原型对象的原型对象"></a>原型对象的原型对象</h1><p>从上面我们已经理清了构造函数与原型对象、实例对象与原型对象之间的关系，那么我们会不会产生一个疑惑：原型对象的原型对象是什么，即 <code>Person.prototype</code> 的原型对象是什么？</p>
<p>JavaScript 中的所有对象都来自 <code>Object</code>，并且所有对象都从 <code>Object.prototype</code> 继承属性和方法，尽管它们可能被覆盖。因此可以推出：</p>
<p><code>Person.prototype.__proto__ === Object.prototype</code>（<strong>true</strong>）。</p>
<p><img src="/images/javascript/prototype/object_prototype.png" alt=""></p>
<p>图中画虚线的表示通过 <code>__prototype__</code> 形成原型链；至此，已经把原型对象及原型链的知识讲完。最后放一张网上对原型的理解画得比较全面的关系图，如下：</p>
<p><img src="/images/javascript/prototype/prototype_all.png" alt=""></p>
<p>注：以上只是自己整理的学习笔记，由于水平有限难免有错误，欢迎指出。随着自己对原型的深入理解，笔记也会做相应的修改，最后放上资料参考来源。</p>
<ul>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">https://github.com/mqyqingfeng/Blog/issues/2</a></p>
</li>
<li><p>《JavaScript 高级程序设计》（第 3 版）</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Javascript 函数有一个 &lt;code&gt;prototype&lt;/code&gt; 属性，该属性是一个指针，指向一个对象，该对象包含特定类型的所
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="知识点整理" scheme="http://panzeyong.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>函数的扩展</title>
    <link href="http://panzeyong.com/2019/03/12/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/12/函数的扩展/</id>
    <published>2019-03-12T12:04:48.000Z</published>
    <updated>2020-08-29T09:46:53.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、函数参数的默认值"><a href="#一、函数参数的默认值" class="headerlink" title="一、函数参数的默认值"></a>一、函数参数的默认值</h1><h3 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><p>ES6 允许为函数的参数指定默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">default</span> (<span class="params">x, y = 'hello'</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的点： </p>
<ul>
<li><p>参数变量是默认声明的，因此不能使用 <code>let</code> 或者 <code>const</code> 再次声明。</p>
</li>
<li><p>使用参数默认值时，函数不能有同名参数。</p>
</li>
<li><p>参数默认值是惰性求值的。（默认值是表达式求值）。</p>
</li>
<li><p>将参数默认值指定为 <code>undefined</code>，表示该参数可以省略。</p>
</li>
</ul>
<h3 id="2、对象的解构赋值与函数参数的默认值"><a href="#2、对象的解构赋值与函数参数的默认值" class="headerlink" title="2、对象的解构赋值与函数参数的默认值"></a>2、对象的解构赋值与函数参数的默认值</h3><p>对象的解构赋值例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<p>函数 foo 的参数是一个对象，需要传递对象才能对 <code>x</code> 和 <code>y</code> 变量解析；如果不传的参数，那么则会报错。</p>
<p>函数参数指定默认值例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、参数默认值的位置"><a href="#3、参数默认值的位置" class="headerlink" title="3、参数默认值的位置"></a>3、参数默认值的位置</h3><p>通常情况下，指定函数参数的默认值，应该是函数参数的最后一个。</p>
<h3 id="4、函数的-length-属性"><a href="#4、函数的-length-属性" class="headerlink" title="4、函数的 length 属性"></a>4、函数的 length 属性</h3><p><code>length</code> 属性的定义是预期函数传入参数的个数，如果我们指定了函数参数的默认值，那么该参数就不属于预期参数，不能计算进去。即函数 <code>length</code> 属性的值等于函数参数的个数减去指定默认值参数的个数。</p>
<p>需要注意的点：</p>
<ul>
<li><p><code>rest</code> 参数不会计入 <code>length</code> 属性；</p>
</li>
<li><p>如果指定默认值的参数不是尾参数，那么 <code>length</code> 属性的值等于指定默认值参数之前参数的个数。</p>
</li>
</ul>
<h3 id="5、作用域"><a href="#5、作用域" class="headerlink" title="5、作用域"></a>5、作用域</h3><p>当函数参数指定默认值时，函数进行声明初始化时，参数会形成一个单独的作用域；直到初始化结束后，作用域才会消失。</p>
<h1 id="二、rest（…test）"><a href="#二、rest（…test）" class="headerlink" title="二、rest（…test）"></a>二、rest（…test）</h1><p>用于获取函数多余的参数，并将参数存放于数组。<code>rest</code> 参数可以替代 <code>arguments</code>，因为 <code>arguments</code> 是一个类数组的对象，需要使用 <code>Array.prototype.slice.call()</code> 方法将其转为真正的数组；而 <code>rest</code> 参数本身是真正的数组，使用起来很方便。</p>
<p><code>rest</code> 参数必须是函数参数列表中的最后一个参数，否则使用起来会报错。</p>
<h1 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h1><p>ES6 规定：只要函数使用了<strong>默认值</strong>、<strong>解构赋值</strong>或者<strong>扩展运算符</strong>，函数内部就不能显示设定为严格模式；否则使用起来会报错。</p>
<h3 id="规避这种限制的两种方法："><a href="#规避这种限制的两种方法：" class="headerlink" title="规避这种限制的两种方法："></a>规避这种限制的两种方法：</h3><ul>
<li><p>设定全局的严格模式；</p>
</li>
<li><p>把函数包含在一个无参数的立即执行函数里面。（IIF）</p>
</li>
</ul>
<h1 id="四、name-属性"><a href="#四、name-属性" class="headerlink" title="四、name 属性"></a>四、name 属性</h1><p>函数 <code>name</code> 属性，返回函数的名称。但是在 ES6 和 ES5 稍微有点区别，具体表现在：</p>
<ul>
<li><p>如果将一个匿名函数赋值给变量，那么在 ES5 中 <code>name</code> 属性会返回<strong>空字符串</strong>；而 ES6 则会返回实际的函数名称。</p>
</li>
<li><p>如果将一个有具体名称的函数赋值给一个变量，那么在 ES5 和 ES6 中，<code>name</code> 属性返回的值是一样，都是具体的函数名字。</p>
</li>
</ul>
<h1 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h1><h3 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><p>ES6 允许使用 “箭头”（<code>=&gt;</code>）定义函数，称为箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = x =&gt; x;</div><div class="line"></div><div class="line">等同于</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// foo(5)</span></div></pre></td></tr></table></figure>
<p>使用时需要注意的点：</p>
<ul>
<li><p>如果箭头函数不需要参数或者需要多个参数，可以使用<strong>圆括号</strong>代表参数一部分。</p>
</li>
<li><p>如果箭头函数的代码块语句多于一行代码的话，则需要使用大括号将代码块括起来，并且使用 <code>return</code> 语句返回。</p>
</li>
<li><p>如果箭头函数直接返回一个对象，则需要在对象使用<strong>圆括号</strong>将其括起来，否则会报错；或者在对象外使用<strong>大括号</strong>并且 <code>return</code> 语句。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> getTempItem = id =&gt; &#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		id: id,</div><div class="line">		name: <span class="string">"Temp"</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>函数体内的 <code>this</code> 对象，就是<strong>定义时</strong>所在的对象，而<strong>不是使用时</strong>所在的对象。</p>
</li>
<li><p><strong>不可以</strong>当作<strong>构造函数</strong>，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</p>
</li>
<li><p><strong>不可以</strong>使用 <code>arguments</code> 对象，该对象在函数体内<strong>不存在</strong>。如果要用，可以用 <code>rest</code> 参数代替。</p>
</li>
<li><p><strong>不可以</strong>使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数。</p>
</li>
<li><p><code>arguments</code>、<code>super</code>、<code>new.target</code> 这三个变量在箭头函数中是不存在的，而是指向外层函数的变量。</p>
</li>
<li><p>由于箭头函数没有自己的 <code>this</code>，因此也就无法使用 <code>call()</code>、<code>apply()</code> 和 <code>bind()</code> 改变 <code>this</code> 指向。</p>
</li>
<li><p>在箭头函数中，<code>this</code> 的指向是固定的。原因是因为箭头函数内部没有自己的 <code>this</code>，导致内部的 <code>this</code> 就是外部代码块的 <code>this</code>。</p>
</li>
</ul>
<h3 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h3><ul>
<li>简化回调函数</li>
</ul>
<h3 id="3、不适合使用场景"><a href="#3、不适合使用场景" class="headerlink" title="3、不适合使用场景"></a>3、不适合使用场景</h3><ul>
<li><p>定义函数的方法，且该方法内部包括 <code>this</code>。</p>
</li>
<li><p>需要动态使用 <code>this</code>。</p>
</li>
</ul>
<h1 id="六、双冒号运算符（提案）"><a href="#六、双冒号运算符（提案）" class="headerlink" title="六、双冒号运算符（提案）"></a>六、双冒号运算符（提案）</h1><p>函数绑定运算符是使用并排的两个冒号 <code>::</code>，双冒号的左边是一个对象，而右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（<code>this</code>），绑定到右边的函数上。</p>
<h1 id="七、尾调用优化"><a href="#七、尾调用优化" class="headerlink" title="七、尾调用优化"></a>七、尾调用优化</h1><h3 id="1、尾调用"><a href="#1、尾调用" class="headerlink" title="1、尾调用"></a>1、尾调用</h3><p>某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> g();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用函数时，会在内存中开辟一块内存空间来存储函数信息，比如变量、调用位置之类的，我们可以称之为 “调用记录”，或者称为 “调用帧”；如果函数内部又调用其它函数，类似的也会有自己的 “调用帧”，以此类推，所有的 “调用帧” 会形成 “调用栈”。</p>
<p>而尾调用是函数最后一步操作，因此不需要外层函数的信息，即不需要保留外层函数的 “调用帧”，而只需要保留内层函数的 “调用帧”，即只保存一条记录，称为 “尾调用优化”。</p>
<h3 id="2、尾递归"><a href="#2、尾递归" class="headerlink" title="2、尾递归"></a>2、尾递归</h3><p>某个函数的最后一步是调用自身函数，称为尾递归。</p>
<p>柯里化：将多参数的函数改为单参数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</div><div class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</div><div class="line"></div><div class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></div></pre></td></tr></table></figure>
<h3 id="3、严格模式"><a href="#3、严格模式" class="headerlink" title="3、严格模式"></a>3、严格模式</h3><p>ES6 规定尾调用递归只在严格模式下生效，正常模式时无效的。</p>
<p>正常模式下，函数内部有两个变量可以跟踪函数调用栈：</p>
<ul>
<li><p><code>func.arguments</code>：返回调用时函数的参数。</p>
</li>
<li><p><code>func.caller</code>：返回调用当前函数的那个函数。</p>
</li>
</ul>
<p>但是在严格模式下禁用这两个变量。</p>
<h3 id="4、尾递归优化的实现"><a href="#4、尾递归优化的实现" class="headerlink" title="4、尾递归优化的实现"></a>4、尾递归优化的实现</h3><ul>
<li><p>为了减少调用栈，可以使用<strong>循环</strong>替代递归。</p>
</li>
<li><p>蹦床函数：每一步返回一个函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fun <span class="comment">/*, args */</span></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> result = fun.apply(fun, _.rest(<span class="built_in">arguments</span>));</div><div class="line">  		<span class="keyword">while</span> (_.isFunction(result)) &#123;</div><div class="line">  			result = result();</div><div class="line">  		&#125;</div><div class="line">  		<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="八、函数参数的尾逗号"><a href="#八、函数参数的尾逗号" class="headerlink" title="八、函数参数的尾逗号"></a>八、函数参数的尾逗号</h1><p>ES7 允许函数的最后一个参数可以有尾逗号。</p>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="external">函数的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、函数参数的默认值&quot;&gt;&lt;a href=&quot;#一、函数参数的默认值&quot; class=&quot;headerlink&quot; title=&quot;一、函数参数的默认值&quot;&gt;&lt;/a&gt;一、函数参数的默认值&lt;/h1&gt;&lt;h3 id=&quot;1、基本用法&quot;&gt;&lt;a href=&quot;#1、基本用法&quot; class=&quot;
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>数值的扩展</title>
    <link href="http://panzeyong.com/2019/03/03/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/03/数值的扩展/</id>
    <published>2019-03-03T09:37:39.000Z</published>
    <updated>2020-08-29T09:44:40.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、二进制和八进制的表示法"><a href="#1、二进制和八进制的表示法" class="headerlink" title="1、二进制和八进制的表示法"></a>1、二进制和八进制的表示法</h3><p>从 ES5 开始，在严格模式下，不允许使用前缀 <code>0</code> 来表示八进制，否则会报错。在ES 6 中，提供了新的表示方法，即用前缀 <code>0b</code> 或者 <code>0B</code> 表示二进制，<code>0o</code> 或者 <code>0O</code> 表示八进制。</p>
<h3 id="2、安全整数"><a href="#2、安全整数" class="headerlink" title="2、安全整数"></a>2、安全整数</h3><p>JavaScript 能够准确表示整数范围为 <code>-2^53</code> ~ <code>2^53</code>（不包括两端），超过这个范围，计算就不准确了。ES6 提供两个常量来表示最大值和最小值：</p>
<ul>
<li><p><code>Number.MAX_SAFE_INTEGER</code>：最大安全整数，9007199254740991。</p>
</li>
<li><p><code>Number.MIN_SAFE_INTEGER</code>：最小安全整数，-9007199254740991。</p>
</li>
</ul>
<h3 id="3、Number-对象提供方法"><a href="#3、Number-对象提供方法" class="headerlink" title="3、Number 对象提供方法"></a>3、Number 对象提供方法</h3><ul>
<li><p><code>Number.isFinite()</code>：检查一个数值是否有限的（finite），即不是 <code>Infinity</code>。需要注意的是：<strong>参数类型不是数值，一律返回 <code>false</code>。</strong></p>
</li>
<li><p><code>Number.isNaN()</code>：检查一个值是否为 <code>NaN</code>。需要注意的是：<strong>参数类型不是 NaN，一律返回 <code>false</code>。</strong></p>
<p>  与传统方法 <code>isFiniter</code> 和 <code>isNaN</code> 的区别：传统方法需要先将非数值转换为数值，然后再进行判断，而新方法直接对数值进行判断。</p>
</li>
<li><p><code>Number.parseInt()</code>：与传统全局方法 <code>parseInt()</code> 行为实现完全一样。</p>
</li>
<li><p><code>Number.parseFloat()</code>：与传统全局方法 <code>parseFloat()</code> 行为实现完全一样。</p>
</li>
<li><p><code>Number.isInteger()</code>：判断一个数值是否为整数。在 JaveScript 内部，整数和浮点数采用的是同样的存储方法，因此 20 与 20.0 是同一个值。需要注意的是：<strong>参数类型不是数值，一律返回 <code>false</code>，以及精确度。</strong></p>
</li>
<li><p><code>Number.EPSILON()</code>：一个极小的常量，表示 1 和大于 1 的最小浮点数之间的差。可以用来计算浮点数时，设置可以接受的最小误差范围。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.EPSILON</div><div class="line"><span class="comment">// 2.220446049250313e-16</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>Number.isSafeInteger()</code>：用来判断一个数是否落在安全整数范围内。在验证的过程中，不仅要验证运算结果，还要验证参与运算的值。</li>
</ul>
<h3 id="4、Math-对象的扩展"><a href="#4、Math-对象的扩展" class="headerlink" title="4、Math 对象的扩展"></a>4、Math 对象的扩展</h3><ul>
<li><p><code>Math.trunc()</code>：去除一个数的小数部分，返回整数部分。对于非数值，内部先使用 <code>Number</code> 方法将其转换为数值；对于空值和无法截取整数的值，则返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.sign()</code>：用来判断一个值是正数、负数和零，对于非数值，会先将其返回数值。返回值有 5 种情况：</p>
<ul>
<li><p><code>+1</code>：正数；</p>
</li>
<li><p><code>-1</code>：负数；</p>
</li>
<li><p><code>0</code>：0；</p>
</li>
<li><p><code>-0</code>：-0；</p>
<p><code>NaN</code>：其他值。</p>
</li>
</ul>
</li>
<li><p><code>Math.cbrt()</code>：用于计算一个数的立方根，对于非数值，内部先使用 <code>Number</code> 方法将其转换为数值。</p>
</li>
<li><p><code>Math.clz32()</code>：将参数转为 32 位无符号整数的形式，返回 32 位值里面有多少个 0。对于小数，只考虑整数部分；对于空值或者其它类型的，会先将他们转换为数值。</p>
</li>
<li><p><code>Math.imul()</code>：返回两个数以 32 位带符号整数形式相乘的结果，可以返回正确的低位数值。</p>
</li>
<li><p><code>Math.fround()</code>：返回一个数的 32 位单精度浮点数形式。对于 <code>NaN</code> 和 <code>Infinity</code> 此方法返回原值；对于其它类型的值，会先将它们转为数值，再返回单精度浮点数。</p>
<p>  对于 32 位单精度浮点数格式来说，数值精度是 24 个二进制位（1 + 23），范围 -2^24 ~ 2^24。</p>
</li>
<li><p><code>Math.hypot()</code>：返回所有参数的平方和的平方根。对于非数值，会先将它们转为数值。</p>
</li>
</ul>
<h3 id="5、对数方法"><a href="#5、对数方法" class="headerlink" title="5、对数方法"></a>5、对数方法</h3><ul>
<li><p><code>Math.expm1()</code>：返回 e^x - 1，即 <code>Math.exp(x) - 1</code>。</p>
</li>
<li><p><code>Math.log1p()</code>：返回 <code>1 + x</code> 的自然对数，即 <code>Math.log(1 + x)</code>。如果 x 小于 -1，返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.log10()</code>：返回以 10 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.log2()</code>：返回以 2 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 <code>NaN</code>。</p>
</li>
</ul>
<h3 id="6、双曲函数方法"><a href="#6、双曲函数方法" class="headerlink" title="6、双曲函数方法"></a>6、双曲函数方法</h3><ul>
<li><p><code>Math.sinh(x)</code>：返回 <code>x</code> 的双曲正弦。</p>
</li>
<li><p><code>Math.cosh(x)</code>：返回 <code>x</code> 的双曲余弦。</p>
</li>
<li><p><code>Math.tanh(x)</code>：返回 <code>x</code> 的双曲正切。</p>
</li>
<li><p><code>Math.asinh(x)</code>：返回 <code>x</code> 的反双曲正弦。</p>
</li>
<li><p><code>Math.acosh(x)</code>：返回 <code>x</code> 的反双曲余弦。</p>
</li>
<li><p><code>Math.atanh(x)</code>：返回 <code>x</code> 的反双曲正切。</p>
</li>
</ul>
<h3 id="7、指数运算符"><a href="#7、指数运算符" class="headerlink" title="7、指数运算符"></a>7、指数运算符</h3><p><code>**</code>：指数运算符，有个特点是右结合。</p>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/number#Math-sign" target="_blank" rel="external">数值的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、二进制和八进制的表示法&quot;&gt;&lt;a href=&quot;#1、二进制和八进制的表示法&quot; class=&quot;headerlink&quot; title=&quot;1、二进制和八进制的表示法&quot;&gt;&lt;/a&gt;1、二进制和八进制的表示法&lt;/h3&gt;&lt;p&gt;从 ES5 开始，在严格模式下，不允许使用前缀 &lt;c
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="http://panzeyong.com/2019/03/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/03/字符串的扩展/</id>
    <published>2019-03-03T07:14:34.000Z</published>
    <updated>2020-08-29T09:40:38.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、字符串的遍历接口"><a href="#1、字符串的遍历接口" class="headerlink" title="1、字符串的遍历接口"></a>1、字符串的遍历接口</h3><p><code>for...of</code> 不仅能遍历字符串，还能识别大于 <code>0xFFFF</code> 的码点，但是传统的 <code>for</code> 循环是无法识别的。</p>
<h3 id="2、字符串实例方法"><a href="#2、字符串实例方法" class="headerlink" title="2、字符串实例方法"></a>2、字符串实例方法</h3><ul>
<li><p><code>normalize()</code>：将字符串的不同表示方法统一为同样的形式，称为 Unicode 正规化。(Unicode 提供两种方法：一种是直接提供带重音符号的字符；另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，)</p>
<p>  <code>normalize</code> 方法提供一个参数来指定 <code>normalize</code> 的方式，共有四个选项：</p>
<ul>
<li><p><code>NFC</code>：默认参数，表示 “标准等价合成”，返回合成字符；</p>
</li>
<li><p><code>NFD</code>：表示 “标准等价分解”；</p>
</li>
<li><p><code>NFKC</code>：表示 “兼容等价合成”，返回合成字符；</p>
</li>
<li><p><code>NFKD</code>：表示 “兼容等价分解”。</p>
</li>
</ul>
</li>
<li><p>对于一个字符串是否包含在另一个字符串中，ES6 提供了三个新方法：</p>
<ul>
<li><p><code>includes()</code>：表示是否找到了参数字符串，返回布尔值。</p>
</li>
<li><p><code>startsWith()</code>：表示参数字符串是否在原字符串的头部，返回布尔值。</p>
</li>
<li><p><code>endsWith()</code>：表示参数字符串是否在原字符串的尾部，返回布尔值。</p>
<p>  这三个方法都接受两个参数：参数字符串 str 和从原始字符串开始搜索的位置 n。</p>
</li>
</ul>
</li>
<li><p><code>repeat()</code>：表示将原字符串复制 n 次，返回新的字符串。对于参数，有几种情况需要注意下：</p>
<ul>
<li><p>参数是小数时，会被取整；</p>
</li>
<li><p>参数是负数或者 Infinity，会报错；</p>
</li>
<li><p>参数是 0 ~ 1 之间的小数，则视为 0；</p>
</li>
<li><p>参数是 0 ~ -1 之间，也视为 0；</p>
</li>
<li><p>参数是 NaN，视为 0；</p>
</li>
<li><p>参数是字符串，会先转为数字。</p>
</li>
</ul>
</li>
<li><p>字符串补全功能的两个方法：</p>
<ul>
<li><p><code>padStart()</code>：头部补全。</p>
</li>
<li><p><code>padEnd()</code>：尾部补全。</p>
<p>  这两个方法共接受两个参数：第一个参数是字符串补全生效的最大长度，第二个参    数是用来补全的字符串。对于方法的使用，需要说明的点如下：</p>
<ul>
<li><p>如果原字符串的长度，大于或等于最大长度，则补全字符串失效，返回原字符串；</p>
</li>
<li><p>如果用来补全的字符串和原字符串，两者的长度超过最大长度，那么则会截出超出位数的补全字符串；</p>
</li>
<li><p>如果省略第二个参数，则会用空格来表示。</p>
<p><code>padStart()</code> 的用途：</p>
</li>
<li><p>为数值补全指定位数；</p>
</li>
<li><p>提示字符串格式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>matchAll()</code>：返回一个正则表达式在字符串中的所有匹配。</p>
<h3 id="3、String-对象提供的方法"><a href="#3、String-对象提供的方法" class="headerlink" title="3、String 对象提供的方法"></a>3、String 对象提供的方法</h3><p><code>String.raw()</code>：充当字符串模板的处理函数，返回一个斜杆都被转义的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 返回 "Hi\\u000A!"</span></div></pre></td></tr></table></figure>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://es6.ruanyifeng.com/#docs/string" target="_blank" rel="external">字符串的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、字符串的遍历接口&quot;&gt;&lt;a href=&quot;#1、字符串的遍历接口&quot; class=&quot;headerlink&quot; title=&quot;1、字符串的遍历接口&quot;&gt;&lt;/a&gt;1、字符串的遍历接口&lt;/h3&gt;&lt;p&gt;&lt;code&gt;for...of&lt;/code&gt; 不仅能遍历字符串，还能识别大于 
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="http://panzeyong.com/2019/02/20/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://panzeyong.com/2019/02/20/变量的解构赋值/</id>
    <published>2019-02-20T14:41:08.000Z</published>
    <updated>2020-08-29T09:40:58.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、理解解构（Destructuring）"><a href="#一、理解解构（Destructuring）" class="headerlink" title="一、理解解构（Destructuring）"></a>一、理解解构（Destructuring）</h1><p>ES6 允许按照一定的模式，从对象和数组提取值，相应地赋值给对应的变量，简单来说，只要等号两边的模式相匹配，变量就会被赋予相应的值，我们把它称为<strong>解构</strong>赋值。</p>
<h1 id="二、支持变量解构的数据类型"><a href="#二、支持变量解构的数据类型" class="headerlink" title="二、支持变量解构的数据类型"></a>二、支持变量解构的数据类型</h1><h2 id="1、数组的解构赋值"><a href="#1、数组的解构赋值" class="headerlink" title="1、数组的解构赋值"></a>1、数组的解构赋值</h2><h3 id="解构赋值类型"><a href="#解构赋值类型" class="headerlink" title="解构赋值类型"></a>解构赋值类型</h3><ul>
<li>完全解构：等号左右两边的模式相匹配，变量被赋予相应的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<ul>
<li>不完全解构：等号左边的模式只匹配等号右边数组的一部分，这种情况解构是成功的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h3 id="解构满足的条件"><a href="#解构满足的条件" class="headerlink" title="解构满足的条件"></a>解构满足的条件</h3><ul>
<li><p>等号右边的数据结构具有 Iterator 接口，否则会报错；</p>
</li>
<li><p>Set 结构也可以使用数组解构赋值。</p>
</li>
</ul>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值，默认值生效的条件：ES6 内部使用严格相等运算符 <code>===</code> 来判断一个位置是否有值，因此，只有当数组中的成员严格等于 <code>undefined</code>，默认值才会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]    <span class="comment">// x: 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]    <span class="comment">// x: null</span></div></pre></td></tr></table></figure>
<p>默认值可以是一个<strong>表达式</strong>，但是该表达式是<strong>惰性</strong>求值的，只有当用到</p>
<p>的时候，才会使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"默认值可是一个表达式"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = example()] = [<span class="number">1</span>];    <span class="comment">// 此时因为变量 x 能取到值 1，使得函数 example 不会被执行。</span></div></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其它变量，前提是这些变量被声明。</p>
<h2 id="2、对象的解构赋值"><a href="#2、对象的解构赋值" class="headerlink" title="2、对象的解构赋值"></a>2、对象的解构赋值</h2><p>与数组的解构赋值相比，有一点明显不同的是与对象属性的顺序没有关系，变量必须与属性名相同，才能获取相应的值。对象的解构赋值的真正形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;a: b, c: d&#125; = &#123;a: <span class="string">"test"</span>, c: <span class="string">"str"</span>&#125;</div></pre></td></tr></table></figure>
<p>a，b 是匹配模式，而 b，d 才是变量，被赋值的是后者，而不是前者。对象的解构赋值有简洁的表达形式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;a, c&#125; = &#123;a: <span class="string">"test"</span>, c: <span class="string">"str"</span>&#125;</div></pre></td></tr></table></figure>
<p>这种表达形式必须满足的条件是变量名与属性名必须相同。</p>
<p>解构也可以用于嵌套结构的对象</p>
<p>对象的解构也可以指定默认值，与数组的解构一样，默认值生效的条件是对象的属性值严格等于 <code>undefined</code>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>如果解构模式是嵌套的对象，并且子对象所在的父属性不存在，这种情况下会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>如果将一个已经声明的变量用于解构赋值，那么此时就得小心，有可能会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</div><div class="line">&#123;x&#125; = &#123;x: <span class="number">8</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line">(&#123;x&#125; = &#123;x:<span class="number">8</span>&#125;)</div></pre></td></tr></table></figure>
<p>JavaScript 引擎会将以大括号开头的代码解析成代码块，从而造成语法错误。要避免此错误的发生，则将其放在圆括号里面。</p>
<h2 id="3、字符串的解构赋值"><a href="#3、字符串的解构赋值" class="headerlink" title="3、字符串的解构赋值"></a>3、字符串的解构赋值</h2><p>字符串解构赋值时，会被转换成一个类似字数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c, d, e, f] = [<span class="string">"script"</span>];</div></pre></td></tr></table></figure>
<h2 id="4、数值和布尔值的解构赋值"><a href="#4、数值和布尔值的解构赋值" class="headerlink" title="4、数值和布尔值的解构赋值"></a>4、数值和布尔值的解构赋值</h2><p>如果等号右边的值不是数组或者对象时，在解构时，会将其先转换为对象。但是有比较特殊的情况是无法转换为对象，即 <code>null</code> 和 <code>undefined</code>，因此对它们解构赋值时是会报错的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;s: toString &#125; = <span class="number">123</span>;</div><div class="line"></div><div class="line">=&gt;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = <span class="number">123</span>,</div><div class="line">    s = _.toString;</div></pre></td></tr></table></figure>
<h2 id="5、函数参数的解构赋值"><a href="#5、函数参数的解构赋值" class="headerlink" title="5、函数参数的解构赋值"></a>5、函数参数的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为 x、y 指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;&#125;)    <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// 为 move 参数指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;&#125;)    <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
<h1 id="三、圆括号问题"><a href="#三、圆括号问题" class="headerlink" title="三、圆括号问题"></a>三、圆括号问题</h1><h2 id="1、不能使用圆括号的情况"><a href="#1、不能使用圆括号的情况" class="headerlink" title="1、不能使用圆括号的情况"></a>1、不能使用圆括号的情况</h2><ul>
<li><p>变量声明语句；</p>
</li>
<li><p>函数参数；</p>
</li>
<li><p>赋值语句的模式。</p>
</li>
</ul>
<h2 id="2、可以使用圆括号的情况"><a href="#2、可以使用圆括号的情况" class="headerlink" title="2、可以使用圆括号的情况"></a>2、可以使用圆括号的情况</h2><p>赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(a)] = [<span class="number">8</span>]; <span class="comment">// 正确</span></div><div class="line">(&#123; p: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></div><div class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div></pre></td></tr></table></figure>
<h1 id="四、用途"><a href="#四、用途" class="headerlink" title="四、用途"></a>四、用途</h1><ul>
<li><p>交换变量；</p>
</li>
<li><p>从函数返回多个值；</p>
</li>
<li><p>函数参数的定义；</p>
</li>
<li><p>提取 JSON 数据；</p>
</li>
<li><p>函数参数的默认值；</p>
</li>
<li><p>遍历 Map 结构；</p>
</li>
<li><p>输入模块的指定方法。</p>
</li>
</ul>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">变量的解构赋值</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、理解解构（Destructuring）&quot;&gt;&lt;a href=&quot;#一、理解解构（Destructuring）&quot; class=&quot;headerlink&quot; title=&quot;一、理解解构（Destructuring）&quot;&gt;&lt;/a&gt;一、理解解构（Destructuring）&lt;/
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>let 和 const 命令</title>
    <link href="http://panzeyong.com/2019/02/12/let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/"/>
    <id>http://panzeyong.com/2019/02/12/let-和-const-命令/</id>
    <published>2019-02-12T04:34:36.000Z</published>
    <updated>2020-08-29T09:34:50.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、let-命令"><a href="#一、let-命令" class="headerlink" title="一、let 命令"></a>一、let 命令</h1><h3 id="1、let-的特点"><a href="#1、let-的特点" class="headerlink" title="1、let 的特点"></a>1、let 的特点</h3><ul>
<li><p><strong>只在声明的代码块生效</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>不存在变量提升</strong>：变量必须在声明之后才能使用，否则会报错；</p>
</li>
<li><p><strong>暂时性死区</strong>：在块级作用域内，使用 let 命令声明的变量，该变量就绑定了该作用域，形成一个封闭的作用域，这时如果在未声明变量前使用该变量，就会报错；也就是说，变量未声明时，是不能使用该变量的，把这种现象称为 “暂时性死区”。</p>
</li>
<li><p><strong>不允许重复</strong>：在相同作用域内，不允许声明相同的变量；</p>
</li>
<li><p><strong>块级作用域</strong>：内部作用域可以访问外部作用域的变量，但是外部作用域无法访问内部作用域的变量。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错：在相同作用域内声明相同变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> a = <span class="number">8</span>;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">9</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不会报错：因为 arg 处于不同作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">let</span> arg = <span class="number">8</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="number">8</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">	<span class="built_in">console</span>.log(test);    <span class="comment">// 报错</span></div><div class="line">	<span class="keyword">let</span> test = <span class="number">9</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、let-应用场景"><a href="#2、let-应用场景" class="headerlink" title="2、let 应用场景"></a>2、let 应用场景</h3><ul>
<li><p>for 循环计数器很适合使用 let 命令；</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">	b[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'Function: '</span> + i);</div><div class="line">   	&#125;;</div><div class="line">   	<span class="built_in">console</span>.log(b[i]);</div><div class="line">&#125;</div><div class="line">b[<span class="number">6</span>]();    <span class="comment">// 6（如果上述 i 使用 var 声明的话，那么输出的结果则为 10）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、const-命令"><a href="#二、const-命令" class="headerlink" title="二、const 命令"></a>二、const 命令</h1><h3 id="1、const-特点"><a href="#1、const-特点" class="headerlink" title="1、const 特点"></a>1、const 特点</h3><ul>
<li><p>声明只读常量，一旦声明之后，其值是不能修改的；</p>
</li>
<li><p>声明变量时，必须初始化，否则会报错；</p>
</li>
<li><p>只在所声明的块级作用域内有效；</p>
</li>
<li><p>不存在变量提升；</p>
</li>
<li><p>暂时性死区；</p>
</li>
<li><p>不允许重复。</p>
</li>
</ul>
<h3 id="2、本质"><a href="#2、本质" class="headerlink" title="2、本质"></a>2、本质</h3><p><code>const</code> 命令声明的变量的值不变，是指其变量所指向的内存地址保存的值是不变的，这对于基本数据类型（字符串、整型）来说是生效的；但是对于复合类型（数组和对象）来说就有区别了，比如一个变量保存一个对象，此时该变量是存储在栈中，保存的是对象的内存地址，而对象的数据结构是存储在堆中，也就是说，变量指向的是对象在堆中的内存地址，对于 <code>const</code> 命令来说，不变的是其内存地址，至于对象的数据结构变或者不变，<code>const</code> 就无法控制了。</p>
<p>如果想让对象及对象的属性不变，可以将对象<strong>冻结</strong>，及采用方法 <code>Object.freeze(obj)</code></p>
<h1 id="三、ES6-规定要点"><a href="#三、ES6-规定要点" class="headerlink" title="三、ES6 规定要点"></a>三、ES6 规定要点</h1><ul>
<li><p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
</li>
<li><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p>
</li>
<li><p>var 命令和 function 命令声明的全局变量，依然属于顶层对象 <code>window</code>（这里的环境是指浏览器）的属性，兼容 ES5；而使用 let 和 const 命令声明的全局变量，不再属于顶层对象 <code>window</code> 的属性，即在 ES6 中，顶层对象的属性与全局变量脱钩。</p>
</li>
</ul>
<h1 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h1><ul>
<li><p>for 循环包含两个独立的作用域，循环变量包含的部分是一个<strong>父作用域</strong>，而循环体内包含的部分是一个<strong>子作用域</strong>。因此，即使循环变量和循环体内声明的变量的名字是相同，但是其实它们是处在两个独立的作用域内，互不影响。</p>
</li>
<li><p>不同环境顶层对象不一样，表现在：</p>
<ul>
<li><p>浏览器的顶层对象指向的是 <code>window</code>、<code>self</code>；</p>
</li>
<li><p>Web Worker 的顶层对象指向的是 <code>self</code>；</p>
</li>
<li><p>Node 的顶层对象指向的是 <code>global</code>。</p>
</li>
</ul>
</li>
</ul>
<h1 id="五、ES6-声明变量的六种方法"><a href="#五、ES6-声明变量的六种方法" class="headerlink" title="五、ES6 声明变量的六种方法"></a>五、ES6 声明变量的六种方法</h1><ul>
<li><p>var</p>
</li>
<li><p>function</p>
</li>
<li><p>let</p>
</li>
<li><p>const</p>
</li>
<li><p>import</p>
</li>
<li><p>class</p>
</li>
</ul>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="external">let 和 const 命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、let-命令&quot;&gt;&lt;a href=&quot;#一、let-命令&quot; class=&quot;headerlink&quot; title=&quot;一、let 命令&quot;&gt;&lt;/a&gt;一、let 命令&lt;/h1&gt;&lt;h3 id=&quot;1、let-的特点&quot;&gt;&lt;a href=&quot;#1、let-的特点&quot; class=&quot;he
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码目录结构</title>
    <link href="http://panzeyong.com/2018/12/19/Vue%20%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://panzeyong.com/2018/12/19/Vue 源码目录结构/</id>
    <published>2018-12-19T14:33:04.000Z</published>
    <updated>2020-08-29T08:48:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>今年 4 月份开始使用 Vue.js，到现在差不多有 8 个月了，参与了两三个项目，对 Vue.js 的用法有了一定的了解。但是我觉得会使用是学习框架的第一步，第二步是研究框架是怎么实现的，学习其设计思想。所以给自己制定了计划来学习 Vue.js 框架源码，打算把自己学习到的知识作为一个系列记录下来。</p>
<p>在学习源码之前，先来学习下 Vue.js 目录结构设计，从整体上了解 Vue.js 的结构。</p>
<p>注：Vue.js 的版本为 2.6.11</p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul>
<li><p><code>.circleci</code>：Vue.js 使用了持续集成工具 CircleCI，要在项目中使用该工具，需要在项目根目录创建文件夹 <code>.circleci</code>，并在其目录下创建文件 <code>config.yml</code> 编写构建脚本。</p>
<ul>
<li><code>config.yml</code>：编写 CircleCI 构建脚本。</li>
</ul>
</li>
<li><p><code>.github</code>：项目相关说明文档，比如开发者参与项目的规则、要求之类的。</p>
<p>  <code>CODE_OF_CONDUCT.md</code>：贡献代码的行为准则。</p>
<p>  <code>COMMIT_CONVENTION.md</code>：git 提交代码时添加提交信息的约定。</p>
<p>  <code>CONTRIBUTING.md</code>：参与项目指南。</p>
<p>  <code>ISSUE_TEMPLATE.md</code>：提交 issue 的模板。</p>
<p>  <code>PULL_REQUEST_TEMPLATE.md</code>：拉取代码指南。</p>
</li>
<li><p><code>benchmarks</code>：性能测试相关文件。</p>
</li>
<li><p><code>dist</code>：包含不同分发版本的构建文件。要注意的是，这个目录只有在发布新版本时才会更新，开发分支更新的新特性不会影响到该目录。</p>
</li>
<li><p><code>example</code>：官方提供的示例。</p>
</li>
<li><p><code>flow</code>：包含使用Flow（静态类型检查工具）声明的类型，供全局使用。</p>
<ul>
<li><p><code>compiler.js</code>：编译相关。</p>
</li>
<li><p><code>component.js</code>：组件数据结构。</p>
</li>
<li><p><code>global-api.js</code>：Global API 结构。</p>
</li>
<li><p><code>modules.js</code>：第三方库定义。</p>
</li>
<li><p><code>options.js</code>：选项相关。</p>
</li>
<li><p><code>ssr.js</code>：服务端渲染相关。</p>
</li>
<li><p><code>vnode.js</code>：虚拟 node 相关。</p>
</li>
<li><p><code>weex.js</code>：weex 平台相关。</p>
</li>
</ul>
</li>
<li><p><code>packages</code>：包含服务端渲染和模板编译器两种不同 NPM 包，供不同场景使用。</p>
<ul>
<li><p><code>vue-server-render</code>：服务端渲染。</p>
</li>
<li><p><code>vue-template-compiler</code>：vue 模板编译器。</p>
</li>
<li><p><code>weex-template-compiler</code>：weex 模板编译器。</p>
</li>
<li><p><code>weex-vue-framework</code>：weex vue 框架。</p>
</li>
</ul>
</li>
<li><p><code>scripts</code>：包含构建相关脚本和配置文件，大多数情况下不需要关注该目录。</p>
<ul>
<li><p><code>alias.js</code>：所有源代码和测试中使用的模块导入别名。</p>
</li>
<li><p><code>config</code>：包含 <code>dist</code> 目录下所有文件的配置信息。</p>
</li>
</ul>
</li>
<li><p><code>src</code>：vue.js 源代码，代码用 ES6 实现的并采用 JavaScript 静态类型检查工具。</p>
<ul>
<li><p><code>compiler</code>：该目录包含 Vue.js 编译的相关代码，包括将模板字符串解析成 AST 语法树的<strong>解析器</strong>、检测用于 vdom 渲染优化的静态树的<strong>优化器</strong>和将 AST 语法树生成渲染函数的<strong>代码生成器</strong>。</p>
</li>
<li><p><code>core</code>：Vue.js 核心代码，包含通用、跨平台的代码。主要有观察者、虚拟 dom、vue 实例化、全局 api 和内置组件。</p>
</li>
<li><p><code>server</code>：包含与服务端渲染相关的代码。</p>
</li>
<li><p><code>platform</code>：Vue.js 是一个跨平台的 MVVM 框架，可以在 web 上运行，也可以配合 weex 在 native 客户端上运行。每个平台都有一个入口，都位于该目录下。</p>
</li>
<li><p><code>sfc</code>：包含将 .vue 单文件解析为 JavaScript 对象的代码，用于 <code>vue-template-compiler</code> 包。</p>
</li>
<li><p><code>shared</code>：包含通用的工具方法，用于浏览器端的 vue.js 和服务器端的 vue.js。</p>
</li>
</ul>
</li>
<li><p><code>tests</code>：所有测试代码，单元测试代码是用 <a href="https://jasmine.github.io/2.3/introduction.html" target="_blank" rel="external">Jasmine</a> 实现并与 <a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="external">Karma</a> 一起运行。e2e 测试是为 <a href="http://nightwatchjs.org/" target="_blank" rel="external">Nightwatch.js</a> 编写并与之一起运行。</p>
</li>
<li><p><code>types</code>：使用 TypeScript 类型注释，并且包含了测试代码。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#project-structure" target="_blank" rel="external">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#project-structure</a></p>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html#compiler" target="_blank" rel="external">https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html#compiler</a></p>
<p><a href="https://segmentfault.com/a/1190000016426470" target="_blank" rel="external">https://segmentfault.com/a/1190000016426470</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年 4 月份开始使用 Vue.js，到现在差不多有 8 个月了，参与了两三个项目，对 Vue.js 的用法有了一定的了解。但是我觉得会使用是学习框架的第一步，第二步是研究框架是怎么实现的，学习其设计思想。所以给自己制定了计划来学习 Vue.js 框架源码，打算把自己学习到
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 静态类型检查工具：Flow</title>
    <link href="http://panzeyong.com/2018/12/04/JavaScript-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%EF%BC%9AFlow/"/>
    <id>http://panzeyong.com/2018/12/04/JavaScript-静态类型检查工具：Flow/</id>
    <published>2018-12-04T15:01:32.000Z</published>
    <updated>2020-08-29T08:48:13.372Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flow.org/en/" target="_blank" rel="external">Flow</a> 是 Facebook 开源的 JavaScript 静态类型检查工具，它可以帮助提高我们的工作效率，使我们的代码更快、更智能、更自信和更大规模。</p>
<p>在学习 Flow 的用法之前，我们先来学习如何在项目中使用 Flow。</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h3 id="1、安装编译器"><a href="#1、安装编译器" class="headerlink" title="1、安装编译器"></a>1、安装编译器</h3><p>在 Flow 官方文档可以了解到，安装 Flow 的方式多种，主要取决于项目使用什么工具。Flow 可以通过包管理器来安装，即 npm 或 yarn，而在安装 Flow 时，需要设置编译器，有两种编译器：Babel 和 flow-remove-types，所以总共有 4 种安装方式。这里包管理器为 npm 和 编译器为 Babel 为例子来说。</p>
<ul>
<li><p>设置编译器</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-cli babel-preset-flow</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在项目根目录创建 <code>.babelrc</code> 文件，并添加以下代码</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="attr">"presets"</span>: [<span class="string">"flow"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果所有源文件都存储在 <code>src</code> 目录下，那么可以通过运行以下命令，把它们编译到另外一个目录</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/babel src/ -d lib/</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在 <code>package.json</code> 文件 <code>script</code> 添加代码</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"my-project"</span>,</div><div class="line">	<span class="attr">"main"</span>: <span class="string">"lib/index.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">  		<span class="attr">"build"</span>: <span class="string">"babel src/ -d lib/"</span>,</div><div class="line">    	<span class="attr">"prepublish"</span>: <span class="string">"npm run build"</span></div><div class="line">  	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、安装-Flow"><a href="#2、安装-Flow" class="headerlink" title="2、安装 Flow"></a>2、安装 Flow</h3><ul>
<li><p>安装 flow-bin</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	npm install --save-dev flow-bin</div><div class="line">	``` </div><div class="line">	</div><div class="line">- 在 `package.json` 文件 `script` 添加 Flow</div><div class="line"></div><div class="line">	```json</div><div class="line">	&#123;</div><div class="line">  &quot;name&quot;: &quot;my-flow-project&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    	&quot;flow-bin&quot;: &quot;^0.87.0&quot;</div><div class="line">  	 &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    	&quot;flow&quot;: &quot;flow&quot;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>初始化 Flow，会生成文件 <code>.flowconfig</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run flow init</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>运行 Flow</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run flow</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、Flow-的工作方式"><a href="#二、Flow-的工作方式" class="headerlink" title="二、Flow 的工作方式"></a>二、Flow 的工作方式</h1><p>Flow 类型检查有两种方式：</p>
<ul>
<li><p>类型推断：结合变量的上下文语境推断出变量的数据类型，然后根据推断出的数据类型进行类型检查。</p>
</li>
<li><p>类型注释：在定义变量时声明其数据类型，Flow 会基于声明的数据类型作出判断。</p>
</li>
</ul>
<h3 id="1、类型推断"><a href="#1、类型推断" class="headerlink" title="1、类型推断"></a>1、类型推断</h3><p>类型推断这种类型检查方式对于开发者来说工作量几乎为零，基本不需要对代码作任何改造，Flow 会根据变量的上下文推断出类型，进而作出判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n; </div><div class="line">&#125;</div><div class="line"></div><div class="line">square(<span class="string">"2"</span>);    <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>Flow 检查上述代码会报错，因为函数 square 期待输入的参数是整型，而我们输入的是字符串。</p>
<h3 id="2、类型注释"><a href="#2、类型注释" class="headerlink" title="2、类型注释"></a>2、类型注释</h3><p>在某些场景下，通过类型推断是检查不出类型错误的，这时就需要通过其它方式来检查类型，也就是这部分要说的类型注释。类型注释是说在定义变量时声明其数据类型，有点类似静态语言，比如 Java，Flow 会基于此作出判断。</p>
<p>先来看一个通过类型推断检查不出错误的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*@flow*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="string">'Hello'</span>, <span class="number">222</span>)</div></pre></td></tr></table></figure>
<p>以上代码，从语法上看没有错误，<code>+</code> 既可以用在字符串上，也可以用在整型上，而且我们并没有指出函数 <code>add</code> 参数必须为整型，其实我们期望的是两个整型相加，为了达到这目的，我们可以指定变量的类型，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="string">'Hello'</span>, <span class="number">222</span>)    <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>此时，我们指定变量 <code>x</code> 和 <code>y</code> 的数据类型为整型，而我们传递的参数中有一个是字符串，那么 Flow 检查类型就会报错。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="external">https://flow.org/en/docs/getting-started/</a></p>
</li>
<li><p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F" target="_blank" rel="external">https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://flow.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flow&lt;/a&gt; 是 Facebook 开源的 JavaScript 静态类型检查工具，它可以帮助提高我们的工作效率，使我们的代码更快、更智能、更自信
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《Python3 网络爬虫开发实战》问题汇总（持续更新......）</title>
    <link href="http://panzeyong.com/2018/12/04/%E3%80%8APython3-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://panzeyong.com/2018/12/04/《Python3-网络爬虫开发实战》问题汇总/</id>
    <published>2018-12-04T14:52:32.000Z</published>
    <updated>2018-12-04T14:57:14.049Z</updated>
    
    <content type="html"><![CDATA[<p>mac 系统版本信息：</p>
<ul>
<li>macOS High Sierra </li>
<li>Version 10.13.4</li>
</ul>
<h3 id="1、安装-ChromeDriver"><a href="#1、安装-ChromeDriver" class="headerlink" title="1、安装 ChromeDriver"></a>1、安装 ChromeDriver</h3><p>mv: rename chromedriver to /usr/bin/chromedriver: Operation not permitted</p>
<p><a href="https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled" target="_blank" rel="external">解决方案</a></p>
<h3 id="2、安装-Geckodriver"><a href="#2、安装-Geckodriver" class="headerlink" title="2、安装 Geckodriver"></a>2、安装 Geckodriver</h3><p>Permission denied: ‘geckodriver.log’ while running selenium webdriver in python</p>
<p>[解决方案(<a href="https://stackoverflow.com/questions/40466809/permission-denied-geckodriver-log-while-running-selenium-webdriver-in-python" target="_blank" rel="external">https://stackoverflow.com/questions/40466809/permission-denied-geckodriver-log-while-running-selenium-webdriver-in-python</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac 系统版本信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS High Sierra &lt;/li&gt;
&lt;li&gt;Version 10.13.4&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、安装-ChromeDriver&quot;&gt;&lt;a href=&quot;#1、安装-ChromeDriver&quot; c
    
    </summary>
    
      <category term="Python" scheme="http://panzeyong.com/categories/Python/"/>
    
    
      <category term="question" scheme="http://panzeyong.com/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 问题</title>
    <link href="http://panzeyong.com/2018/03/08/JavaScript-%E9%97%AE%E9%A2%98/"/>
    <id>http://panzeyong.com/2018/03/08/JavaScript-问题/</id>
    <published>2018-03-08T09:25:35.000Z</published>
    <updated>2020-08-29T09:07:54.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-数组（包括元素和对象）去重"><a href="#一、JavaScript-数组（包括元素和对象）去重" class="headerlink" title="一、JavaScript 数组（包括元素和对象）去重"></a>一、JavaScript 数组（包括元素和对象）去重</h1><h3 id="1、for-循环"><a href="#1、for-循环" class="headerlink" title="1、for 循环"></a>1、for 循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [array[<span class="number">0</span>]];</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, resultLen = result.length; j &lt; resultLen; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (array[i] === result[j]) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (j === resultLen) &#123;</div><div class="line">			result.push(array[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、indexOf"><a href="#2、indexOf" class="headerlink" title="2、indexOf"></a>2、indexOf</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> res = [];</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">		<span class="keyword">var</span> current = array[i];</div><div class="line">		<span class="keyword">if</span> (res.indexOf(current) === <span class="number">-1</span>) &#123;</div><div class="line">			res.push(current);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、排序后去重"><a href="#3、排序后去重" class="headerlink" title="3、排序后去重"></a>3、排序后去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = [];</div><div class="line">    <span class="keyword">var</span> sortedArray = array.concat().sort();</div><div class="line">    <span class="keyword">var</span> seen;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sortedArray.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="comment">// 如果是第一个元素或者相邻的元素不相同</span></div><div class="line">        <span class="keyword">if</span> (!i || seen !== sortedArray[i]) &#123;</div><div class="line">            res.push(sortedArray[i])</div><div class="line">        &#125;</div><div class="line">        seen = sortedArray[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、ES6-Set"><a href="#4、ES6-Set" class="headerlink" title="4、ES6 Set"></a>4、ES6 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、根据对象属性的唯一值（针对数组元素是对象）"><a href="#5、根据对象属性的唯一值（针对数组元素是对象）" class="headerlink" title="5、根据对象属性的唯一值（针对数组元素是对象）"></a>5、根据对象属性的唯一值（针对数组元素是对象）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">unique(score: Score) &#123;</div><div class="line">    <span class="keyword">this</span>.changedScore.some((item, index) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (item.questionId === score.questionId) &#123;</div><div class="line">        <span class="keyword">this</span>.changedScore.splice(index, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.changedScore = <span class="keyword">this</span>.changedScore.concat(score);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="二、如何防止频繁操作"><a href="#二、如何防止频繁操作" class="headerlink" title="二、如何防止频繁操作"></a>二、如何防止频繁操作</h1><h3 id="1、防抖动"><a href="#1、防抖动" class="headerlink" title="1、防抖动"></a>1、防抖动</h3><ul>
<li><p>原理：当触发事件时，事件必须在 n 秒后才执行，但是当在这 n 秒内又触发事件，事件执行是以最新触发事件的事件为起点，直到这 n 秒内不再触发事件为止，事件才在 n 秒后被执行。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</div><div class="line">	    <span class="keyword">var</span> timeout;</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">	        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">	        </div><div class="line">	        clearTimeout(timeout)</div><div class="line">	        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	            func.apply(context, args)</div><div class="line">	        &#125;, wait);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、节流"><a href="#2、节流" class="headerlink" title="2、节流"></a>2、节流</h3><p>允许一个函数在规定的时间内只执行一次。</p>
<p>实现方法：</p>
<ul>
<li><p>时间戳</p>
</li>
<li><p>定时器</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、JavaScript-数组（包括元素和对象）去重&quot;&gt;&lt;a href=&quot;#一、JavaScript-数组（包括元素和对象）去重&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript 数组（包括元素和对象）去重&quot;&gt;&lt;/a&gt;一、JavaSc
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="知识点整理" scheme="http://panzeyong.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>插入排序：直接插入排序</title>
    <link href="http://panzeyong.com/2018/01/22/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://panzeyong.com/2018/01/22/插入排序：直接插入排序/</id>
    <published>2018-01-22T14:23:30.000Z</published>
    <updated>2018-01-22T15:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发工作中，不管是前端开发还是后端开发，在处理数据时，有时根据业务需求需要对数据进行排序，这就涉及到排序算法的选择。然而排序算法有很多种，对于算法的选择需要根据业务的需求，除此之外，还需要扎实的基本功。最近刚好在学习排序算法，把它记录下来，当作学习笔记。这篇文章要讲的是插入排序中一种：直接插入排序。</p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>排序，简单来说就是把一组无序的元素以正序或者逆序的方式排序，那么至于采取什么方式排序，即是接下来要讲的。<strong>插入排序</strong>的主要思想是将一组元素的第一个元素看作是有序序列，从第二个元素起将待排序的元素插入到有序序列中，使有序序列逐渐扩大，直至所有元素都插入到有序序列中。<strong>直接插入排序</strong>是插入排序的一种，也是比较简单的一种排序方法，以下通过类比的例子来说明直接插入排序的思想。</p>
<p>这里小学上体育课为例子。回想下我们当时上第一节体育课的情景，老师会说：“同学们，先排好队伍，我们再开始上课”。那么此时老师会根据同学们的身高来排队伍，先按身高从低到高排成一排（从左到右站队），再分成 n 行 n 列。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发工作中，不管是前端开发还是后端开发，在处理数据时，有时根据业务需求需要对数据进行排序，这就涉及到排序算法的选择。然而排序算法有很多种，对于算法的选择需要根据业务的需求，除此之外，还需要扎实的基本功。最近刚好在学习排序算法，把它记录下来，当作学习笔记。这篇文章要讲的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第五章 初始化与清理</title>
    <link href="http://panzeyong.com/2017/12/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
    <id>http://panzeyong.com/2017/12/18/第五章-初始化与清理/</id>
    <published>2017-12-18T13:34:19.000Z</published>
    <updated>2018-01-02T23:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、构造器"><a href="#一、构造器" class="headerlink" title="一、构造器"></a>一、构造器</h1><h3 id="1、要点"><a href="#1、要点" class="headerlink" title="1、要点"></a>1、要点</h3><ul>
<li><p>构造器的名称必须与类名完全相同；</p>
</li>
<li><p>构造器是一种特殊类型的方法，没有返回值；</p>
</li>
<li><p>构造器可以重载；</p>
</li>
<li><p>若无构造器则会默认创建无参构造器；否则不会；</p>
</li>
<li><p>构造器有助于减少错误，并使代码更易于阅读。</p>
</li>
</ul>
<h3 id="2、构造器中调用构造器"><a href="#2、构造器中调用构造器" class="headerlink" title="2、构造器中调用构造器"></a>2、构造器中调用构造器</h3><ul>
<li><p>必须将构造器调用置于最起始处，否则编译器会报错；</p>
</li>
<li><p>使用 this 调用构造器时，不能调用多次；</p>
</li>
<li><p>除构造器外，编译器禁止在其它任何方法中调用构造器。</p>
</li>
</ul>
<h1 id="二、方法重载"><a href="#二、方法重载" class="headerlink" title="二、方法重载"></a>二、方法重载</h1><ul>
<li><p>方法名相同</p>
</li>
<li><p>必须有独一无二的参数类型列表</p>
</li>
<li><p>参数顺序不同也能区分（不推荐）</p>
</li>
<li><p>传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升；反之，如果传入的数据类型（实际参数类型）大于方法中声明的形式参数类型，实际数据类型就得通过类型转换执行窄化操作，否则编译器会报错。</p>
</li>
<li><p>不能通过方法返回值区分</p>
</li>
</ul>
<h1 id="三、关键字"><a href="#三、关键字" class="headerlink" title="三、关键字"></a>三、关键字</h1><h3 id="1、this"><a href="#1、this" class="headerlink" title="1、this"></a>1、this</h3><ul>
<li><p>对当前对象的引用；</p>
</li>
<li><p>只能在方法内部使用</p>
</li>
</ul>
<h3 id="2、static"><a href="#2、static" class="headerlink" title="2、static"></a>2、static</h3><ul>
<li><p>static 方法里不能使用关键字 this；</p>
</li>
<li><p>static 方法内部不能调用非静态方法；</p>
</li>
<li><p>非静态方法内部可以调用静态方法；</p>
</li>
</ul>
<h1 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h1><ul>
<li><p>类的数据成员（即字段）若未初始化，系统则会指定默认值；局部变量若未初始化，编译器则会报错；</p>
</li>
<li><p>无法阻止自动初始化的进行，它将在构造器被调用之前发生；</p>
</li>
</ul>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><ul>
<li><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化；（变量优先于构造器和方法初始化）</p>
</li>
<li><p>静态变量优先于非静态变量初始化；</p>
</li>
<li><p>创建一个类的多个实例时，静态变量只初始化一次，非静态变量每次被初始化；</p>
</li>
<li><p>对于静态块，首次创建该类对象或首次访问静态块成员才会被初始化；</p>
</li>
</ul>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><ul>
<li>编译器不允许指定数组的大小</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、构造器&quot;&gt;&lt;a href=&quot;#一、构造器&quot; class=&quot;headerlink&quot; title=&quot;一、构造器&quot;&gt;&lt;/a&gt;一、构造器&lt;/h1&gt;&lt;h3 id=&quot;1、要点&quot;&gt;&lt;a href=&quot;#1、要点&quot; class=&quot;headerlink&quot; title=&quot;1、要点&quot;
    
    </summary>
    
      <category term="Java" scheme="http://panzeyong.com/categories/Java/"/>
    
    
      <category term="《Java Thinking》学习笔记" scheme="http://panzeyong.com/tags/%E3%80%8AJava-Thinking%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架：Vector（JDK 8）</title>
    <link href="http://panzeyong.com/2017/12/15/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9AVector%EF%BC%88JDK-8%EF%BC%89/"/>
    <id>http://panzeyong.com/2017/12/15/Java-集合框架：Vector（JDK-8）/</id>
    <published>2017-12-15T00:54:05.000Z</published>
    <updated>2017-12-23T08:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Vector 底层是由<strong>数组</strong>实现，是一个<strong>动态数组</strong>，其容量能自动增长或者减少。Vector 继承 AbstractList<e> 抽象类，实现 List<e>、RandomAccess、Clone、java.io.Serializable 接口。其实现原理与 ArrayList 类似。</e></e></p>
<ul>
<li><p>Vector 继承 AbstractList<e> 抽象类，实现 List<e> 接口。它是一个数组队列，提供了增删改查以及遍历等功能。</e></e></p>
</li>
<li><p>Vector 实现 RandomAccess 接口，提供快速随机访问功能。RandomAccess 接口被 List 实现主要用来支持快速随机访问，通过数组下标随机访问元素。</p>
</li>
<li><p>Vector 实现 Clone 接口，重写 Object clone() 方法可以克隆对象。</p>
</li>
<li><p>Vector 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据在网络进行传输。</p>
</li>
</ul>
<p>Vector 允许添加所有元素，包括 null 元素。</p>
<p>与 ArrayList 一样，Vector 支持容量自动增长，但是增长方式与 ArrayList 略有不同。Vector 通过维护 <strong>capacity</strong> 和 <strong>capacityIncrement</strong> 这两个属性来优化其内存管理，而 capacityIncrement 是容量增长的系数，当 Vector 容量不足时，如果 capacityIncrement 为 0 的话，那么 Vector 容量扩容为原先的 2 倍（newCapacity = 2 * oldCapacity）；如果 capacityIncrement 大于 0，那么扩容后的容量为 oldCapacity + capacityIncrement。扩容的原理其实是对数组进行复制，对需要移动的元素进行移动，相当消耗性能的。如果可能的话，在实例化 Vector 的时候指定其容量。</p>
<p>与 ArrayList 不一样的是，Vector 是线程安全，方法实现加上 synchronized 关键字。正因为其线程安全，这就导致其在单线程下性能不如 ArrayList。如果不在多线程下使用，推荐使用 ArrayList。</p>
<p>Vector 是在 Java 1.2 实现 List 接口，使其成为 Java 集合框架的一员，而并不是一开始就存在的。</p>
<h1 id="二、Vector-继承关系图"><a href="#二、Vector-继承关系图" class="headerlink" title="二、Vector 继承关系图"></a>二、Vector 继承关系图</h1><p><img src="/images/java/collection/vector/vector.png" alt=""></p>
<h1 id="三、Vector-源码分析"><a href="#三、Vector-源码分析" class="headerlink" title="三、Vector 源码分析"></a>三、Vector 源码分析</h1><h3 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h3><p>从源码可以看出，Vector 提供的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 存储 Vector 包含所有元素的数组</span></div><div class="line"><span class="keyword">protected</span> Object[] elementData;</div><div class="line"></div><div class="line"><span class="comment">// Vector 所包含的元素个数</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</div><div class="line"></div><div class="line"><span class="comment">// Vector 容量自动增长的增量，如果小于等于 0，那么增量为原先容量的一倍</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</div><div class="line"></div><div class="line"><span class="comment">// 序列号版本号</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2767605614048989439L</span>;</div></pre></td></tr></table></figure>
<p>Vector 底层是由数组实现，所有元素都存储在 elementData 数组中，当 Vector 容量大于 elementData 的容量时，则需要扩容；那么到底如何扩容取决于属性 capacityIncrement 的值，如果 capacityIncrement 不为 0，那么扩容的增量就是它，即 oldCapacity + capacityIncrement；如果 capacityIncrement 小于等于 0，那么扩容的增量即为原先的一倍，即 oldCapacity + oldCapacity。至于 capacityIncrement 这个属性，则是 Vector 所包含元素的个数。</p>
<h3 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h3><p>Vector 提供 4 个不同版本的构造函数，它们之间有着一定的联系，具体实现看下面的分析。</p>
<p>无参构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造空的 Vector，默认大小为 10，容量的增量系数为 0</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在无参构造函数里，调用了传一个参数的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用指定的初始容量和容量增量系数为 0 构造空 Vector</div><div class="line"> * </div><div class="line"> * <span class="doctag">@initialCapacity</span> vector 初始容量</div><div class="line"> * <span class="doctag">@throws</span> 如果 initialCapacity 为负数，则抛出异常 java.lang.IllegalArgumentException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着调用带两个参数的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="comment">// 检查 initialCapacity 是否小于 0，是的话则抛出异常</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</div><div class="line">    <span class="comment">// 实例化数组对象，数组大小为 initialCapacity</span></div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，才真正创建初始容量为 initialCapacity 的数组对象以及指定容量增长系统 this.capacityIncrement。</p>
<p>构造包含指定集合所有元素的 Vector 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造一个包含指定集合元素的 Vector</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> c 集合 c 中的元素添加到 Vector</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合为 null ，则抛出空指针</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 集合 c 转换为数组赋值给数组 elementData</span></div><div class="line">    elementData = c.toArray();</div><div class="line">    <span class="comment">// 数组的长度</span></div><div class="line">    elementCount = elementData.length;</div><div class="line">    <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="comment">// 转换数组返回值可能不是 Object[]，如果是这样的话，则执行下面的语句</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果看过 <a href="http://panzeyong.com/2017/11/07/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9AArrayList/">ArrayList</a> 这篇文章对 ArrayList 的分析的话，那么对该方法的逻辑实现应该不陌生，而且基本一模一样，所以这里就不再做分析了。</p>
<h3 id="3、添加元素"><a href="#3、添加元素" class="headerlink" title="3、添加元素"></a>3、添加元素</h3><p>Vector 提供多个添加元素版本，有将元素添加到 Vector，也有将元素添加到 Vector 指定位置，至于是怎么实现的，见下面分析。</p>
<h4 id="（1）、add-Object"><a href="#（1）、add-Object" class="headerlink" title="（1）、add(Object)"></a>（1）、add(Object)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 把指定元素添加到 Vector 末尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> e 添加到 Vector 元素</div><div class="line"> * <span class="doctag">@returns</span> true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 在添加元素到数组 elementData 之前检测 elementData 容量是否满足</span></div><div class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">    <span class="comment">// 将元素 e 添加到数组 elementData</span></div><div class="line">    elementData[elementCount++] = e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看第 10 行代码方法 ensureCapacityHelper(elementCount + 1) 的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这实现了 ensureCapacity 的非同步语义。此类中的同步方法可以在内部调用</div><div class="line"> * 此方法来确保容量，而不会产生额外同步的代价。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里假设数组 elementData 已经添加了 10 个元素，容量等于初始容量，现在要再添加 1 一个新元素，也就是说，传给方法 ensureCapacityHelper(int minCapacity) 的参数 minCapacity 值为 11，那么来第 3 行代码，显示条件是成立的，第 4 行代码被执行，看下具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 保存扩容前数组的容量</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 根据 capacityIncrement 的值来决定扩容。这里假设 capacityIncrement 为 0，那么增加的容量是原来的一倍，即 newCapacity = 2 * oldCapacity</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?capacityIncrement : oldCapacity);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// 复制源数组到目标数组，实现扩容</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，应该终于知道前面为何一直扩容取决于属性 capacityIncrement，答案在第 6 行代码。第 12 行代码实现扩容操作，最终调用 <code>System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));</code>，而该方法是 native 方法，在底层实现对数组复制操作，对需要移动的元素进行移动，从而实现了扩容操作。</p>
<h4 id="（2）、add-int-index-E-element"><a href="#（2）、add-int-index-E-element" class="headerlink" title="（2）、add(int index, E element)"></a>（2）、add(int index, E element)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在 Vector 指定的位置插入指定的元素，将当前位置的元素（如果有的话）和任何随后的元素移动到右侧（在其索引中增加 1）</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 指定的元素将被插入的索引</div><div class="line"> * <span class="doctag">@params</span> element 将被插入的元素</div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    insertElementAt(element, index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看第 9 行代码的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定的对象作为 Vector 的组件插入到 Vector 指定的索引；此 Vector</div><div class="line"> * 每个具有大于或者等于指定索引的索引的组件都需要向右移动，以使其大于先前</div><div class="line"> * 的索引值。</div><div class="line"> * </div><div class="line"> * 索引必须是大于 0 并且小于或等于当前 Vector 的大小（如果索引等于当前</div><div class="line"> * Vector 的大小，那么则将新元素插入到 Vector 尾）。</div><div class="line"> * </div><div class="line"> * 此方法与 add(int，E) 方法（它是 List 接口的一部分）的功能相同。</div><div class="line"> * 请注意，add 方法颠倒了参数的顺序，以更贴近地匹配数组的用法。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> obj 插入组件</div><div class="line"> * <span class="doctag">@params</span> index 插入新组件的索引</div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// Vector 结构发生改变，插入属性 modCount 会加 1</span></div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 在添加元素之前检查容量，不满足的话则扩容</span></div><div class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">    <span class="comment">// 将源数组需要移动的元素移到目标数组</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</div><div class="line">    <span class="comment">// 在指定索引插入元素</span></div><div class="line">    elementData[index] = obj;</div><div class="line">    <span class="comment">// 数组大小加 1</span></div><div class="line">    elementCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现逻辑不是很复杂，将指定的对象作为 Vector 的组件插入到 Vector 指定的索引。第 20 ~ 22 行代码检查数组是否越界；第 24 行代码检查容量是否满足，具体分析上面已经分析过；第 25 行代码实现对数组的复制，换句话说，即对需要的移动的元素进行移动。那么至于是如何移动元素的，看下面图解</p>
<p><img src="/images/java/collection/vector/add_by_index.png" alt=""></p>
<h4 id="（3）、addAll-Collection"><a href="#（3）、addAll-Collection" class="headerlink" title="（3）、addAll(Collection)"></a>（3）、addAll(Collection)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定集合中包含的所有元素插入到 Vector 尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> 插入到 Vector 的元素</div><div class="line"> * <span class="doctag">@returns</span> true</div><div class="line"> * <span class="doctag">@throws</span> 如果指定的集合 c 是 null，则抛出异常 java.lang.NullPointerException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 指定集合转换为数组</span></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    <span class="comment">// 在插入元素之前检查容量是否满足</span></div><div class="line">    ensureCapacityHelper(elementCount + numNew);</div><div class="line">    <span class="comment">// 把指定集合 c 包含的元素插入到 Vector 尾</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, elementCount, numNew);</div><div class="line">    <span class="comment">// 更新 elementData 数组的大小</span></div><div class="line">    elementCount += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法实现逻辑与 add(Object) 类似，区别只在于 allAll(Collection) 往 Vector 添加多个元素，而 add(Object) 值添加一个元素。至于具体分析细节可参考 add(Object) 方法。</p>
<h4 id="（4）、addAll-int-Collection"><a href="#（4）、addAll-int-Collection" class="headerlink" title="（4）、addAll(int, Collection)"></a>（4）、addAll(int, Collection)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定集合中的所有元素插入到指定位置 Vector 中。将当前位置的元素（如果有的话）和随后的元素移动到右侧（增加它们的索引）</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 在 index 插入指定集合的第一个元素</div><div class="line"> * <span class="doctag">@params</span> c 插入到 Vector 的元素</div><div class="line"> * <span class="doctag">@returns</span> true</div><div class="line"> * <span class="doctag">@throws</span> 如果指定的集合 c 是 null，则抛出异常 java.lang.NullPointerException</div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">    <span class="comment">// 指定集合转换为数组</span></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    <span class="comment">// 在插入元素之前检查容量是否满足</span></div><div class="line">    ensureCapacityHelper(elementCount + numNew);</div><div class="line">    <span class="comment">// 需要移动元素个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = elementCount - index;</div><div class="line">    <span class="comment">// 对需要移动的元素进行移动，即复制到目标数组</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</div><div class="line">    <span class="comment">// 将指定集合包含的元素插入到 Vector</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">    elementCount += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是在 Vector 指定位置插入指定集合包含的所有元素，这就需要对元素进行移动，即将源数组的元素复制到目标数组，那么至于是怎么移动的呢，来看下图解</p>
<p><img src="/images/java/collection/vector/add_collection.png" alt=""></p>
<h4 id="（5）、addElement-E-obj"><a href="#（5）、addElement-E-obj" class="headerlink" title="（5）、addElement(E obj)"></a>（5）、addElement(E obj)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定组件添加到 Vector 尾，其大小增加 1。如果 Vector 的大小大于其容量，那么它的容量就会增加。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> obj 添加组件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">    elementData[elementCount++] = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法等价于方法 add(Object)，实现逻辑基本相同，可参考以上分析。</p>
<h3 id="4、删除元素"><a href="#4、删除元素" class="headerlink" title="4、删除元素"></a>4、删除元素</h3><p>同样，Vector 也提供多个版本删除元素，开发者可以根据自己的需求调用不同的 API，那么来看下它们的具体实现。</p>
<h4 id="1-、remove-Object"><a href="#1-、remove-Object" class="headerlink" title="(1)、remove(Object)"></a>(1)、remove(Object)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除 Vector 第一个与指定元素 o 相同的元素，如果 Vector 不包含指定元</div><div class="line"> * 素 o，则不发生改变。换句话说，移除最小索引 i 的元素 </div><div class="line"> * (o==null ? get(i)==null : o.equals(get(i)))（指定元素存在的情况下）</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> 从 Vector 移除的元素（指定元素存在的情况下） </div><div class="line"> * <span class="doctag">@returns</span> 如果 Vector 包含指定元素的话，则返回 true </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeElement(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看第 10 行代码的源码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从 Vector 移除与参数匹配的第一个元素，如果 Vector 包含该对象，</div><div class="line"> * 则 Vector 索引大于或等于该对象索引的元素都需要向左移动，</div><div class="line"> * 使其索引比之前小。该方法等价于 remove(Object)</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> obj 被移除组件</div><div class="line"> * <span class="doctag">@returns</span> 如果 Vector 包含指定组件，返回 true；否则返回 false</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 搜索指定元素在 Vector 出现的索引，存在的返回大于等于 0 的数；否则返回 -1</span></div><div class="line">    <span class="keyword">int</span> i = indexOf(obj);</div><div class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</div><div class="line">        removeElementAt(i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先调用方法 indexOf(Object) 遍历指定元素在 Vector 中第一次出现的索引，如果存在的话的返回指定元素在 Vector 的索引，否则返回 -1；那么接下来看下是如何遍历的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，</div><div class="line"> * 则返回 -1。更通常地来说，返回最低索引 i，使得 (o==null ? </div><div class="line"> * get(i)==null : o.equals(get(i)))，如果不存在的话则返回 -1。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> o 搜索的元素</div><div class="line"> * <span class="doctag">@returns</span> 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，则返回 -1。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>紧接着又调用方法 indexOf(Object, int)，源码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，</div><div class="line"> * 则返回 -1。更通常地来说，返回最低索引 i，使得 (i &gt;= index &amp;&amp; </div><div class="line"> * (o==null ? get(i)==null : o.equals(get(i))))，</div><div class="line"> * 如果不存在的话则返回 -1。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> o 搜索的元素</div><div class="line"> * <span class="doctag">@params</span> index 从 Vector 开始搜索的索引</div><div class="line"> * <span class="doctag">@returns</span> 返回 Vector 指定元素第一次出现的索引，如果 Vector 不包含该指定元素，则返回 -1。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@throws</span> 如果指定索引是负数的话，则抛出 java.lang.IndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</div><div class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</div><div class="line">                <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先判断指定搜索元素 o 是否为 null，如果为 null 的话，则执行第 14 - 16 行代码，即遍历数组 elementData 是否存在 null 元素，存在的话返回其索引，否则返回 -1；如果 o 不为 null 的话，则执行第 18 - 20 行代码，即遍历数组 elementData 是否存在该元素，存在的话则返回其索引，否则返回 -1。</p>
<p>回到方法 removeElement(Object)，假设 Vector 包含指定元素，调用方法 indexOf(Object) 的索引大于等于 0，那么将会执行第 13 - 16 行，即执行移除指定元素操作，真正执行该操作的方法是 removeElementAt(int)，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 删除指定索引的组件。此时 Vector 中每个大于或等于指定索引的索引的组件</div><div class="line"> * 需要向左移动，以使其索引小于先前的值。Vector 的大小减 1。</div><div class="line"> * 索引值必须是大于等于 0，并且小于当前 Vector 的大小。</div><div class="line"> * 该方法功能与 remvoe(int) 一样，但是需要注意的一点是 remove(int) 返回存储在指定位置的旧值。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 删除对象的索引</div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 需要移动元素的个数</span></div><div class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</div><div class="line">    <span class="comment">// 对需要移动的元素进行移动，即从源数组复制到指定位置的目标数组</span></div><div class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</div><div class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// elementData 大小减少 1</span></div><div class="line">    elementCount--;</div><div class="line">    <span class="comment">// 将被移除元素腾出来的空间置 null，释放资源</span></div><div class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>理解了如何在 Vector 指定位置添加元素后，再来理解如何在 Vector 指定位置删除元素应该很容易的，同样是需要对部分元素进行移动的，其实就是从源数组复制到指定位置的目标数组，通过图解加深理解</p>
<p><img src="/images/java/collection/vector/remove_by_index.png" alt=""></p>
<h4 id="2-、remove-int"><a href="#2-、remove-int" class="headerlink" title="(2)、remove(int)"></a>(2)、remove(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除 Vector 指定位置的元素，将指定元素随后的元素向左移动，</div><div class="line"> * 返回从 Vector 删除的元素。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 删除元素索引</div><div class="line"> * <span class="doctag">@returns</span> 被删除的元素 </div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">        </div><div class="line">    E oldValue = elementData(index);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    </div><div class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法基本与 removeElementAt(int) 等价，但是有点区别的是该方法有返回值，即返回被删除的元素；而 removeElementAt(int) 没有返回值。</p>
<h4 id="（3）、removeAllElements"><a href="#（3）、removeAllElements" class="headerlink" title="（3）、removeAllElements()"></a>（3）、removeAllElements()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除 Vector 所有组件以及设置其 size 为 0。</div><div class="line"> * 功能等价于方法 clear()</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">    elementCount = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现逻辑很简单，就不再分析了。</p>
<h4 id="（4）、removeRange-int-fromIndex-int-toIndex"><a href="#（4）、removeRange-int-fromIndex-int-toIndex" class="headerlink" title="（4）、removeRange(int fromIndex, int toIndex)"></a>（4）、removeRange(int fromIndex, int toIndex)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从 Vector 删除所用介于 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</div><div class="line"> * 将任何后续的元素向左移动（索引减 1）。通过调用 （toIndex - fromIndex）来缩短 Vector（如果 toIndex == fromIndex），此操作无效。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="comment">// 需要移动元素个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = elementCount - toIndex;</div><div class="line">    <span class="comment">// 将源数组复制到指定位置的目标数组</span></div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);</div><div class="line">    </div><div class="line">    <span class="comment">// Let gc do its work</span></div><div class="line">    <span class="comment">// 释放资源</span></div><div class="line">    <span class="keyword">int</span> newElementCount = elementCount - (toIndex-fromIndex);</div><div class="line">    <span class="keyword">while</span> (elementCount != newElementCount)</div><div class="line">        elementData[--elementCount] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信理解了以上方法之后，对该方法也不难理解。在这里只是列出来而已，让大家知道有这个方法。</p>
<h3 id="5、修改元素"><a href="#5、修改元素" class="headerlink" title="5、修改元素"></a>5、修改元素</h3><p>对于修改元素，Vector 提供两个版本，区别在于是否有返回值。</p>
<h4 id="（1）、set-int-E"><a href="#（1）、set-int-E" class="headerlink" title="（1）、set(int, E)"></a>（1）、set(int, E)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用指定的元素替换 Vector 指定位置的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 要替换元素的索引</div><div class="line"> * <span class="doctag">@params</span> element 元素存储在指定的位置</div><div class="line"> * <span class="doctag">@returns</span> 之前在指定位置的元素 </div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），</div><div class="line"> * 则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">    </div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查 index 是否越界，是的话就抛出异常；否则继续执行。保存 Vector 指定位置元素的值作为返回值返回，接着修改指定位置 index 的值。</p>
<h4 id="2-、setElementAt-E-obj-int-index"><a href="#2-、setElementAt-E-obj-int-index" class="headerlink" title="(2)、setElementAt(E obj, int index)"></a>(2)、setElementAt(E obj, int index)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 将 Vector 指定索引的组件设置为指定的对象，该位置原先的组件被丢弃。</div><div class="line"> * 索引必须是大于或等于0的值，并且小于矢量的当前大小。</div><div class="line"> * 此方法功能与 set(int, E) 相同。注意 set 方法颠倒参数顺序，以更接近数组的使用。还有一点区别的是 set 方法返回存储在指定位置的旧值。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> obj 替换 Vector 指定位置的新值</div><div class="line"> * <span class="doctag">@params</span> index 指定索引 </div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），</div><div class="line"> * 则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    elementData[index] = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、查询元素"><a href="#6、查询元素" class="headerlink" title="6、查询元素"></a>6、查询元素</h3><p>对于查询元素，Vector 提供多个版本，由于实现 RandomAccess 接口，因此具有随机快速访问元素功能，即通过索引快速访问元素，Vector 查询元素都是通过索引访问元素实现的。</p>
<h4 id="（1）、elementAt-int"><a href="#（1）、elementAt-int" class="headerlink" title="（1）、elementAt(int)"></a>（1）、elementAt(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 返回指定索引的组件。</div><div class="line"> * 该方法功能与 get(int) 相同</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index Vector 索引</div><div class="line"> * <span class="doctag">@returns</span> 指定索引的组件 </div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），</div><div class="line"> * 则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-、elementData-int"><a href="#2-、elementData-int" class="headerlink" title="(2)、elementData(int)"></a>(2)、elementData(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (E) elementData[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-、get-int"><a href="#3-、get-int" class="headerlink" title="(3)、get(int)"></a>(3)、get(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 指定位置的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> index 返回元素的索引</div><div class="line"> * <span class="doctag">@returns</span> 指定索引的对象</div><div class="line"> * <span class="doctag">@throws</span> 如果索引越界（index &lt; 0 || index &gt; size），</div><div class="line"> * 则抛出 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（4）、firstElement"><a href="#（4）、firstElement" class="headerlink" title="（4）、firstElement()"></a>（4）、firstElement()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 返回 Vector 第一个组件</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> 返回 Vector 第一个组件</div><div class="line"> * <span class="doctag">@thorws</span> 如果 Vector 没有组件，则抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> elementData(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（5）、lastElement"><a href="#（5）、lastElement" class="headerlink" title="（5）、lastElement()"></a>（5）、lastElement()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 最后一个组件</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> Vector 最后一个组件</div><div class="line"> * <span class="doctag">@thorws</span> 如果 Vector 没有组件，则抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">lastElement</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> elementData(elementCount - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7、遍历元素"><a href="#7、遍历元素" class="headerlink" title="7、遍历元素"></a>7、遍历元素</h3><p>对于遍历元素，Vector 提供多个版本，每个版本执行的效率有所差别。我们先来理解源码实现，然后再通过例子加以说明。</p>
<h4 id="1-、elements"><a href="#1-、elements" class="headerlink" title="(1)、elements()"></a>(1)、elements()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 返回 Vector 中所有组件对应的 Enumeration。被返回的 Enumeration 生成 Vector 中所有的组件。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> Vector 中组件的枚举</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;E&gt;() &#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count &lt; elementCount;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (count &lt; elementCount) &#123;</div><div class="line">                    <span class="keyword">return</span> elementData(count++);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Vector Enumeration"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>elements() 方法返回一个 Enumeration<e> 对象，而 Enumeration<e> 是一个接口，在方法 elements() 实现 Enumeration<e> 两个方法：hasMoreElements() 和 nextElement()。对于方法 hasMoreElements() 是判断是否还有下一个元素；而 nextElement() 遍历整个 Vector，返回下一个元素。</e></e></e></p>
<h4 id="（2）、iterator"><a href="#（2）、iterator" class="headerlink" title="（2）、iterator()"></a>（2）、iterator()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 以合适的顺序返回 Vector 中元素的迭代器。</div><div class="line"> * 返回的迭代器是 fail-fast（“快速失败”机制）。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建类 Itr 对象并返回，即返回 Iterator<e> 对象，类 Itr 实现 Iterator<e> 接口，并实现该接口中的方法 hasNext()、next()、remove()、forEachRemaining(Consumer)，以下给出该类的源码，以供理解。</e></e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断是否还有下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Racy but within spec, since modifications are checked</span></div><div class="line">        <span class="comment">// within or after synchronization in next/previous</span></div><div class="line">        <span class="keyword">return</span> cursor != elementCount;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回下一个元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</div><div class="line">            checkForComodification();</div><div class="line">            <span class="keyword">int</span> i = cursor;</div><div class="line">            <span class="keyword">if</span> (i &gt;= elementCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            cursor = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> elementData(lastRet = i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</div><div class="line">            checkForComodification();</div><div class="line">            Vector.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">            expectedModCount = modCount;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        cursor = lastRet;</div><div class="line">        lastRet = -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = elementCount;</div><div class="line">            <span class="keyword">int</span> i = cursor;</div><div class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            <span class="keyword">final</span> E[] elementData = (E[]) Vector.<span class="keyword">this</span>.elementData;</div><div class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</div><div class="line">                action.accept(elementData[i++]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></div><div class="line">            cursor = i;</div><div class="line">            lastRet = i - <span class="number">1</span>;</div><div class="line">            checkForComodification();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（3）、通过索引随机快速访问"><a href="#（3）、通过索引随机快速访问" class="headerlink" title="（3）、通过索引随机快速访问"></a>（3）、通过索引随机快速访问</h4><h4 id="（4）、foreach-增强循环遍历访问"><a href="#（4）、foreach-增强循环遍历访问" class="headerlink" title="（4）、foreach 增强循环遍历访问"></a>（4）、foreach 增强循环遍历访问</h4><h4 id="（5）、例子"><a href="#（5）、例子" class="headerlink" title="（5）、例子"></a>（5）、例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Enumeration;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTraverseDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">999</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</div><div class="line">        vector = <span class="keyword">new</span> Vector();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</div><div class="line">            vector.add(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调用方法 elements() 遍历 Vector 元素</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">elementsAccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        </div><div class="line">        Enumeration enumeration = vector.elements();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(enumeration.hasMoreElements()) &#123;</div><div class="line">            enumeration.nextElement();        </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time = endTime - startTime;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Elements() Method Access Time: "</span> + time + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调用 iterator() 方法遍历 Vector 元素</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        </div><div class="line">        Iterator iterator = vector.iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line">            iterator.next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time = endTime - startTime;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Iterator() Method Access Time: "</span> + time + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * foreach 增强循环遍历 Vector 元素</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreachAccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : vector) &#123;</div><div class="line">            <span class="keyword">int</span> i = item;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time = endTime - startTime;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Foreach Access Time: "</span> + time + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomAccess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">            vector.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time = endTime - startTime;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Random Access Time: "</span> + time + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        init();</div><div class="line">        elementsAccess();</div><div class="line">        iteratorAccess();</div><div class="line">        foreachAccess();</div><div class="line">        randomAccess();</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">MAX = <span class="number">999</span></div><div class="line">Elements() Method Access Time: <span class="number">0</span> <span class="function">ms</span></div><div class="line"><span class="title">Iterator</span><span class="params">()</span> Method Access Time: 0 ms</div><div class="line">Foreach Access Time: 0 ms</div><div class="line">Random Access Time: 1 ms</div><div class="line">-----------------------------------</div><div class="line"></div><div class="line">MAX = <span class="number">9999</span></div><div class="line">Elements() Method Access Time: <span class="number">1</span> <span class="function">ms</span></div><div class="line"><span class="title">Iterator</span><span class="params">()</span> Method Access Time: 1 ms</div><div class="line">Foreach Access Time: 1 ms</div><div class="line">Random Access Time: 0 ms</div><div class="line">-----------------------------------</div><div class="line"></div><div class="line">MAX = <span class="number">99999</span></div><div class="line">Elements() Method Access Time: <span class="number">5</span> <span class="function">ms</span></div><div class="line"><span class="title">Iterator</span><span class="params">()</span> Method Access Time: 6 ms</div><div class="line">Foreach Access Time: 7 ms</div><div class="line">Random Access Time: 7 ms</div><div class="line">-----------------------------------</div><div class="line"></div><div class="line">MAX = <span class="number">999999</span></div><div class="line">Elements() Method Access Time: <span class="number">28</span> <span class="function">ms</span></div><div class="line"><span class="title">Iterator</span><span class="params">()</span> Method Access Time: 29 ms</div><div class="line">Foreach Access Time: 31 ms</div><div class="line">Random Access Time: 50 ms</div><div class="line">-----------------------------------</div><div class="line"></div><div class="line">MAX = <span class="number">9999999</span></div><div class="line">Elements() Method Access Time: <span class="number">270</span> <span class="function">ms</span></div><div class="line"><span class="title">Iterator</span><span class="params">()</span> Method Access Time: 266 ms</div><div class="line">Foreach Access Time: 265 ms</div><div class="line">Random Access Time: 513 ms</div></pre></td></tr></table></figure>
<p>从运行结果可以看出，随着数据量不断递增，不同的遍历方式的效率渐趋明显；而对于数量小的话，遍历效率基本相同。</p>
<h3 id="8、判断-Vector-是否包含指定元素"><a href="#8、判断-Vector-是否包含指定元素" class="headerlink" title="8、判断 Vector 是否包含指定元素"></a>8、判断 Vector 是否包含指定元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 如果 Vector 包含指定元素，那么返回 true。换句话说，</div><div class="line"> * 当且仅当 Vector 至少包含一个元素 e，使得 (o==null ? e==null : o.equals(e))。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> o 搜索的元素</div><div class="line"> * <span class="doctag">@returns</span> 如果 Vector 包含指定元素，那么返回 true。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到第 9 行代码，应该很熟悉吧，见上面分析。</p>
<h3 id="9、判断-Vector-的大小是否-0"><a href="#9、判断-Vector-的大小是否-0" class="headerlink" title="9、判断 Vector 的大小是否 0"></a>9、判断 Vector 的大小是否 0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 判断 Vector 是否不包含任何组件。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> 有且仅当 Vector 不包含任何组件时返回 true，换句话说，size 为 0；否则返回 false。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elementCount == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="10、获取-Vector-大小"><a href="#10、获取-Vector-大小" class="headerlink" title="10、获取 Vector 大小"></a>10、获取 Vector 大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 包含组件的数量</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> 返回 Vector 包含组件的数量</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elementCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="11、改变-Vector-大小"><a href="#11、改变-Vector-大小" class="headerlink" title="11、改变 Vector 大小"></a>11、改变 Vector 大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 设置 Vector 的大小。如果新的大小比当前大小大的话，那么将创建 null 添加到 Vector 末尾；如果新的大小比当前大小小的话，那么 Vector 索引为 newSize 以及之后的索引将被置为 null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@params</span> newSize Vector 新大小</div><div class="line"> * <span class="doctag">@throws</span> 如果 newSize 是负数，那么抛出异常 java.lang.ArrayIndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</div><div class="line">        ensureCapacityHelper(newSize);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</div><div class="line">            elementData[i] = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    elementCount = newSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 newSize 当前数组 elementData 容量大的话，那么执行第 10 行代码，很眼熟吧，即对 Vector 进行扩容，在Vector 尾添加 （newSize - elementCount） null 元素；如果小的话，那么执行第 12 - 14 行代码，即将Vector 索引为 newSize 及之后索引的元素置 null。</p>
<h3 id="12、获取-Vector-容量"><a href="#12、获取-Vector-容量" class="headerlink" title="12、获取 Vector 容量"></a>12、获取 Vector 容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回 Vector 当前容量</div><div class="line"> * </div><div class="line"> * <span class="doctag">@returns</span> 当前容量（内部数组 elementData 的长度）</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elementData.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><ul>
<li><p>Vector 底层是基于数组实现的，是一个动态数组；</p>
</li>
<li><p>Vector 允许添加所有元素，包括 null 元素；</p>
</li>
<li><p>Vector 是线程安全；</p>
</li>
<li><p>Vector 实现 RandomAccess 接口，支持通过索引随机快速访问元素；</p>
</li>
<li><p>Vector 支持容量自增长，通过 capacity 和 capacityIncrement 这两个属性来维护。容量增长的机制如下：当增长系数 capacityIncrement 大于 0 时，那么 Vector 增加的容量为增长系数 capacityIncrement，扩容后的容量为 oldCapacity + capacityIncrement；如果增长系数 capacityIncrement 等于 0，那么 Vector 增加的容量为原来的一倍，扩容后的容量为 oldCapacity * 2。</p>
</li>
</ul>
<h1 id="五、Vector-与-ArrayList-区别"><a href="#五、Vector-与-ArrayList-区别" class="headerlink" title="五、Vector 与 ArrayList 区别"></a>五、Vector 与 ArrayList 区别</h1><table><tr><th></th><th style="text-align:center">不同点</th><th style="text-align:center">相同点</th></tr><tr><td rowspan="4" style="text-align:center">Vector</td><td style="text-align:center">同步、线程安全</td><td rowspan="8">1、底层基于数组实现，是一个动态数组；<br> 2、继承抽象类 AbstractList，实现 List 接口，提供增删改查以及遍历功能；<br>3、实现 RandomAccess 接口，支持随机快速访问元素功能；<br> 4、实现接口 java.io.Serializable，支持序列化和反序列化；<br> 5、实现接口 Clone，支持克隆对象；<br> 6、允许添加任何元素，包括 null 元素</td></tr><tr><td style="text-align:center">容量扩容根据增长系数 capacityIncrement </td></tr><tr><td style="text-align:center">支持 Enumeration、foreach、iterator、for 遍历</td></tr><tr><td style="text-align:center">需要额外开销来维护同步锁，性能慢</td></tr><tr><td rowspan="4" style="text-align:center">ArrayList</td><td style="text-align:center">异步、线程不安全</td></tr><tr><td style="text-align:center">容量扩容为旧容量的 1.5 倍</td></tr><tr><td style="text-align:center">支持 foreach、iterator、for 遍历</td></tr><tr><td style="text-align:center">不需要额外开销来维护同步锁，性能快</td></tr></table>

<p>以上是自己对 Vector 的初始，由于水平有限，如果文中有错误的，欢迎指出！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;Vector 底层是由&lt;strong&gt;数组&lt;/strong&gt;实现，是一个&lt;strong&gt;动态数组&lt;/strong&gt;，其容量能
    
    </summary>
    
      <category term="Java" scheme="http://panzeyong.com/categories/Java/"/>
    
    
      <category term="Java 集合框架" scheme="http://panzeyong.com/tags/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架：LinkedList（JDK 8）</title>
    <link href="http://panzeyong.com/2017/12/06/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9ALinkedList/"/>
    <id>http://panzeyong.com/2017/12/06/Java-集合框架：LinkedList/</id>
    <published>2017-12-06T00:41:35.000Z</published>
    <updated>2017-12-12T01:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>LinkedList 底层实现基于<strong>双向链表</strong>，除了可以当作链表使用外，LinkedList 还可以当作栈、队列和双端队列使用，其原因是实现 List 和 Deque 接口。LinkedList 继承于抽象类 AbstractSequentialList，实现 List、Deque、Cloneable、java.io.Serializable 接口。</p>
<ul>
<li><p>LinkedList 继承于抽象类 AbstractSequentialList，实现 List 接口，可以对队列进行基本操作，提供了增删改查以及遍历等功能。</p>
</li>
<li><p>LinkedList 实现 Clone 接口，重写 Object clone() 方法可以克隆对象。</p>
</li>
<li><p>LinkedList 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据传输。</p>
</li>
<li><p>LinkedList 实现 Deque 接口，而 Deque 接口是一个线性集合，支持元素在两端进行插入和移除，它有个名称叫作<strong>双端队列</strong>。Deque 实现既支持限制容量又支持不限制容量；提供的方法都可以从两端对元素进行操作，被提供的方法主要用于 <strong>insert</strong>、<strong>remove</strong> 和 <strong>examine</strong> 元素。这些方法存在两种形式：一种是操作失败时抛出异常；一种是返回一个特定值（null 或者 false，取决于具体操作）。对于这些操作，Deque 提供 12 个方法，具体如下表：</p>
  <table><tr style="text-align:center"><th></th><th style="text-align:center" colspan="2">First Element (Head)</th><th style="text-align:center" colspan="2">Last Element (Tail)</th></tr><tr><td></td><td>Throws exception</td><td>Special Value</td><td>Throws exception</td><td>Special Value</td></tr><tr><th>Insert</th><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><th>Remove</th><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast</td></tr><tr><th>Examine</th><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr><table><br>  Deque 接口继承 Queue，可以当作队列使用，而队列是一种先进先出（FIFO）的数据结构，即元素可以从队列的一端插入，从另一端移除。从 Queue 继承的方法与 Deque 实现的方法完全等价，如下表：<br>  <table><tr><th style="text-align:center">Queue Method</th><th style="text-align:center">Equivalent Deque Method</th></tr><tr><td style="text-align:center">add(e)</td><td style="text-align:center">addLast(e)</td></tr><tr><td style="text-align:center">offer(e)</td><td style="text-align:center">offerLast(e)</td></tr><tr><td style="text-align:center">remove()</td><td style="text-align:center">removeFirst()</td></tr><tr><td style="text-align:center">poll()</td><td style="text-align:center">pollFirst()</td></tr><tr><td style="text-align:center">element()</td><td style="text-align:center">getFirst()</td></tr><tr><td style="text-align:center">peek()</td><td style="text-align:center">peekFirst()</td></tr></table><br>  Deque 也可以当作栈使用，而栈是一种后进先出（LIFO）的数据结构，即元素只能从 Deque 一端插入，并且从这端移除。从 Stack 继承的方法与 Deque 实现的方法完全等价，如下表：<br>  <table><tr><th style="text-align:center">Stack Method</th><th style="text-align:center">Equivalent Deque Method</th></tr><tr><td style="text-align:center">push(e)</td><td style="text-align:center">addFirst(e)</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">removeFirst()</td></tr><tr><td style="text-align:center">peek()</td><td style="text-align:center">peekFirst()</td></tr></table>

</table></table></li>
</ul>
<p>LinkedList 允许添加所有元素，包括 null 元素。</p>
<p>LinkedList 是线程不安全，只能在单线程环境下工作；如果要在多线程环境下工作，则可以使用 Collections.synchronizedList 创建 List，返回线程安全 LinkedList 实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</div></pre></td></tr></table></figure>
<p>从上面对 LinkedList 的介绍可知，LinkedList 的底层实现涉及到双向链表、栈、队列、双端队列这四种数据结构；为了能更好地理解其原理，简单来介绍链表、栈、队列、双端队列这四种数据结构。</p>
<h1 id="二、链表、栈、队列和双端队列（补充知识点）"><a href="#二、链表、栈、队列和双端队列（补充知识点）" class="headerlink" title="二、链表、栈、队列和双端队列（补充知识点）"></a>二、链表、栈、队列和双端队列（补充知识点）</h1><h3 id="1、链表（来源）"><a href="#1、链表（来源）" class="headerlink" title="1、链表（来源）"></a>1、链表（<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" target="_blank" rel="external">来源</a>）</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p>链表有很多种不同类型：<strong>单向链表、单向循环链表、双向链表、双向循环链表</strong>。下面通过图解加深理解。</p>
<ul>
<li><p><strong>单向链表</strong>：单向链表是链表中最简单的一种。链表是由各个节点串起来而组成的，不同种类型链表的节点所包含的域不同。对于单向链表而言，每个节点包含两个域：数据域和指针域。数据域所要存放的是这个节点的内容，比如基本数据类型、引用类型以及自定义类型；而指针域存放的是下一个节点的内存地址。一般来说，在一个固定的位置保存着指向第一个节点的指针；最后一个节点的指针域保存着一个特殊的标记。</p>
<p>  <img src="images/java/collection/linkedlist/one_way_linked_list.png" alt=""></p>
</li>
<li><p><strong>单向循环链表</strong>：单向循环链表是在单向链表的基础上，将最后一个节点的指针域指向第一个节点，就构成了单向循环链表。</p>
<p>  <img src="images/java/collection/linkedlist/one_way_circular_linked_list.png" alt=""></p>
</li>
<li><p><strong>双向链表</strong>：与单向链表相比，双向链表更复杂些。双向链表包含三个域：两个指针域和一个数据域。在这两个指针域中，一个指针域（pre）存放的是前一个节点的内存地址，被指向的节点称为前驱节点；另一个指针域（next）存放的是后一个节点的内存地址，被指向的节点称为后继节点；而数据域存放的是该节点的内容。一般来说，第一个节点的 pre 指针指向 null，最后一个节点的 next 指针指向 null。</p>
<p>  <img src="images/java/collection/linkedlist/doubly_linked_list.png" alt=""></p>
</li>
<li><p><strong>双向循环链表</strong>：双向循环链表是在双向链表的基础上，将第一个节点的 pre 指针指向最后一个节点，最后一个节点的 next 指向第一个节点，形成一个环，构成双向循环链表。</p>
<p>  <img src="images/java/collection/linkedlist/doubly_circular_linked_list.png" alt=""></p>
</li>
</ul>
<h3 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h3><p>栈是一种简单的数据结构，在计算机科学中有着广泛的应用。栈（stack）是限定仅在表尾进行插入和删除操作的线性表。因此，对于栈来说，表尾端有其特殊含义，称为<strong>栈顶</strong>（top）；相应地，表头端称为<strong>栈底</strong>（bottom）。不含元素的空表称为<strong>空栈</strong>。</p>
<p>由于栈只局限于在一端进行操作，因此使它具有后进先出（Last In First Out）的特点。这特点在生活中是很常见的，比如往一个箱子装书，当把箱子装满时，这时如果要取最后一本书或者倒数第二本书，都必须得把前面的书拿出来，才能拿到自己想要的书。除此之外，除了头尾节点外，每一个节点都有一个前驱节点和一个后继节点。</p>
<p><img src="images/java/collection/linkedlist/stack.png" alt=""></p>
<h3 id="3、队列（来源）"><a href="#3、队列（来源）" class="headerlink" title="3、队列（来源）"></a>3、队列（<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97" target="_blank" rel="external">来源</a>）</h3><p>队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（队尾，称为 rear）进行插入操作，在前端（队头，称为 front）进行删除操作。</p>
<p><img src="images/java/collection/linkedlist/queue.png" alt=""></p>
<h3 id="4、双端队列"><a href="#4、双端队列" class="headerlink" title="4、双端队列"></a>4、双端队列</h3><p>双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称作端点 1 和端点 2。</p>
<p><img src="images/java/collection/linkedlist/deque.png" alt=""></p>
<p>基础知识简单介绍完了，可以开始源码分析之旅了。</p>
<h1 id="三、LinkedList-继承关系图"><a href="#三、LinkedList-继承关系图" class="headerlink" title="三、LinkedList 继承关系图"></a>三、LinkedList 继承关系图</h1><p><img src="images/java/collection/linkedlist/linked_list.png" alt=""></p>
<h1 id="四、LinkedList-源码分析"><a href="#四、LinkedList-源码分析" class="headerlink" title="四、LinkedList 源码分析"></a>四、LinkedList 源码分析</h1><p>由于 LinkedList 底层实现的灵活性，既可以当作双向链表使用，也可以当作栈、队列和双端队列使用，因此对于源码的分析将分开讲解。</p>
<h2 id="（一）、LinkedList-基于双向链表实现"><a href="#（一）、LinkedList-基于双向链表实现" class="headerlink" title="（一）、LinkedList 基于双向链表实现"></a>（一）、LinkedList 基于双向链表实现</h2><h3 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h3><p>从 LinkedList 源码实现来看，就提供 3 个属性，分别如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"> </div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<p>很明显可以注意到，这三个属性前面都有 <strong>transient</strong> 修饰，那么 <strong>transient</strong> 是什么呢？有什么作用呢？其实 <strong>transient</strong> 是 Java 中的一个关键字，只能用来修饰变量，不能修饰类和方法；作用是被修饰的变量不是对象持久化的一部分，换句话说，被 <strong>transient</strong> 修饰的变量不能被序列化。由于 LinkedList 实现 java.io.Serializable 接口，对象可以被序列化，但是对于属性 <strong>size</strong>、<strong>first</strong>、<strong>last</strong> 不想被序列化，就在前面加了关键字 <strong>transient</strong>。</p>
<p>接下来简单说下这三个属性的具体作用。属性 <strong>size</strong> 表示 list 的长度，即节点的个数；属性 <strong>first</strong> 表示指向链表第一个节点；<strong>last</strong> 表示指向链表最后一个节点。</p>
<h3 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h3><p>LinkedList 提供两个构造函数，一个无参构造函数和一个有参构造函数，分别如下：</p>
<p>无惨构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造空列表</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有参构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将包含指定元素的集合 c 添加到 list</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> c 包含指定元素的集合</div><div class="line"> * <span class="doctag">@throws</span> 如果指定的集合是 null，那么将抛出 NullPointerException</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 调用无惨构造方法</span></div><div class="line">    <span class="keyword">this</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 将集合的所有元素添加到 list，具体分析见下面</span></div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、静态内部类-Node-lt-E-gt"><a href="#3、静态内部类-Node-lt-E-gt" class="headerlink" title="3、静态内部类 Node &lt;E&gt;"></a>3、静态内部类 Node &lt;E&gt;</h3><p>本来是要直接分析如何添加元素的，但是看了源码后，发现 Node<e> 这个类贯穿 LinkedList 的整个实现，所以有必要先讲下。源码实现如下：</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line">    </div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node<e> 是一个静态内部类，采用泛型，表示的是双向链表中每个节点的数据结构。也就是说，每个节点包含三个域，一个数据域和两个指针域，数据域存储的是当前节点的内容（item），而指针域一个存放的是当前节点的前一个节点（前驱节点 prev）的内存地址，另一个指针域存放的是当前节点的后一个节点（后继节点 next）的内存地址。</e></p>
<h3 id="4、添加元素"><a href="#4、添加元素" class="headerlink" title="4、添加元素"></a>4、添加元素</h3><p>LinkedList 提供多个版本添加元素，有添加单个元素的，在指定位置添加元素或者添加集合包含的元素。至于具体如何实现，下面一一分析。</p>
<h4 id="1-、添加单个元素"><a href="#1-、添加单个元素" class="headerlink" title="(1)、添加单个元素"></a>(1)、添加单个元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定元素添加到 list 末尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> 被添加到 list 元素</div><div class="line"> * <span class="doctag">@return</span> true</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">     linkLast(e);</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看 linkLast(e) 的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加元素到链表末尾</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将最后一个节点 last 保存到变量 l</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="comment">// 创建新节点 newNode，l 作为新节点的前驱节点（前一个节点）</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">// last 指向新节点 newNode，即新节点 newNode 作为最后一个节点 last</span></div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点</span></div><div class="line">        first = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 链表不为空表，将新节点 newNode 插入到链表末尾，l 的下一个节点指向新节点 newNode</span></div><div class="line">        l.next = newNode;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 链表节点数加 1  </span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上给出了详细的注释，其余就不多说了。接下来通过图解来理解链表不为空表时是如何将指定元素添加到链表末尾，如下图：</p>
<p><img src="images/java/collection/linkedlist/link_last.png" alt=""></p>
<h4 id="（2）、在双向链表指定位置添加新元素"><a href="#（2）、在双向链表指定位置添加新元素" class="headerlink" title="（2）、在双向链表指定位置添加新元素"></a>（2）、在双向链表指定位置添加新元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查 index 是否越界，注意 index 是从 0 开始的</span></div><div class="line">    checkPositionIndex(index);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (index == size) &#123;</div><div class="line">        <span class="comment">// 双向链表是空表或者在双向链表末尾添加新元素，linkLast(element) 方法分析见上</span></div><div class="line">        linkLast(element);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 在双向链表指定的位置添加新元素</span></div><div class="line">        linkBefore(element, node(index));</div><div class="line">    &#125;         </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 10 行代码将指定的元素添加到双向链表指定的位置，在添加新元素之前必须找到index 所指向的节点，即方法 node(index)。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line">    </div><div class="line">    <span class="comment">// 采用一次二分法查找元素，size &gt;&gt; 1 相当于 size / 2</span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</div><div class="line">            x = x.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</div><div class="line">            x = x.prev;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从方法 node(int) 源代码可以看出，LinkedList 通过索引 index 访问元素是遍历整个链表，不像 ArrayList 可以随机访问元素。在这里采用一次二分法查找元素，同样也要遍历元素，只不过是遍历元素的个数为原先的一半。如果 index 在前半部分，则从头开始遍历；如果 index 在后半部分，则从尾开始遍历；最后将查找的节点返回。</p>
<p>回到方法 add(int, E)，再看第 10 行代码，将参数 index 和调用方法 node(int) 返回的节点传给方法 linkBefore(int, Node<e>)，该方法的具体实现如下：</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert succ != null;</span></div><div class="line">    <span class="comment">// 将通过 index 遍历查找到的节点 succ 的前驱节点（前一个节点）prev 赋值给 pred</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">    <span class="comment">// 创建新节点 newNode，pred 作为 newNode 前驱节点，succ 作为 newNode 的后继节点</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">    <span class="comment">// succ 的 prev 指向新节点 newNode</span></div><div class="line">    succ.prev = newNode;</div><div class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点</span></div><div class="line">        first = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// pred 的 next 指向新节点 newNode</span></div><div class="line">        pred.next = newNode;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 双向链表的个数加 1</span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过注释不难理解该方法的实现逻辑，下面通过图解加深对该方法的理解，如下图：</p>
<p><img src="images/java/collection/linkedlist/link_before.png" alt=""></p>
<h4 id="3-、将集合包含的元素添加到双向列表中"><a href="#3-、将集合包含的元素添加到双向列表中" class="headerlink" title="(3)、将集合包含的元素添加到双向列表中"></a>(3)、将集合包含的元素添加到双向列表中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将集合包含指定的所有元素添加到双向列表末尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> c 包含指定元素的集合</div><div class="line"> * <span class="doctag">@return</span> 添加成功返回 true</div><div class="line"> * <span class="doctag">@throws</span> c 为 null 抛出异常 NullPointerException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就一行代码，调用 add(int, Collection&lt;? extends E&gt;)，看下具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定集合中的所有元素插入到列表中，从指定的位置开始。将当前在该位置的</div><div class="line"> * 元素（如果有的话）和随后的元素移到右侧（增加它们的索引）。新元素将按照</div><div class="line"> * 指定集合的​​迭代器返回的顺序出现在列表中。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> index 插入到列表起始位置</div><div class="line"> * <span class="doctag">@return</span> 成功插入时返回 true</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</div><div class="line"> * <span class="doctag">@throws</span> c 为 null 抛出异常 NullPointerException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    checkPositionIndex(index);</div><div class="line">    </div><div class="line">    <span class="comment">// 将集合 c 转换为数组</span></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    </div><div class="line">    <span class="comment">// 集合元素的个数</span></div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    </div><div class="line">    <span class="comment">// 集合元素个数为 0，返回 false</span></div><div class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 定义前驱节点 pred 和后继节点 succ</span></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断是从列表的末尾插入还是某个位置</span></div><div class="line">    <span class="keyword">if</span> (index == size) &#123;</div><div class="line">        succ = <span class="keyword">null</span>;</div><div class="line">        pred = last;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        succ = node(index);</div><div class="line">        pred = succ.prev;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 遍历数组中元素，创建新节点，并指定新节点的前驱节点和后继节点，然后插入到列表</span></div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pred.next = newNode;</div><div class="line">        pred = newNode;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">        last = pred;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pred.next = succ;</div><div class="line">        succ.prev = pred;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信通过以上注释不难理解该方法的实现逻辑。该方法实现逻辑将集合中指定的元素插入到列表有种情况：一种是从列表的末尾插入，另一种是从列表的某个位置插入，这与上面所讲解两个添加元素的方法的原理是一样的，区别只在于是添加单个元素还是添加多个元素，如何插入到链表中参考以上两个方法的图解。</p>
<h3 id="5、删除元素"><a href="#5、删除元素" class="headerlink" title="5、删除元素"></a>5、删除元素</h3><p>LinkedList 也提供好多个版本删除元素，下面一一来看具体实现。</p>
<h4 id="（1）、删除元素"><a href="#（1）、删除元素" class="headerlink" title="（1）、删除元素"></a>（1）、删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索和删除列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回 list 第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的抛出 NoSuchElementException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看 removeFirst() 具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除并返回列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 从列表返回的第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的抛出 NoSuchElementException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 保存 list 第一个节点到变量 f，并作为参数传给 unlinkFirst(Node&lt;E&gt;)</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看方法 unlinkFirst(Node<e>) 具体实现</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></div><div class="line">    <span class="comment">// 保存 f 的 item 到变量 element，并作为返回值返回</span></div><div class="line">    <span class="keyword">final</span> E element = f.item;</div><div class="line">    <span class="comment">// 保存 f 的下一个节点到变量 next</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</div><div class="line">    <span class="comment">// 释放资源，f 的 item 和 next 置 null</span></div><div class="line">    f.item = <span class="keyword">null</span>;</div><div class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    <span class="comment">// first 指针指向被删除第一个节点的下一个节点 next</span></div><div class="line">    first = next;</div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 列表只有一个元素的情况下</span></div><div class="line">        last = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// list 第一个节点的 prev 指向 null</span></div><div class="line">        next.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 列表的节点数加 1 </span></div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于删除 list 第一个节点的实现逻辑也挺简单的。简单来说就是先把第一个节点 first 的数据域和指针域保存起来，然后置空，释放资源；如果列表元素个数大于 1 的话，将 first 指针移动到下一个元素，并重新对 first 节点的 prev 进行设置。</p>
<h4 id="（2）、删除列表中指定位置的元素"><a href="#（2）、删除列表中指定位置的元素" class="headerlink" title="（2）、删除列表中指定位置的元素"></a>（2）、删除列表中指定位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除列表中指定位置的元素，返回从列表被删除的元素</div><div class="line"> * </div><div class="line"> *  <span class="doctag">@param</span> index 被移除元素的索引</div><div class="line"> *  <span class="doctag">@return</span> 返回指定位置的元素</div><div class="line"> *  <span class="doctag">@throws</span> IndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="comment">// 调用 node(int) 方法查找要删除的元素</span></div><div class="line">    <span class="keyword">return</span> unlink(node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的实现也挺简单的，核心实现是第 2 行代码，看方法 unlink(Node<e>) 具体实现：</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="comment">// 保存被删除元素的数据域 item 和指针域 next、prev</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断被删除节点是否是第一个节点，然后作出相应的实现</span></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        <span class="comment">// 释放资源，将被删除节点 x 的 prev 置 null</span></div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断被删除节点是否是最后一个节点，然后作出相应的实现</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        <span class="comment">// 释放资源，将被删除节点 x 的 next 置 null</span></div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放资源，将被删除节点 x 的 item 置 null</span></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 列表的节点数减 1</span></div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的实现同样也先保存被删除节点的数据域和指针域，然后判断该节点时列表的第一个节点还是最后一个节点或者是在列表个数之间的节点，作出相应的处理。对于删除第一个节点或者最后一个节点稍微比较简单，不再作出分析。对于删除位于列表之间的节点，通过图解加深理解，如下图：</p>
<p><img src="images/java/collection/linkedlist/unlink.png" alt=""></p>
<h4 id="（3）、检索并删除元素"><a href="#（3）、检索并删除元素" class="headerlink" title="（3）、检索并删除元素"></a>（3）、检索并删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，首先判断要删除的元素 o 是否为 null，如果为 null 的话，遍历列表是否存在空元素，存在的则调用 unlink(Node<e>) 方法删除元素并返回 true；不为 null 的话也是遍历列表是否存在该元素，存在的话则调用 unlink(Node<e>) 方法删除元素并返回 true。至于 unlink(Node<e>) 是如何实现的看上面分析。</e></e></e></p>
<h3 id="6、修改元素"><a href="#6、修改元素" class="headerlink" title="6、修改元素"></a>6、修改元素</h3><p>LinkedList 提供修改列表元素的方法，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用指定的元素替换此列表中指定位置的元素。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> index 要替换的元素的索引</div><div class="line"> * <span class="doctag">@param</span> element 元素存储子在的指定位置</div><div class="line"> * <span class="doctag">@return</span> 返回被替换的元素</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="comment">// 遍历列表查找索引为 index 的节点</span></div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    <span class="comment">// 保存被替换元素到变量 oldVal，并作为返回值返回</span></div><div class="line">    E oldVal = x.item;</div><div class="line">    <span class="comment">// 修改元素的值</span></div><div class="line">    x.item = element;</div><div class="line">    <span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现逻辑挺简单的，就不再作分析了。</p>
<h3 id="7、查询元素"><a href="#7、查询元素" class="headerlink" title="7、查询元素"></a>7、查询元素</h3><p>对于查询列表元素，LinkedList 提供通过索引检索元素的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回列表中指定位置的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> index 要返回的元素的索引</div><div class="line"> * <span class="doctag">@return</span> 返回列表中指定位置的元素</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查 index 是否越界</span></div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="comment">// 遍历列表查找索引为 index 的节点并获取其 item 作为返回值返回</span></div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8、清空列表"><a href="#8、清空列表" class="headerlink" title="8、清空列表"></a>8、清空列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></div><div class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></div><div class="line">    <span class="comment">//   more than one generation</span></div><div class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></div><div class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</div><div class="line">        Node&lt;E&gt; next = x.next;</div><div class="line">        x.item = <span class="keyword">null</span>;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">        x = next;</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    first = last = <span class="keyword">null</span>;</div><div class="line">    size = <span class="number">0</span>;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>清空整个列表，简单来说就是遍历整个列表，把每个节点的三个域：数据域和两个指针域置 null，并且将 first 和 last 置 null，列表长度 size 为 0。</p>
<h3 id="9、判断列表是否包含指定的元素"><a href="#9、判断列表是否包含指定的元素" class="headerlink" title="9、判断列表是否包含指定的元素"></a>9、判断列表是否包含指定的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 如果列表包含指定元素，则返回 true</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> o 检查元素是否存在于列表</div><div class="line"> * <span class="doctag">@return</span> 如果列表包含指定元素，则返回 true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果 indexOf(Object) 方法不返回 -1，则表示要查找的元素存在于列表，那么该方法是怎么实现的，来看下源码实现就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回此列表中指定元素第一次出现的索引;如果此列表不包含元素，则返回-1。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> o 检索的元素</div><div class="line"> * <span class="doctag">@return</span> 返回此列表中指定元素第一次出现的索引;如果此列表不包含元素，则返回-1。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item))</div><div class="line">                <span class="keyword">return</span> index;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出，首先判断要查找的元素 o 是否为 null，如果为 null 的话，遍历列表是否存在空元素，存在的则返回该元素在列表的位置 index，否则继续遍历；不为 null 的话也是遍历列表是否存在该元素，存在的则返回该元素在列表的位置 index，否则继续遍历；如果最后搜索不到该元素的话直接返回 -1。</p>
<h3 id="10、从列表末尾开始检索指定元素是否存在列表"><a href="#10、从列表末尾开始检索指定元素是否存在列表" class="headerlink" title="10、从列表末尾开始检索指定元素是否存在列表"></a>10、从列表末尾开始检索指定元素是否存在列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回指定元素的最后一次出现的索引在此列表中，如果此列表不包含元素，</div><div class="line"> * 则为-1。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> o 检索的元素</div><div class="line"> * <span class="doctag">@return</span> 返回指定元素的最后一次出现的索引在此列表中，</div><div class="line"> * 如果此列表不包含元素，则为-1。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = size;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</div><div class="line">            index--;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> index;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</div><div class="line">            index--;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item))</div><div class="line">                <span class="keyword">return</span> index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lastIndexOf(Object) 方法与 indexOf(Object) 的区别在于该方法是从列表末尾开始查找指定的元素是否存在。</p>
<h3 id="11、获取列表元素个数"><a href="#11、获取列表元素个数" class="headerlink" title="11、获取列表元素个数"></a>11、获取列表元素个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回列表元素个数</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表元素个数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="（二）、LinkedList-实现-Deque-双端队列"><a href="#（二）、LinkedList-实现-Deque-双端队列" class="headerlink" title="（二）、LinkedList 实现 Deque 双端队列"></a>（二）、LinkedList 实现 Deque 双端队列</h2><p>LinkedList 实现 Deque 接口，因此可以把它当作双端队列使用。理解了双向链表的原理后，再来理解双端队列的基本操作操作应该很容易了。Deque 实现基本操作可以分为三种：插入元素、删除元素和查询元素。每种操作的实现方法都有两种形式，一种是如果操作失败时抛出异常；一种是如果操作失败返回 null 或者 false。以下对这三种操作分别作出解析。</p>
<h3 id="1、插入元素"><a href="#1、插入元素" class="headerlink" title="1、插入元素"></a>1、插入元素</h3><h4 id="（1）、在列表的开始处插入指定元素（第一种形式：抛出异常）"><a href="#（1）、在列表的开始处插入指定元素（第一种形式：抛出异常）" class="headerlink" title="（1）、在列表的开始处插入指定元素（第一种形式：抛出异常）"></a>（1）、在列表的开始处插入指定元素（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在列表的开始处插入指定元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> 添加的元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看 linkFirst(E) 的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 链接元素 e，作为列表第一个元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将第一个节点 first 保存到变量 f</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="comment">// 创建新节点 newNode，f 作为新节点 newNode 的后继节点（后一个节点）</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</div><div class="line">    <span class="comment">// first 指向新节点 newNode，即新节点 newNode 作为第一个节点 first    </span></div><div class="line">    first = newNode;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 链表是空表，新节点 newNode 既是第一个节点又是最后一个节点</span></div><div class="line">        last = newNode;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 链表不为空表，将新节点 newNode 插入到表头，f 的上一个节点指向新节点 newNode</span></div><div class="line">        f.prev = newNode;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 链表节点数加 1  </span></div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上给出了详细的注释，其余就不多说了。接下来通过图解来理解链表不为空表时是如何将指定元素插入表头，如下图：</p>
<p><img src="images/java/collection/linkedlist/link_first.png" alt=""></p>
<h4 id="（2）、在列表的前面插入指定的元素（第二种形式：返回特定值）"><a href="#（2）、在列表的前面插入指定的元素（第二种形式：返回特定值）" class="headerlink" title="（2）、在列表的前面插入指定的元素（第二种形式：返回特定值）"></a>（2）、在列表的前面插入指定的元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在列表的前面插入指定的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> e 插入元素</div><div class="line"> * <span class="doctag">@return</span> true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法最终是调用 addFirst(E)，并且返回 true，至于方法的分析见上面的分析。</p>
<h4 id="（3）、将指定的元素添加到列表末尾（第一种形式：抛出异常）"><a href="#（3）、将指定的元素添加到列表末尾（第一种形式：抛出异常）" class="headerlink" title="（3）、将指定的元素添加到列表末尾（第一种形式：抛出异常）"></a>（3）、将指定的元素添加到列表末尾（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定的元素添加到列表末尾，该方法与  add(java.lang.Object) 等价</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> e 添加的元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到第 2 行代码很熟悉吧，具体分析看上面。</p>
<h4 id="（4）、在列表的末尾插入指定的元素（第二种形式：返回特定值）"><a href="#（4）、在列表的末尾插入指定的元素（第二种形式：返回特定值）" class="headerlink" title="（4）、在列表的末尾插入指定的元素（第二种形式：返回特定值）"></a>（4）、在列表的末尾插入指定的元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在列表的末尾插入指定的元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> e 添加的元素</div><div class="line"> * <span class="doctag">@return</span> true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法实现逻辑很简单，调用方法 addLast(E) 并返回 true。</p>
<h3 id="2、删除元素"><a href="#2、删除元素" class="headerlink" title="2、删除元素"></a>2、删除元素</h3><h4 id="（1）、从列表中删除并返回第一个元素（第一种形式：抛出异常）"><a href="#（1）、从列表中删除并返回第一个元素（第一种形式：抛出异常）" class="headerlink" title="（1）、从列表中删除并返回第一个元素（第一种形式：抛出异常）"></a>（1）、从列表中删除并返回第一个元素（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除并返回列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 从列表返回的第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的抛出 NoSuchElementException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 保存 list 第一个节点到变量 f，并作为参数传给 unlinkFirst(Node&lt;E&gt;)</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-、从列表中删除并返回第一个元素（第二种形式：返回特定值）"><a href="#2-、从列表中删除并返回第一个元素（第二种形式：返回特定值）" class="headerlink" title="(2)、从列表中删除并返回第一个元素（第二种形式：返回特定值）"></a>(2)、从列表中删除并返回第一个元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索并删除此列表的第一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表第一个元素或者如果列表是空，则返回 null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（3）、从列表中删除并返回最后一个元素（第一种形式：抛出异常）"><a href="#（3）、从列表中删除并返回最后一个元素（第一种形式：抛出异常）" class="headerlink" title="（3）、从列表中删除并返回最后一个元素（第一种形式：抛出异常）"></a>（3）、从列表中删除并返回最后一个元素（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除并返回列表最后一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表最后一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表为空抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 保存 list 最后一个节点到变量 l，并作为参数传给 unlinkLast(Node&lt;E&gt;)</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkLast(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看方法 unlinkLast(Node<e>) 具体实现</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></div><div class="line">    <span class="comment">// 保存 l 的 item 到变量 element，并作为返回值返回</span></div><div class="line">    <span class="keyword">final</span> E element = l.item;</div><div class="line">    <span class="comment">// 保存 l 的 prev 到变量 prev</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</div><div class="line">    <span class="comment">// 释放资源，将 l 的 item 和 prev 置 null</span></div><div class="line">    l.item = <span class="keyword">null</span>;</div><div class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">    <span class="comment">// 移动 last 指针，指向被删除节点的前驱节点 prev</span></div><div class="line">    last = prev;</div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 由于 prev 是列表最后一个节点，因此 prev 的 next 指向 null</span></div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 列表节点数减 1    </span></div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与方法 unlinkFirst(Node<e>) 实现逻辑类似的，只不过一个是删除头节点，一个是删除尾节点。简单来说就是先把最后一个节点 last 的数据域和指针域保存起来，然后置空，释放资源；如果列表元素个数大于 1 的话，将 last 指针移动到上一个节点，并重新对 last 节点的 next 进行设置。</e></p>
<h4 id="（4）、从列表中删除并返回最后一个元素（第二种形式：返回特定值）"><a href="#（4）、从列表中删除并返回最后一个元素（第二种形式：返回特定值）" class="headerlink" title="（4）、从列表中删除并返回最后一个元素（第二种形式：返回特定值）"></a>（4）、从列表中删除并返回最后一个元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索并删除此列表的最后一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表第一个元素或者如果列表是空，则返回 null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、查询元素"><a href="#3、查询元素" class="headerlink" title="3、查询元素"></a>3、查询元素</h3><h4 id="（1）、查询列表第一个元素（第一种形式：抛出异常）"><a href="#（1）、查询列表第一个元素（第一种形式：抛出异常）" class="headerlink" title="（1）、查询列表第一个元素（第一种形式：抛出异常）"></a>（1）、查询列表第一个元素（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 列表第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的，抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> f.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（2）、查询列表第一个元素（第二种形式：返回特定值）"><a href="#（2）、查询列表第一个元素（第二种形式：返回特定值）" class="headerlink" title="（2）、查询列表第一个元素（第二种形式：返回特定值）"></a>（2）、查询列表第一个元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表第一个元素，如果列表为空，则返回 null。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（3）、查询列表最后一个元素（第一种形式：抛出异常）"><a href="#（3）、查询列表最后一个元素（第一种形式：抛出异常）" class="headerlink" title="（3）、查询列表最后一个元素（第一种形式：抛出异常）"></a>（3）、查询列表最后一个元素（第一种形式：抛出异常）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回列表最后一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 列表最后一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的，抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> l.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="（3）、查询列表最后一个元素（第二种形式：返回特定值）"><a href="#（3）、查询列表最后一个元素（第二种形式：返回特定值）" class="headerlink" title="（3）、查询列表最后一个元素（第二种形式：返回特定值）"></a>（3）、查询列表最后一个元素（第二种形式：返回特定值）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索但不移除此列表的最后一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表最后一个元素，如果列表为空，则返回 null。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="（三）、LinkedList-实现队列-Queue"><a href="#（三）、LinkedList-实现队列-Queue" class="headerlink" title="（三）、LinkedList 实现队列 Queue"></a>（三）、LinkedList 实现队列 Queue</h2><p>Deque 接口继承 Queue 接口，可以当作队列使用，那么 LinkedList 也就实现队列的基本操作，具体实现如下。</p>
<h3 id="1、add-E"><a href="#1、add-E" class="headerlink" title="1、add(E)"></a>1、add(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定元素添加到 list 末尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> 被添加到 list 元素</div><div class="line"> * <span class="doctag">@return</span> true</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">     linkLast(e);</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、off-E"><a href="#2、off-E" class="headerlink" title="2、off(E)"></a>2、off(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 添加指定元素到列表尾</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> e 添加的元素</div><div class="line"> * <span class="doctag">@return</span> true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> add(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、remove"><a href="#3、remove" class="headerlink" title="3、remove()"></a>3、remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索和删除列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回 list 第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的抛出 NoSuchElementException </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、poll"><a href="#4、poll" class="headerlink" title="4、poll()"></a>4、poll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索并删除此列表的头（第一个元素）。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表的表头，如果列表为空，则返回 null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、element"><a href="#5、element" class="headerlink" title="5、element()"></a>5、element()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回列表第一个元素</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 列表第一个元素</div><div class="line"> * <span class="doctag">@throws</span> 如果列表是空的，抛出异常 NoSuchElementException</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、peek"><a href="#6、peek" class="headerlink" title="6、peek()"></a>6、peek()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表第一个元素，如果列表为空，则返回 null。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="（四）、LinkedList-实现栈-Stack"><a href="#（四）、LinkedList-实现栈-Stack" class="headerlink" title="（四）、LinkedList 实现栈 Stack"></a>（四）、LinkedList 实现栈 Stack</h2><p>由于 Deque 接口可以当作栈（Stack）使用，那么 LinkedList 也实现栈的基本操作，来看下是怎么实现的吧。</p>
<h3 id="1、入栈"><a href="#1、入栈" class="headerlink" title="1、入栈"></a>1、入栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定元素压入到列表所表示的栈；换句话说，将元素插入到列表表头。</div><div class="line"> * </div><div class="line"> * 该方法与 addFirst(E) 等价</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> 入栈元素</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    addFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、出栈"><a href="#2、出栈" class="headerlink" title="2、出栈"></a>2、出栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从列表所表示的栈弹出元素；换句话说，删除并返回此列表的第一个元素。</div><div class="line"> * </div><div class="line"> * 该方法与 removeFirst() 等价</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> removeFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、查询元素-1"><a href="#3、查询元素-1" class="headerlink" title="3、查询元素"></a>3、查询元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检索但不移除此列表的第一个元素，如果此列表为空，则返回null。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 返回列表第一个元素，如果列表为空，则返回 null。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上可以看出，不管 LinkedList 是当作双端队列使用，还是当作队列或者栈使用，其底层实现是通过链表实现的。</p>
<h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><ul>
<li><p>LinkedList 是基于双向链表实现的。</p>
</li>
<li><p>对于插入或者删除元素，如果从列表两端插入或者删除元素的时，执行效率是高效的；如果是在列表指定的位置插入或者删除元素的话，需要先通过索引遍历查找指定的元素，再执行相关操作，效率明显降低了。</p>
</li>
<li><p>LinkedList 不存在容量这个问题，也就不存在扩容之说，这是与 ArrayList 不同的，ArrayList 当容量不满足的话，需要进行扩容的。</p>
</li>
<li><p>LinkedList 是线程不同步的。</p>
</li>
<li><p>由于 LinkedList 实现 Deque 接口，因此 LinkedList 既可以当作双端队列使用，又可以当作队列或者栈，但是底层都是由双向链表实现。</p>
</li>
</ul>
<h1 id="六、LinkedList-与-ArrayList-异同"><a href="#六、LinkedList-与-ArrayList-异同" class="headerlink" title="六、LinkedList 与 ArrayList 异同"></a>六、LinkedList 与 ArrayList 异同</h1><h3 id="1、LinkedList-与-ArrayList-的区别"><a href="#1、LinkedList-与-ArrayList-的区别" class="headerlink" title="1、LinkedList 与 ArrayList 的区别"></a>1、LinkedList 与 ArrayList 的区别</h3><ul>
<li><p>LinkedList 是基于双向链表实现；而 ArrayList 是基于数组实现，可以理解为动态数组。</p>
</li>
<li><p>LinkedList 没有实现 RandomAccess 接口，不具有随机访问元素的功能，对于访问元素需要遍历整个列表，效率显然很低；而 ArrayList 实现了RandomAccess 接口，可以通过索引快速随机访问元素，效率高。</p>
</li>
<li><p>LinkedList 是基于双向链表实现的，在插入或删除元素时效率相对较高，只需要记录当前节点的前驱节点和后继节点；而 ArrayList 在插入或者删除元素时，需要移动数组里的元素，即复制数组。</p>
</li>
<li><p>LinkedList 不用预先分配内存空间，不存在容量问题；而 ArrayList 在创建数组时需要指定其容量，存在容量问题。当容量不足时，需要扩容，为原来的 1.5 倍，扩容是很消耗性能的，因此有可能的话在创建数组时预先指定其容量。</p>
</li>
</ul>
<h3 id="2、LinkedList-与-ArrayList-相同点"><a href="#2、LinkedList-与-ArrayList-相同点" class="headerlink" title="2、LinkedList 与 ArrayList 相同点"></a>2、LinkedList 与 ArrayList 相同点</h3><ul>
<li><p>允许存储所有元素，包括 null 元素；</p>
</li>
<li><p>线程不同步；</p>
</li>
<li><p>存储的元素允许重复。</p>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.jianshu.com/p/d5ec2ff72b33" target="_blank" rel="external">Java集合干货系列-（二）LinkedList源码解析</a>    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;LinkedList 底层实现基于&lt;strong&gt;双向链表&lt;/strong&gt;，除了可以当作链表使用外，LinkedList 
    
    </summary>
    
      <category term="Java" scheme="http://panzeyong.com/categories/Java/"/>
    
    
      <category term="Java 集合框架" scheme="http://panzeyong.com/tags/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架：ArrayList（JDK 8）</title>
    <link href="http://panzeyong.com/2017/11/07/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%9AArrayList/"/>
    <id>http://panzeyong.com/2017/11/07/Java-集合框架：ArrayList/</id>
    <published>2017-11-07T00:43:33.000Z</published>
    <updated>2017-12-12T01:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>ArrayList 是<strong>数组队列</strong>，相当于<strong>动态数组</strong>，其底层结构是由<strong>数组</strong>实现。ArrayList 继承 AbstractList 抽象类，实现 List、RandomAccess、Clone、java.io.Serializable 接口。</p>
<ul>
<li><p>ArrayList 继承 AbstractList 抽象类，实现 List 接口。它是一个数组队列，提供了增删改查以及遍历等功能。</p>
</li>
<li><p>ArrayList 实现 RandomAccess 接口，提供快速随机访问功能。RandomAccess 接口被 List 实现主要用来支持快速随机访问，通过数组下标随机访问元素。</p>
</li>
<li><p>ArrayList 实现 Clone 接口，重写 Object <code>clone()</code> 方法可以克隆对象。</p>
</li>
<li><p>ArrayList 实现 java.io.Serializable 接口，可以进行序列化和反序列化，方便数据传输。</p>
</li>
</ul>
<p>ArrayList 允许添加所有元素，包括 null 元素。</p>
<p>与 Java 数组相比，ArrayList 实现容量动态增长。简单来说，当向 ArrayList 添加新元素时，会将 ArrayList 实际元素个数加 1（size + 1）与底层数组（elementData）的长度进行比较，如果大于底层数组长度时，则会自动进行扩容（newValue = oldValue + oldValue &gt;&gt; 1，即为原先的 1.5 倍），扩容是对原先数组复制到新数组，相当消耗性能。如果可能的话，提前预估数据规模，调用 ArrayList(init initialCapacity) 构造方法初始化，做到减少扩容，提高效率。</p>
<p>与 Vector 相比，ArrayList 是线程不安全，只能在单线程环境下工作；如果要在多线程环境下工作，则可以使用 <code>Collections.synchronizedList</code> 创建 List，返回线程安全 ArrayList 实例；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList(...));</div></pre></td></tr></table></figure>
<h2 id="二、ArrayList-继承关系图"><a href="#二、ArrayList-继承关系图" class="headerlink" title="二、ArrayList 继承关系图"></a>二、ArrayList 继承关系图</h2><p><img src="/images/java/collection/ArrayList.png" alt=""></p>
<h2 id="三、ArrayList-源码解析"><a href="#三、ArrayList-源码解析" class="headerlink" title="三、ArrayList 源码解析"></a>三、ArrayList 源码解析</h2><h3 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h3><p>ArrayList 提供三个构造函数，分别如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 用初始容量构造空列表</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span>  initialCapacity 列表初始容量</div><div class="line">* <span class="doctag">@throws</span> IllegalArgumentException 如果指定初始容量为负数，则抛出异常 </div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</div><div class="line">        <span class="comment">// 创建数组（elementData 是 ArrayList 底层实现数组，用于存储 ArrayList 列表中所有元素）</span></div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造空数组（默认初始容量 10）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    </div><div class="line">    <span class="comment">// 把空数组赋值给 elementData（elementData 是 ArrayList 底层实现数组，用于存储 ArrayList 列表中所有元素）</span></div><div class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造指定集合元素列表</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> c 集合 c 中的元素复制到 ArrayList</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合为 null ，则抛出空指针</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="comment">// 集合 c 转换为数组赋值给数组 elementData</span></div><div class="line">    elementData = c.toArray();</div><div class="line">    size = elementData.length; <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">    <span class="comment">// 转换数组返回值可能不正确，如果是这样的话，则执行下面的语句</span></div><div class="line">    <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上源码已经给出了详细的注释，这里就不再解释了。不过从第 3 个构造函数可以看出，对数组的复制是调用了 <code>Arrays.copyOf(elementData, size, Object[].class)</code> 方法，那么该方法具体是什么呢，先来看下它的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) <span class="keyword">new</span> Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength);</div><div class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,Math.min(original.length, newLength));</div><div class="line">    <span class="keyword">return</span> copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法采用泛型，<strong>T</strong> 是方法返回值数组类型，而 <strong>U</strong> 是原始数组类型；第 2 行代码是根据传入参数 <strong>newType</strong> 类型创建数组实例。真正对数组执行复制的是第 3 行代码，那么来看它的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</div></pre></td></tr></table></figure>
<p>该方法是 native 方法，接收 5 个参数：</p>
<ul>
<li><p><strong>src</strong>：源数组；</p>
</li>
<li><p><strong>srcPos</strong>：源数组起始位置；</p>
</li>
<li><p><strong>dest</strong>：目标数组；</p>
</li>
<li><p><strong>destPos</strong>：目标数组起始位置；</p>
</li>
<li><p><strong>length</strong>：复制源数组元素个数。</p>
</li>
</ul>
<p>从指定的源数组复制指定位置的数组到目标数组指定的位置。</p>
<h3 id="2、增加元素"><a href="#2、增加元素" class="headerlink" title="2、增加元素"></a>2、增加元素</h3><p>ArrayList 提供多个添加元素的方法，既有添加单个元素也有添加整个集合，具体方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将指定的元素添加到 ArrayList 末尾</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> e 被添加到列表的元素</div><div class="line"> * <span class="doctag">@return</span> true </div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">     <span class="comment">// 检查内部数组 elementData 容量是否满足，不满足的话则扩容</span></div><div class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">     elementData[size++] = e;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的主要功能是往列表的末尾添加元素，实现逻辑挺简单的，短短的 3 行代码，但是每行代码又包含着相应的逻辑，那么就来看下具体是怎么实现的。这里假设一开始创建 ArrayList 实例是调用无参构造函数创建的，也就是说 <strong>elementData</strong> 这个内部数组被赋值<strong>空数组</strong>。第 9 行代码是在添加元素之前对内部数组 elementData 容量进行检查，<strong>ensureCapacityInternal()</strong> 方法传入的参数是原先数组的长度加 1（size + 1），具体实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 判断 elementData 是否为空数组，是的话执行 if 语句里的代码，取 DEFAULT_CAPACITY 与 minCapacity 的最大值作为最小容量</span></div><div class="line">    <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由以上可知，minCapacity 的值为 DEFAULT_CAPACITY，即默认容量 10。再来看 <strong>ensureExplicitCapacity(minCapacity)</strong> 的逻辑实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个字段主要用于记录列表结构被修改的次数，所谓的列表结构可理解为列表长度的改变</span></div><div class="line">    modCount++;</div><div class="line">    </div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 6 行代码的条件满足，执行 if 语句里的代码，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="comment">// 添加新元素之前 elementData 的容量（旧长度）</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 新容量为旧容量的 1.5 倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>增加容量，以确保至少能容纳最小容量参数指定的元素数量。第 12 代码主要功能是实现对数组的复制，由以上对构造函数分析可知，真正实现对数组复制的函数是 <code>System.arraycopy(original, 0, copy, 0,Math.min(original.length, newLength));</code> 即将源数组里的元素拷贝到新数组，然后返回赋值给 elementData。可见，扩容是相当于耗性能的。</p>
<p>扩容完成后，就可以往数组添加元素。回到方法 <code>add(E)</code> 第 10 行代码，将要添加的新元素添加到底层数组 elementData 末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  向列表中指定中位置添加指定的元素</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> index 指定元素被插入到列表的索引</div><div class="line"> * <span class="doctag">@param</span> element 被插入的元素</div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组越界抛出异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查数组是否越界</span></div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">        <span class="comment">// 检查内部数组 elementData 容量是否满足，不满足的话则扩容</span></div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        <span class="comment">// 移动数组中元素，目的为了插入新元素</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的主要功能是往列表指定位置添加新元素，实现逻辑与上一个方法有所不同。第 10 ~ 11 行代码检查是否数组是否越界；第 13 行代码检查容量是否满足，具体分析上面已经分析过；第 15 行代码实现对数组的复制，那么是如何复制的呢，具体分析见下图：</p>
<p><img src="/images/java/collection/add_by_index.png" alt=""></p>
<p>相信通过上图的讲解可以更好地理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 把集合中所有的元素添加到列表中，添加顺序与元素在集合中的顺序一致</div><div class="line"> * </div><div class="line"> * @param c 包含被添加到列表中的元素的集合</div><div class="line"> * @return true</div><div class="line"> * @throws NullPointerException 指定集合为 null 时抛出异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">    size += numNew;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是把集合中的所有元素添加到列表末尾，与 <strong>add(E)</strong> 方法的区别是前者是添加集合所包含的元素；而后者则添加单个元素，其它基本差不多，就不再作分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 把集合中所有的元素添加到列表指定的位置，添加顺序与元素在集合中的顺序一致</div><div class="line"> * <span class="doctag">@param</span> index 集合插入到列表的起始位置</div><div class="line"> * <span class="doctag">@param</span> c 包含被添加到列表中的元素的集合 </div><div class="line"> * <span class="doctag">@return</span> true </div><div class="line"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 数组越界抛出异常</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException 指定集合为 null 时抛出异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div class="line">    </div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</div><div class="line">        </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是向列表指定位置插入多个新元素（集合中所有元素），那么在实现移动源数组元素与 <strong>add(int, E)</strong> 方法的实现基本相同，同样也通过图进行解析：</p>
<p><img src="/images/java/collection/add_collection_by_index.png" alt=""></p>
<h3 id="3、删除元素"><a href="#3、删除元素" class="headerlink" title="3、删除元素"></a>3、删除元素</h3><p>Arraylist 提供多个删除元素方法，既有通过索引删除元素，又有通过 Object 以及删除指定集合包含的元素，具体方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 删除列表指定位置的元素</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> 被删除元素索引</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查要删除元素索引是否在源数组范围内（数组是否越界）</span></div><div class="line">    rangeCheck(index);</div><div class="line">    </div><div class="line">    modCount++;</div><div class="line">    </div><div class="line">    <span class="comment">// 存储被删除元素作为返回值返回</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    </div><div class="line">    <span class="comment">// 移动元素个数</span></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 移动元素</span></div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是通过索引删除列表指定位置的元素，源码中给出详细的注释，再结合下图加深对该方法的理解：</p>
<p><img src="/images/java/collection/remove_by_index.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上源码可以看出，不管 <strong>o</strong> 是否为 null，都需要遍历整个数组 elementData，看该元素是否存在于数组里，存在的话通过调用 <strong>fastRemove(int)</strong> 方法移除并返回 true；不存在的话则返回 false。那么方法 <strong>fastRemove(int)</strong> 是怎么移除元素的呢？具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">该方法的实现逻辑与 **remove(<span class="keyword">int</span>)** 差不多，具体分析看 **remove(<span class="keyword">int</span>)** 的图解。</div><div class="line"></div><div class="line">```java</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从列表中删除指定集合中包含的所有元素</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(c);</div><div class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是移除指定集合中包含的所有元素。第 5 行代码是检查集合 c 是否为空，第 6 行代码是批量移除元素，那么来看下具体是如何实现的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</div><div class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</div><div class="line">                elementData[w++] = elementData[r];</div><div class="line">            &#125; </div><div class="line">    <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">    <span class="comment">// even if c.contains() throws.</span></div><div class="line">        <span class="keyword">if</span> (r != size) &#123;</div><div class="line">            System.arraycopy(elementData, r, elementData, w, size - r);</div><div class="line">            w += size - r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (w != size) &#123;</div><div class="line">            <span class="comment">// clear to let GC do its work</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</div><div class="line">                elementData[i] = <span class="keyword">null</span>;</div><div class="line">            modCount += size - w;</div><div class="line">            size = w;</div><div class="line">            modified = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> modified;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的功能是批量移除元素，实现逻辑也不是很复杂。大致是先遍历源数组 elementData 中元素是否被包含在集合 c 中，被包含的话直接跳过；不被包含的话则将元素复制另一个数组（目标数组），最后目标数组空出来的位置置 null，完成移除元素操作。下面通过图解加深对该方法的理解：</p>
<p><img src="/images/java/collection/batch_remove.png" alt=""></p>
<p>ArrayList 还提供 <strong>removeRange(int fromIndex, int toIndex)</strong> 方法，移除指定范围元素，实现思路与 <strong>batchRemove(Collection&lt;?&gt; c, boolean complement)</strong> 类似，具体分析参考该方法。</p>
<h3 id="4、修改元素"><a href="#4、修改元素" class="headerlink" title="4、修改元素"></a>4、修改元素</h3><p>在 ArrayList 提供增删改查的方法中，修改元素和查询元素方法实现逻辑算是最简单的了，那么怎么个简单法呢？来看下源码实现就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    </div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码上看，逻辑实现确实很简单。一开始检查要修改元素的索引是否越界（第 2 行代码）；接着保存被修改元素的原始值并作为返回值返回，最后修改元素。</p>
<h3 id="5、查询元素"><a href="#5、查询元素" class="headerlink" title="5、查询元素"></a>5、查询元素</h3><p>由于 ArrayList 实现 RandomAccess 接口，因此具有随机快速访问元素的功能，该方法的实现逻辑也很简单，具体看下面源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="keyword">return</span> elementData(index);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是对 ArrayList 源码的初步认识，有时间的话再研究其它，比如遍历、排序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;ArrayList 是&lt;strong&gt;数组队列&lt;/strong&gt;，相当于&lt;strong&gt;动态数组&lt;/strong&gt;，其底层结
    
    </summary>
    
      <category term="Java" scheme="http://panzeyong.com/categories/Java/"/>
    
    
      <category term="Java 集合框架" scheme="http://panzeyong.com/tags/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Activity</title>
    <link href="http://panzeyong.com/2017/11/07/Activity/"/>
    <id>http://panzeyong.com/2017/11/07/Activity/</id>
    <published>2017-11-06T23:40:09.000Z</published>
    <updated>2017-11-06T23:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>Activity 应用组件，是 Android 程序与用户交互的窗口。通常来说，Activity 呈现给用户的是充满整个窗口，但是也有其它方式，比如悬浮窗口（设置 <strong>windowIsFloating</strong>）或者嵌套在另一个 Activity 里面（<strong>ActivityGroup</strong>）。</p>
<h1 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h1><p>在 Android 系统中，Android 是由一个叫做任务栈进行管理的；简单来说，当创建新 Activity 时，该 Activity 会压入任务栈里，此时处于前台进程，之前的 Activity 位于新 Activity 下面，直到新 Activity 被 finish 时之前的 Actiivity 才会重新回到前台进程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;Activity 应用组件，是 Android 程序与用户交互的窗口。通常来说，Activity 呈现给用户的是充满整个窗口
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第十三章 事件</title>
    <link href="http://panzeyong.com/2017/11/04/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BA%8B%E4%BB%B6/"/>
    <id>http://panzeyong.com/2017/11/04/第十三章-事件/</id>
    <published>2017-11-04T02:40:35.000Z</published>
    <updated>2017-12-05T11:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h1><p>事件流描述的是在页面上点击元素时，从页面中接收事件的顺序。对于事件流的概念有两种说发，一种是事件冒泡流（IE 团队），一种是事件捕获流（Netscape Communicator 团队）。</p>
<h3 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h3><p>IE 的 事件流叫做事件冒泡，即事件开始时由最具体的元素（元素中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。简单来说就是从下往上进行传播。以下面的 HTML 页面为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>点击元素 &lt;div&gt; 后事件冒泡的过程如下图：</p>
<p><img src="/images/javascript/event/event_bubble.png" alt=""></p>
<p>注：IE5.5 及更早版本中的事件冒泡会跳过 &lt;html&gt; 元素（从 &t;body&gt;直接跳转到 document）。IE9、Firefox、Chrome 和 Safari 则将事件一直冒泡到 window 对象。</p>
<h3 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h3><p>Netscape Communicator 的事件流叫做事件捕获，思想是不太具体的节点应该更早地接收到事件，而最具体的节点应该是最后接收到事件。仍以前面 HTML 页面为例子，点击元素 &lt;div&gt; 后事件捕获的过程如下图：</p>
<p><img src="/images/javascript/event/event_catch.png" alt=""></p>
<h3 id="3、DOM-事件流"><a href="#3、DOM-事件流" class="headerlink" title="3、DOM 事件流"></a>3、DOM 事件流</h3><p>“DOM2 级事件” 规定的事件流包括三个阶段：</p>
<ul>
<li><p>事件捕获阶段</p>
</li>
<li><p>处于目标阶段；</p>
</li>
<li><p>事件冒泡阶段。</p>
</li>
</ul>
<p>仍以上面 HTML 页面为例子，单击 &lt;div&gt; 元素事件触发顺序如下图：</p>
<p><img src="/images/javascript/event/event_stream.png" alt=""></p>
<h1 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h1><p>响应某个事件的函数就叫做事件处理程序（或事件侦听器）。</p>
<h3 id="1、HTML-事件处理程序"><a href="#1、HTML-事件处理程序" class="headerlink" title="1、HTML 事件处理程序"></a>1、HTML 事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"Click me"</span> onclick=<span class="string">"alert('Clicked')"</span> /&gt;</div></pre></td></tr></table></figure>
<p>使用这种方式缺点：</p>
<ul>
<li><p>时差问题。用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件；</p>
</li>
<li><p>这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果；</p>
</li>
<li><p>HTML 与 JavaScript 代码紧密耦合。</p>
</li>
</ul>
<h3 id="2、DOM0-级事件处理程序"><a href="#2、DOM0-级事件处理程序" class="headerlink" title="2、DOM0 级事件处理程序"></a>2、DOM0 级事件处理程序</h3><p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">"click"</span>);</div><div class="line">    click.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用这种方式的优点：</p>
<ul>
<li><p>简单；</p>
</li>
<li><p>具有跨浏览器的优势。</p>
</li>
</ul>
<h3 id="3、DOM2-级事件处理程序"><a href="#3、DOM2-级事件处理程序" class="headerlink" title="3、DOM2 级事件处理程序"></a>3、DOM2 级事件处理程序</h3><p>用于处理指定和删除事件处理程序的操作：<strong>addEventListener()</strong> 和 <strong>removeEventListener()</strong>。这两个方法都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后一个参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">"click"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">click.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div><div class="line"></div><div class="line">click.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h3 id="4、IE-事件处理程序"><a href="#4、IE-事件处理程序" class="headerlink" title="4、IE 事件处理程序"></a>4、IE 事件处理程序</h3><p>IE 实现了与 DOM 中类似的两个方法：<strong>attachEvent()</strong> 和 <strong>detachEvent()</strong>。这两个方法接受相同的两个参数：事件处理程序名称和事件处理程序函数，事件被添加到冒泡阶段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> click = <span class="built_in">document</span>.getElementById(<span class="string">"click"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">click.addachEvent(<span class="string">"onclick"</span>, handler);</div></pre></td></tr></table></figure>
<p>这两个方法的使用与 DOM0 级方法使用的区别在于事件处理程序的作用域：</p>
<ul>
<li><p>在使用 DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；</p>
</li>
<li><p>在使用 <strong>attachEvent()</strong> 方法的情况下，事件处理程序会在全局作用域中运行，此时 this 等于 window。</p>
</li>
</ul>
<h3 id="5、跨浏览器的事件处理程序"><a href="#5、跨浏览器的事件处理程序" class="headerlink" title="5、跨浏览器的事件处理程序"></a>5、跨浏览器的事件处理程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"addEventListener"</span>);</div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.addachEvent) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"addachEvent"</span>);</div><div class="line">            element.addachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> + type] + handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">	removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">			element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</div><div class="line">			element.detachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h1><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他特定事件相关信息。</p>
<h3 id="1、DOM-中的事件对象"><a href="#1、DOM-中的事件对象" class="headerlink" title="1、DOM 中的事件对象"></a>1、DOM 中的事件对象</h3><p>DOM 事件对象 event 包含着相关的属性和方法，如下表格：</p>
<table><tr style="text-align: center"><td>属性/方法</td><td>类型</td><td>读/写</td><td>说明</td></tr><tr style="text-align: center"><td>bubbles</td><td>Boolean</td><td>只读</td><td>表示事件是否冒泡</td></tr><tr style="text-align: center"><td>cancelable</td><td>Boolean</td><td>只读</td><td>表明是否可以取消事件的默认行为</td></tr><tr style="text-align: center"><td>currentTarget</td><td>Element</td><td>只读</td><td>其事件处理程序当前正在处理事件的那个元素</td></tr><tr style="text-align: center"><td>defaultPrevented</td><td>Boolean</td><td>只读</td><td>为 true 表示已经调用了 preventDefault() （DOM3 级事件中新增）</td></tr><tr style="text-align: center"><td>detail</td><td>Integer</td><td>只读</td><td>与事件相关的细节信息</td></tr><tr style="text-align: center"><td>eventPhase</td><td>Integer</td><td>只读</td><td>调用事件处理程序的阶段：1 表示捕获阶段，2 表示 “处于目标”， 3 表示冒泡阶段</td></tr><tr style="text-align: center"><td>preventDefault()</td><td>Function</td><td>只读</td><td>取消事件的默认行为。如果是 cancelable 是 true，则可以使用这个方法</td></tr><tr style="text-align: center"><td>stopImmediate<br>Propagation()</td><td>Function</td><td>只读</td><td>取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3 级事件中新增）</td></tr><tr style="text-align: center"><td>stopPropagation()</td><td>Function</td><td>只读/td&gt;</td><td>取消事件的进一步捕获或冒泡。如果 bubbles 为 true，则可以使用这个方法</td></tr><tr style="text-align: center"><td>target</td><td>Element</td><td>只读</td><td>事件的目标</td></tr><tr style="text-align: center"><td>trusted</td><td>Boolean</td><td>只读</td><td>为 true 表示事件时浏览器生产的。为 false 表示事件时由开发人员通过 JavaScript 创建的（DOM3 级事件新增）</td></tr><tr style="text-align: center"><td>type</td><td>String</td><td>只读</td><td>被触发的事件的类型</td></tr><tr style="text-align: center"><td>view</td><td>AbstractView</td><td>只读</td><td>与事件关联的抽象视图。等同于发送事件的 window 对象</td> </tr></table>

<h3 id="2、IE-中的事件对象"><a href="#2、IE-中的事件对象" class="headerlink" title="2、IE 中的事件对象"></a>2、IE 中的事件对象</h3><p>IE 的 event 对象同样也包含着与创建它的事件相关属性和方法，如下表：</p>
<table><tr><td>属性/方法</td><td>类型</td><td>读/写</td><td>说明</td></tr><tr><td>cancelBubble</td><td>Boolean</td><td>读/写</td><td>默认值为 false，但将其设置为 true 就可以取消事件冒泡（与 DOM 中的 stopPropagation() 方法的作用相同）</td></tr><tr><td>returnValue</td><td>Boolean</td><td>读/写</td><td>默认值为 true，当将其设置为 false 就可以取消事件的默认行为（与 DOM 中的 preventDefault() 方法的作用相同）</td></tr><tr><td>srcElement</td><td>Element</td><td>只读</td><td>事件的目标（与 DOM 中的 target 属性相同）</td></tr><tr><td>type</td><td>String</td><td>只读</td><td>被触发的事件类型</td></tr></table>

<h3 id="3、跨浏览器的事件对象"><a href="#3、跨浏览器的事件对象" class="headerlink" title="3、跨浏览器的事件对象"></a>3、跨浏览器的事件对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    priventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.priventDefault) &#123;</div><div class="line">            event.priventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    </div><div class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.stopPropagation) &#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="四、事件类型"><a href="#四、事件类型" class="headerlink" title="四、事件类型"></a>四、事件类型</h1><p>DOM3 级事件规定了以下几类事件：</p>
<ul>
<li><p>UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发；</p>
</li>
<li><p>焦点事件，当元素获得或失去焦点时触发；</p>
</li>
<li><p>鼠标事件，当用户通过鼠标在页面上执行操作时触发；</p>
</li>
<li><p>滚轮事件，当使用鼠标滚轮（或类似设备）时触发；</p>
</li>
<li><p>文本事件，当在文档中输入文本时触发；</p>
</li>
<li><p>键盘事件，当用户通过键盘在页面上执行操作时触发；</p>
</li>
<li><p>合成事件，当为 IME（Input Method Editor，输入法编辑器）输入字符时触发；</p>
</li>
<li><p>变动（mutation）事件，当底层 DOM 结构发生变化时触发。</p>
</li>
</ul>
<h3 id="1、UI-事件"><a href="#1、UI-事件" class="headerlink" title="1、UI 事件"></a>1、UI 事件</h3><ul>
<li><p><strong>load</strong>：当页面完全加载后在 window 上触发，当所有框架都加载完毕时在框架集上触发，当图像加载完毕时在 &lt;img&gt; 元素上面触发，或者当嵌入内容加载完毕时在 &lt;object&gt; 元素上面触发。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"> alert(<span class="string">"Loaded!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>unload</strong>：当页面完全卸载后在 window 上面触发，当所有框架都卸载后在框架集上面触发，或者当嵌入的内容卸载完毕后在 &lt;object&gt; 元素上面发。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"unload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"> alert(<span class="string">"Unloaded"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>abort</strong>：在用户停止下载过程时，如果嵌入的内容没有加载完，则在 &lt;object&gt; 元素上面触发。</p>
</li>
<li><p><strong>error</strong>：当发生 JavaScript 错误时在 window 上面触发，当无法加载图像时在 &lt;img&gt; 元素上面触发，当无法加载嵌入内容时在 &lt;object&gt; 元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。</p>
</li>
<li><p><strong>select</strong>：当用户选择文本框（&lt;input&gt; 或 &lt;texterea&gt;）中的一或多个字符时触发。</p>
</li>
<li><p><strong>resize</strong>：当窗口或框架的大小变化时在 window 或框架上面触发。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"> alert(<span class="string">"Resized"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>scroll</strong>：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。&lt;body&gt; 元素中包含所加载页面的滚动条。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123;</div><div class="line">  alert(<span class="built_in">document</span>.documentElement.scrollTop);</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">  alert(<span class="built_in">document</span>.body.scrollTop);</div><div class="line"> &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、焦点事件"><a href="#2、焦点事件" class="headerlink" title="2、焦点事件"></a>2、焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFeature() 方法及 document.activeElement 属性配合，可以知晓用户在页面上的行踪。有以下 6 个焦点事件：</p>
<ul>
<li><p><strong>blur</strong>：在元素失去焦点时触发。这个事件<strong>不会冒泡</strong>；所有浏览器都支持它。</p>
</li>
<li><p><strong>DOMFocusIn</strong>：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它<strong>冒泡</strong>。只有 <strong>Opera支持这个事件</strong>。DOM3 级事件废弃了 DOMFocusIn，选择了 focusin。</p>
</li>
<li><p><strong>DOMFocusOut</strong>：在元素失去焦点时触发。这个事件是 HTML 事件 blur 的通用版。只有 <strong>Opera支持这个事件</strong>。DOM3 级事件废弃了 DOMFocusOut，选择了 focusout。</p>
</li>
<li><p><strong>focus</strong>：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</p>
</li>
<li><p><strong>focusin</strong>：在元素获得焦点时触发。这个事件与 HTML 事件 focus 等价，但它<strong>冒泡</strong>。</p>
</li>
<li><p><strong>focusout</strong>：在元素失去焦点时触发。这个事件时 HTML 事件 blur 的通用版本。</p>
</li>
</ul>
<p>当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：</p>
<ul>
<li><p>focusout 在失去焦点的元素上触发；</p>
</li>
<li><p>focusin 在获得焦点的元素上触发；</p>
</li>
<li><p>blur 在失去焦点的元素上触发；</p>
</li>
<li><p>DOMFocusOut 在失去焦点的元素上触发；</p>
</li>
<li><p>focus 子啊获得焦点的元素上触发；</p>
</li>
<li><p>DOMFocusIn 在获得焦点的元素上触发。</p>
</li>
</ul>
<h3 id="3、鼠标与滚轮事件"><a href="#3、鼠标与滚轮事件" class="headerlink" title="3、鼠标与滚轮事件"></a>3、鼠标与滚轮事件</h3><p>DOM3 级事件中定义了 9 个鼠标事件，如下：</p>
<ul>
<li><p><strong>click</strong>：在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发。</p>
</li>
<li><p><strong>dblclick</strong>：在用户双击主鼠标按钮（一般是左边的按钮）时触发。</p>
</li>
<li><p><strong>mousedown</strong>：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</p>
</li>
<li><p><strong>mouseenter</strong>：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件<strong>不冒泡</strong>，而且在光标移动到后代元素上不会触发。</p>
</li>
<li><p><strong>mouseleave</strong>：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。</p>
</li>
<li><p><strong>mousemove</strong>：当鼠标指针在元素内部移动时重复第触发。不能通过键盘触发这个事件。</p>
</li>
<li><p><strong>mouseout</strong>：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</p>
</li>
<li><p><strong>mouseover</strong>：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。</p>
</li>
<li><p><strong>mouseup</strong>：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。</p>
</li>
</ul>
<p>事件触发顺序：</p>
<ul>
<li><p>mousedown</p>
</li>
<li><p>mouseup</p>
</li>
<li><p>click</p>
</li>
<li><p>mousedown</p>
</li>
<li><p>mouseup</p>
</li>
<li><p>click</p>
</li>
<li><p>dblclick</p>
</li>
</ul>
<p>相关细节如下：</p>
<ul>
<li><p><strong>客户区坐标位置</strong>：事件发生时鼠标指针子啊视口中的水平和垂直坐标。这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line"> event = EventUtil.getEvent(event);</div><div class="line"> alert(<span class="string">"Client coordinates: "</span> + event.clientX + <span class="string">","</span> + event.clientY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>页面坐标位置</strong>：表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。在页面没有滚动的情况下，pageX 和 pageY 的值与 clientX 和 clientY 的值相等。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(<span class="string">"Page coordinates: "</span> + event.pageX + <span class="string">","</span> + event.pageY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>屏幕坐标位置</strong>：鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(<span class="string">"Screen coordinates: "</span> + event.screenX + <span class="string">","</span> + event.screenY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>修改键</strong>：DOM 规定了 4 个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey 和 metaKey。这些属性中包含的都是布尔值，如果相应的键被按下了，则值为 true，否则值为 false。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> keys = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (event.shiftKey) &#123;</div><div class="line">        keys.push(<span class="string">"shift"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (event.ctrlKey) &#123;</div><div class="line">        keys.push(<span class="string">"ctrl"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (event.altKey) &#123;</div><div class="line">        keys.push(<span class="string">"alt"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (event.metaKey) &#123;</div><div class="line">        keys.push(<span class="string">"meta"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    alert(<span class="string">"Keys: "</span> + keys.join(<span class="string">","</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>相关元素</strong>：DOM 通过 event 对象的 relatedTarget 属性提供了相关元素信息。这个属性只对 mouseover 和 mouseout 事件才包含值；对于其它事件，这个属性的值是 null。IE8 及之前版本不支持 relatedTarget 属性，但是提供了保存着同样信息的不同属性。在 mouseover 事件触发时，IE 的 fromElement 属性中保存了相关元素；在 mouseout 事件触发时，IE 的 toElement 属性中保存着相关元素。那么跨浏览器取得相关元素的方法实现如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.relatedTarget) &#123;</div><div class="line">            <span class="keyword">return</span> event.relatedTarget;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</div><div class="line">            <span class="keyword">return</span> event.toElement;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement) &#123;</div><div class="line">            <span class="keyword">return</span> event.fromElement;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>鼠标按钮</strong>：对于 mousedown 和 mosueup 事件来说，则在其 event 对象存在一个 button 属性，表示按下或释放的按钮。DOM 的 button 属性可能有如下 3 个值：</p>
<ul>
<li><p>0 表示主鼠标按钮；（鼠标左键）</p>
</li>
<li><p>1 表示中间的鼠标按钮（鼠标滚轮按钮）；</p>
</li>
<li><p>2 表示次鼠标按钮。（鼠标右键）</p>
</li>
</ul>
<p>IE8 及之前版本也提供了 button 属性，但这个属性的值与 DOM 的 button 属性有很大差异。</p>
<ul>
<li><p>0：表示没有按下按钮。</p>
</li>
<li><p>1：表示按下了主鼠标按钮。</p>
</li>
<li><p>2：表示按下了次鼠标按钮。</p>
</li>
<li><p>3：表示同时按下主、次鼠标按钮。</p>
</li>
<li><p>4：表示按下了中间的鼠标按钮。</p>
</li>
<li><p>5：表示同时按下了主鼠标按钮和中间的鼠标按钮。</p>
</li>
<li><p>6：表示同时按下了次鼠标按钮和中间的鼠标按钮。</p>
</li>
<li><p>7：表示同时按下了三个鼠标按钮。</p>
<p> 跨浏览器鼠标按钮属性实现方法：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    getButton: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> event.button;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">switch</span>(event.button) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                </div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">                </div><div class="line">                <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>更多的事件信息</strong>：”DOM2级事件” 规范在 event 对象中还提供了 detail 属性，用于给出有关事件的更多信息。对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。</p>
</li>
<li><p><strong>鼠标滚轮事件</strong></p>
</li>
<li><p><strong>触摸设备</strong></p>
</li>
<li><p><strong>无障碍性问题</strong></p>
</li>
</ul>
<h3 id="4、键盘与文本事件"><a href="#4、键盘与文本事件" class="headerlink" title="4、键盘与文本事件"></a>4、键盘与文本事件</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、事件流&quot;&gt;&lt;a href=&quot;#一、事件流&quot; class=&quot;headerlink&quot; title=&quot;一、事件流&quot;&gt;&lt;/a&gt;一、事件流&lt;/h1&gt;&lt;p&gt;事件流描述的是在页面上点击元素时，从页面中接收事件的顺序。对于事件流的概念有两种说发，一种是事件冒泡流（IE 团队）
    
    </summary>
    
    
  </entry>
  
</feed>
