<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PANJU&#39;s Note</title>
  <subtitle>故不积跬步，无以至千里；不积小流，无以成江海。</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://panzeyong.com/"/>
  <updated>2021-01-24T10:34:17.649Z</updated>
  <id>http://panzeyong.com/</id>
  
  <author>
    <name>PANJU</name>
    <email>04120513panzeyong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人生第一次写单元测试用例</title>
    <link href="http://panzeyong.com/2021/01/24/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://panzeyong.com/2021/01/24/人生第一次写单元测试用例/</id>
    <published>2021-01-24T06:52:52.000Z</published>
    <updated>2021-01-24T10:34:17.649Z</updated>
    
    <content type="html"><![CDATA[<p>说起来也惭愧，从事开发工作到现在将近 5 年，在此之前没有写过任何一行单元测试代码。直到最近，公司在推动每个项目需要写单元测试用例，而且代码覆盖率有一定的指标，目的在于保证代码质量。于是，我成为了整个前端组第一个写单元测试用例，提前踩踩坑，积累经验。如今负责写单元测试用例的项目已完成，抽空把“人生第一次写单元测试用例”所遇到的各种问题整理成笔记，方便日后查阅。</p>
<p>项目使用的前端框架是 <code>Vue</code>，那么单元测试用例所选的框架也是围绕 <code>Vue</code> 生态来选择的。阅读 <code>Vue</code> 官网教程 <a href="https://cn.vuejs.org/v2/guidetesting.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" target="_blank" rel="external">单元测试</a> 这一小节，最后采用 <a href="https://jestjs.io/zh-Hans/" target="_blank" rel="external">Jest</a> 和 <a href="https://vue-test-utils.vuejs.org/zh/" target="_blank" rel="external">Vue Test Utils</a>。接下来会从如何安装、如何写、怎么写三方面来介绍，带你们走一遍写单元测试用例整个流程。</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>Jest 最新版本只支持 Babel 7，不支持 Babel 6，在 Jest 24 时已经移除对 Babel 6 的支持；所以项目中使用的是 Babel 6 的话，需要安装 Jest 版本 24 以下的，否则项目是运行不起来。那么接下来会介绍 Babel 6 和 Babel 7 两种环境下如何安装 Jest。</p>
<h2 id="Babel-6-环境"><a href="#Babel-6-环境" class="headerlink" title="Babel 6 环境"></a>Babel 6 环境</h2><h3 id="1、安装-Jest"><a href="#1、安装-Jest" class="headerlink" title="1、安装 Jest"></a>1、安装 Jest</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jest@<span class="number">23.6</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p>在 <code>package.json</code> 文件 <code>script</code> 标签里配置运行测试脚本，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"test:unit"</span>: <span class="string">"jest --no-cache"</span></div></pre></td></tr></table></figure>
<p>根据 <a href="https://www.manning.com/books/testing-vue-js-applications" target="_blank" rel="external">《Test Vue.js Applications》</a> 这本书的建议，如果使用的是 Windows，需要在 jest 命令后参数 <code>--no-cache</code>，避免发生潜在的错误。</p>
<p>此时在控制台执行命令：<code>npm run test:unit</code>，会看到控制台有报错信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">testMatch: **<span class="regexp">/__tests__/</span>**<span class="comment">/*.[jt]s?(x), **/</span>?(*.)+(spec|test).[tj]s?(x) - <span class="number">0</span> matches</div><div class="line">testPathIgnorePatterns: <span class="regexp">/node_modules/</span> - <span class="number">173</span> matches</div><div class="line">testRegex:  - <span class="number">0</span> matches</div><div class="line">Pattern:  - <span class="number">0</span> matches</div></pre></td></tr></table></figure>
<p>意思是没有找到任何匹配的测试文件。这是因为 Jest 框架会在整个项目中全局匹配测试文件，然后运行相应的测试用例。__tests<strong> 是 Jest 默认匹配的文件夹，文件夹里的测试文件是以 <code>.spec.js</code> 或者 <code>.test.js</code> 为后缀的。因此，我们需要在项目<strong>根目录</strong>创建文件夹 __tests</strong>，同时创建以 <code>.spec.js</code> 为后缀的文件。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sum.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = (s1, s2) =&gt; &#123;</div><div class="line">	<span class="keyword">return</span> s1 + s2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单元测试用例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// __tests__/sum.spec.js</span></div><div class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'../sum.js'</span></div><div class="line"></div><div class="line">describe(<span class="string">'sum.js'</span>, () =&gt; &#123;</div><div class="line">    test(<span class="string">'输入：1 和 2；输出：3'</span>, () =&gt; &#123;</div><div class="line">        expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/images/sum.png" alt="单元测试用例结果"></p>
<p>从输出结果可知，单元测试用例已经能正常跑起来。</p>
<p>如果想要让测试文件一旦有改动，就自动运行测试用例，那么可以在执行命令时添加参数 <code>--watch</code>，即 <code>npm run test:unit -- --watch</code>。为了不用每次执行命令时输入参数 <code>watch</code>，可以直接在 <code>package.json</code> 文件进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"test:unit"</span>: <span class="string">"jest --no-cache"</span>,</div><div class="line">	<span class="string">"test"</span>: <span class="string">"npm run test:unit -- --watch"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接执行命令 <code>npm run test</code> 就可以了。</p>
<h3 id="2、安装-Vue-Test-Units"><a href="#2、安装-Vue-Test-Units" class="headerlink" title="2、安装 Vue Test Units"></a>2、安装 Vue Test Units</h3><p>Jest 要测试 Vue 单文件组件，需要安装框架 Vue Test Unit，具体安装教程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jest @vue/test-utils</div></pre></td></tr></table></figure>
<h3 id="3、安装-vue-jest-预处理器"><a href="#3、安装-vue-jest-预处理器" class="headerlink" title="3、安装 vue-jest 预处理器"></a>3、安装 vue-jest 预处理器</h3><p>为了让 Jest 知道如何处理 <code>*.vue</code> 文件，需要安装和配置 <code>vue-jest</code> 预处理器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev vue-jest</div></pre></td></tr></table></figure>
<h3 id="4、配置-Jest"><a href="#4、配置-Jest" class="headerlink" title="4、配置 Jest"></a>4、配置 Jest</h3><p>Jest 可以单独创建配置文件，也可以在 <code>package.json</code> 文件添加 <code>jest</code> 块进行配置，这里采用的是在 <code>package.json</code> 文件进行配置，具体如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// package.json</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">        <span class="string">"moduleFileExtensions"</span>: [</div><div class="line">            <span class="string">"js"</span>,</div><div class="line">            <span class="string">"json"</span>,</div><div class="line">            <span class="comment">// 告诉 Jest 处理 `*.vue` 文件</span></div><div class="line">            <span class="string">"vue"</span></div><div class="line">        ],</div><div class="line">        <span class="string">"transform"</span>: &#123;</div><div class="line">            <span class="comment">// 用 `vue-jest` 处理 `*.vue` 文件</span></div><div class="line">            <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="comment">// 处理 webpack 别名</span></div><div class="line">        <span class="string">"moduleNameMapper"</span>: &#123;</div><div class="line">            <span class="string">"^@/(.*)$"</span>: <span class="string">"&lt;rootDir&gt;/src/$1"</span>,</div><div class="line">            <span class="comment">// 作用：引入 element-ui，处理 CSS 模块，需要安装 identity-obj-proxy 依赖</span></div><div class="line">            <span class="string">"\\.(css|less)$"</span>: <span class="string">"identity-obj-proxy"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、为-Jest-配置-Babel"><a href="#5、为-Jest-配置-Babel" class="headerlink" title="5、为 Jest 配置 Babel"></a>5、为 Jest 配置 Babel</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-jest@<span class="number">23.6</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p>然后在 <code>package.json</code> 文件 <code>jest. transform</code> 添加一个入口，来告诉 Jest 使用 <code>babel-jest</code> 处理 JavaScript 测试文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">        <span class="string">"transform"</span>: &#123;</div><div class="line">              <span class="comment">// 用 `babel-jest` 处理 js</span></div><div class="line">     		<span class="string">"^.+\\.js$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、测试覆盖率"><a href="#6、测试覆盖率" class="headerlink" title="6、测试覆盖率"></a>6、测试覆盖率</h3><p>Jest 可以配置输出测试覆盖率报告，简单的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">		<span class="comment">// 开启收集覆盖率</span></div><div class="line">		<span class="string">"collectCoverage"</span>: <span class="literal">true</span>,</div><div class="line">		<span class="comment">// 指定测试覆盖率报告输出路径</span></div><div class="line">        <span class="string">"coverageDirectory"</span>: <span class="string">"&lt;rootDir&gt;/tests/unit/coverage"</span>,</div><div class="line">        <span class="comment">// 指定测试覆盖率以什么样的方式展示</span></div><div class="line">        <span class="string">"coverageReporters"</span>: [</div><div class="line">            <span class="string">"html"</span>,</div><div class="line">            <span class="string">"text-summary"</span></div><div class="line">        ],</div><div class="line">        <span class="comment">// 指定哪些文件可以被收集；哪些文件不需要被收集</span></div><div class="line">        <span class="string">"collectCoverageFrom"</span>: [</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于更详细的配置，可参考 <a href="https://jestjs.io/docs/zh-Hans/configuration#collectcoverage-boolean" target="_blank" rel="external">Jest 配置</a></p>
<h3 id="7、Jest-测试单文件例子"><a href="#7、Jest-测试单文件例子" class="headerlink" title="7、Jest 测试单文件例子"></a>7、Jest 测试单文件例子</h3><p>先给出 <code>package.json</code> 文件对 Jest 的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">        <span class="string">"moduleFileExtensions"</span>: [</div><div class="line">            <span class="string">"js"</span>,</div><div class="line">            <span class="string">"json"</span>,</div><div class="line">            <span class="string">"vue"</span></div><div class="line">        ],</div><div class="line">        <span class="string">"transform"</span>: &#123;</div><div class="line">            <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span>,</div><div class="line">            <span class="string">"^.+\\.js$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"moduleNameMapper"</span>: &#123;</div><div class="line">            <span class="string">"^@/(.*)$"</span>: <span class="string">"&lt;rootDir&gt;/src/$1"</span>,</div><div class="line">            <span class="comment">// 作用：引入 element-ui，处理 CSS 模块，需要安装 identity-obj-proxy 依赖（npm install --save-dev identity-obj-proxy）</span></div><div class="line">            <span class="string">"\\.(css|less)$"</span>: <span class="string">"identity-obj-proxy"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"collectCoverage"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"coverageDirectory"</span>: <span class="string">"&lt;rootDir&gt;/tests/unit/coverage"</span>,</div><div class="line">        <span class="string">"coverageReporters"</span>: [</div><div class="line">            <span class="string">"html"</span>,</div><div class="line">            <span class="string">"text-summary"</span></div><div class="line">        ],</div><div class="line">        <span class="string">"collectCoverageFrom"</span>: [</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Test.vue 文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div&gt;Test.vue&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">export default &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>Test.spec.js 测试文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../Test.vue'</span></div><div class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Test)</div><div class="line">describe(<span class="string">'Test.vue'</span>, () =&gt; &#123;</div><div class="line">    test(<span class="string">'正常渲染 Test.vue 组件'</span>, () =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> wrapper = mount(Test)</div><div class="line">        expect(wrapper.find(<span class="string">'div'</span>).text()).toContain(<span class="string">'Test.vue'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Vue Test Units 提供两个方法来挂载 Vue 组件，分别是 <code>mount</code> 和 <code>shallowMount</code>。这两个方法的区别在于：<code>mount</code> 方法对整个文件进行解析，包括子组件；而 <code>shallowMount</code> 只会解析当前文件，对于当前文件所包含的子组件是不会解析的，可以根据具体的场景选用具体的方法，更详细的可参考官方文档 <a href="https://vue-test-utils.vuejs.org/zh/" target="_blank" rel="external">Vue Test Utils</a>。</p>
<h2 id="Babel-7-环境"><a href="#Babel-7-环境" class="headerlink" title="Babel 7 环境"></a>Babel 7 环境</h2><p>这里需要列出与 Babel 6 环境的不同点，其余相同。</p>
<h3 id="1、安装-Jest-1"><a href="#1、安装-Jest-1" class="headerlink" title="1、安装 Jest"></a>1、安装 Jest</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jest</div></pre></td></tr></table></figure>
<h3 id="2、为-Jest-配置-Babel"><a href="#2、为-Jest-配置-Babel" class="headerlink" title="2、为 Jest 配置 Babel"></a>2、为 Jest 配置 Babel</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core@^<span class="number">7.0</span><span class="number">.0</span>-bridge<span class="number">.0</span></div><div class="line">npm install --save-dev babel-preset-env</div><div class="line">npm isntall --save-dev babel-jest</div></pre></td></tr></table></figure>
<h1 id="二、确定范围"><a href="#二、确定范围" class="headerlink" title="二、确定范围"></a>二、确定范围</h1><p>环境搭建好了，是不是就可以开始写测试用例了？且慢，还没到这一步，需要先确定怎么测，即哪些模块需要写测试用例。下面就列出认为需要测试的要点，至于到项目层可根据具体项目的实际情况而定。</p>
<ul>
<li><p>抽离公共模块：公共函数、公共组件；</p>
</li>
<li><p>核心模块：覆盖各分支。</p>
</li>
</ul>
<h1 id="三、实战案例"><a href="#三、实战案例" class="headerlink" title="三、实战案例"></a>三、实战案例</h1><p>这一部分主要来说下怎么写测试用例，具体内容是在项目中遇到过的，后续会继续补充。</p>
<h3 id="1、公共函数测试用例"><a href="#1、公共函数测试用例" class="headerlink" title="1、公共函数测试用例"></a>1、公共函数测试用例</h3><p>测试公共函数是比较简单的，毕竟相对比较独立，很好写测试用例。</p>
<p>date.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> dateFormat = (timestamp) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timestamp * <span class="number">1000</span>)</div><div class="line">    <span class="keyword">const</span> year = date.getFullYear()</div><div class="line">    <span class="keyword">let</span> month = date.getMonth() + <span class="number">1</span></div><div class="line">    <span class="keyword">let</span> d = date.getDate()</div><div class="line"></div><div class="line">    month = month &lt; <span class="number">10</span> ? <span class="string">'0'</span> + month : month,</div><div class="line">    d = d &lt; <span class="number">10</span> ? <span class="string">'0'</span> + d : d</div><div class="line"></div><div class="line">    <span class="keyword">return</span> year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>date.spec.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;dateFormat&#125; <span class="keyword">from</span> <span class="string">'../date'</span></div><div class="line"></div><div class="line">describe(<span class="string">'dateFormat 方法'</span>, () =&gt; &#123;</div><div class="line">    test(<span class="string">'输入：时间戳为 1611471600；输出：2021-01-24'</span>, () =&gt; &#123;</div><div class="line">        expect(dateFormat(<span class="number">1611471600</span>)).toContain(<span class="string">'2021-01-24'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="2、Vue-单文件组件"><a href="#2、Vue-单文件组件" class="headerlink" title="2、Vue 单文件组件"></a>2、Vue 单文件组件</h3><p>有些组件可能依赖一个全局插件，比如 <code>element-ui</code>、<code>vue-router</code>，为了做到独立性，避免影响到其它组件，可以使用 <code>createLocalVue</code> 来存档它们，并把它们放到一个配置文件，引入即可：<code>config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createLocalVue &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> localVue = createLocalVue()</div><div class="line"></div><div class="line">localVue.use(Vuex)</div><div class="line">localVue.use(ElementUI)</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!process || process.env.NODE_ENV !== <span class="string">'test'</span>) &#123;</div><div class="line">    localVue.use(VueRouter)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    router,</div><div class="line">    localVue</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Test.vue</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;el-button type="primary" @click="click"&gt;模拟点击按钮&lt;/el-button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    name: <span class="string">'Test'</span>,</div><div class="line"></div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            count: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        click () &#123;</div><div class="line">            <span class="keyword">this</span>.count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>Test.spec.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../Test.vue'</span></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123;localVue&#125; = config</div><div class="line"></div><div class="line">describe(<span class="string">'Test.vue'</span>, () =&gt; &#123;</div><div class="line">    test(<span class="string">'模拟点击按钮'</span>, () =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> wrapper = mount(Test, &#123;</div><div class="line">            localVue</div><div class="line">        &#125;)</div><div class="line">        wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>)</div><div class="line">        expect(wrapper.vm.count).toBe(<span class="number">1</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="3、模拟-axios-发送请求"><a href="#3、模拟-axios-发送请求" class="headerlink" title="3、模拟 axios 发送请求"></a>3、模拟 axios 发送请求</h3><p>项目中难免会涉及到发送请求获取后端数据，而 Jest 测试时不可能真正发送请求去验证逻辑，那么我们可以模拟接口返回的数据，来测试我们的逻辑是否正常，具体例子如下：</p>
<p>Test.vue</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;el-button type="primary" @click="click"&gt;模拟 axios 发送请求&lt;/el-button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    name: <span class="string">'Test'</span>,</div><div class="line"></div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            list: []</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        <span class="keyword">async</span> click () &#123;</div><div class="line">            <span class="keyword">const</span> result = <span class="keyword">await</span> axios.get(<span class="string">'/list'</span>)</div><div class="line">            <span class="keyword">this</span>.list = result.data</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>Test.spec.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../Test.vue'</span></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></div><div class="line"></div><div class="line">jest.mock(<span class="string">'axios'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        get: jest.fn().mockImplementation(() =&gt; &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                data: [</div><div class="line">                    &#123;</div><div class="line">                        id: <span class="number">1</span>,</div><div class="line">                        name: <span class="string">'username'</span></div><div class="line">                    &#125;,</div><div class="line">                    &#123;</div><div class="line">                        id: <span class="number">2</span>,</div><div class="line">                        name: <span class="string">'username'</span></div><div class="line">                    &#125;</div><div class="line">                ]</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">const</span> &#123;localVue&#125; = config</div><div class="line"></div><div class="line">describe(<span class="string">'Test.vue'</span>, () =&gt; &#123;</div><div class="line">    test(<span class="string">'模拟 axios 发送请求'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> wrapper = mount(Test, &#123;</div><div class="line">            localVue</div><div class="line">        &#125;)</div><div class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>)</div><div class="line">        expect(wrapper.vm.list.length).toBe(<span class="number">2</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="测试-props"><a href="#测试-props" class="headerlink" title="测试 props"></a>测试 props</h3><p>有时我们需要以 <code>props</code> 的方式从父组件传递数据给子组件，那么我们该如何测试数据是否真的传递到呢？Vue Test Units 框架支持测试 <code>props</code>，具体例子如下：</p>
<p>Test.vue</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;el-button type="primary" @click="click"&gt;点击&lt;/el-button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    name: <span class="string">'Test'</span>,</div><div class="line"></div><div class="line">    props: &#123;</div><div class="line">        count: &#123;</div><div class="line">            type: <span class="built_in">Number</span>,</div><div class="line">            <span class="keyword">default</span>: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    data () &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            result: <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    mounted() &#123;</div><div class="line">        </div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    methods: &#123;</div><div class="line">        click () &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Click: '</span>, <span class="keyword">this</span>.count)</div><div class="line">            <span class="keyword">this</span>.result = <span class="keyword">this</span>.count * <span class="number">2</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>Test.spec.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Test <span class="keyword">from</span> <span class="string">'../Test.vue'</span></div><div class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></div><div class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123;localVue&#125; = config</div><div class="line"></div><div class="line">describe(<span class="string">'Test.vue'</span>, () =&gt; &#123;</div><div class="line"></div><div class="line">    test(<span class="string">'模拟点击按钮'</span>, <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> wrapper = mount(Test, &#123;</div><div class="line">            localVue,</div><div class="line">            propsData: &#123;</div><div class="line">                count: <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(wrapper.props().count)</div><div class="line"></div><div class="line">        <span class="keyword">await</span> wrapper.find(<span class="string">'.el-button'</span>).trigger(<span class="string">'click'</span>)</div><div class="line"></div><div class="line">        expect(wrapper.vm.result).toBe(<span class="number">2</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="5、模拟-window-属性"><a href="#5、模拟-window-属性" class="headerlink" title="5、模拟 window 属性"></a>5、模拟 window 属性</h3><p>有时难免项目中会使用到 window 属性，而 Jest 框架不支持，也就是说没有实现 window 相关属性，所以执行到对应代码时会报错的。那么我们可以通过来模拟 window 属性，以此来避免该错误。这里给出模拟 <code>window.location.reload</code> 的例子，具体如下：</p>
<p>Test.spec.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'测试 window location 中 reload 方法'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> &#123; reload &#125; = <span class="built_in">window</span>.location;</div><div class="line"></div><div class="line">  beforeAll(() =&gt; &#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>.location, <span class="string">'reload'</span>, &#123;</div><div class="line">      configurable: <span class="literal">true</span>,</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">window</span>.location.reload = jest.fn();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  afterAll(() =&gt; &#123;</div><div class="line">    <span class="built_in">window</span>.location.reload = reload;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/55712640/jest-testing-window-location-reload/55771671" target="_blank" rel="external">Jest: Testing window.location.reload
</a></p>
<h1 id="四、问题汇集"><a href="#四、问题汇集" class="headerlink" title="四、问题汇集"></a>四、问题汇集</h1><h3 id="1、Babel-6-下安装-Jest-最新版本会报错"><a href="#1、Babel-6-下安装-Jest-最新版本会报错" class="headerlink" title="1、Babel 6 下安装 Jest 最新版本会报错"></a>1、Babel 6 下安装 Jest 最新版本会报错</h3><p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jest@<span class="number">23.6</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p><a href="http://blog.magmalabs.io/2019/06/27/adding-jest-to-a-babel-6-project.html" target="_blank" rel="external">Adding Jest to a Babel 6 project</a></p>
<h3 id="2、babel-jest-版本比-jest-版本高报的错误"><a href="#2、babel-jest-版本比-jest-版本高报的错误" class="headerlink" title="2、babel-jest 版本比 jest 版本高报的错误"></a>2、babel-jest 版本比 jest 版本高报的错误</h3><p><code>TypeError: Cannot read property &#39;cwd&#39; of undefined</code></p>
<p>解决方案：版本与 jest 一样就好</p>
<h3 id="3、Handlebars-版本问题，导致测试报告无法显示"><a href="#3、Handlebars-版本问题，导致测试报告无法显示" class="headerlink" title="3、Handlebars 版本问题，导致测试报告无法显示"></a>3、<code>Handlebars</code> 版本问题，导致测试报告无法显示</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Handlebars: Access has been denied to resolve the property “<span class="keyword">from</span>” because it</div><div class="line">is not an “own property” <span class="keyword">of</span> its parent</div></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -D handlebars@<span class="number">4.5</span><span class="number">.0</span></div></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/59690923/handlebars-access-has-been-denied-to-resolve-the-property-from-because-it-is" target="_blank" rel="external">Handlebars 版本问题</a></p>
<h3 id="4、引入-element-ui-css-解析报错"><a href="#4、引入-element-ui-css-解析报错" class="headerlink" title="4、引入 element-ui css 解析报错"></a>4、引入 element-ui css 解析报错</h3><p>解决方案：</p>
<p>先安装依赖 <code>identity-obj-proxy</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev identity-obj-proxy</div></pre></td></tr></table></figure>
<p>然后在 <code>package.json</code> 文件 <code>jest.moduleNameMapper</code> 添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="string">"jest"</span>: &#123;</div><div class="line">		<span class="string">"moduleNameMapper"</span>: &#123;</div><div class="line">			<span class="string">"\\.(css|less)$"</span>: <span class="string">"identity-obj-proxy"</span></div><div class="line">    		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://hellogithub2014.github.io/2018/07/16/jest-quirks/" target="_blank" rel="external">引入 element-ui css 解析报错</a></p>
<h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><ul>
<li><p><a href="https://vue-test-utils.vuejs.org/zh/guides/#%E8%B5%B7%E6%AD%A5" target="_blank" rel="external">Vue Test Units</a></p>
</li>
<li><p><a href="https://jestjs.io/docs/zh-Hans/getting-started.html" target="_blank" rel="external">Jest</a></p>
</li>
<li><p><a href="https://lmiller1990.github.io/vue-testing-handbook/zh-CN/" target="_blank" rel="external">Vue 测试指南</a></p>
</li>
<li><p><a href="https://wangtunan.github.io/blog/test/vueTest.html#%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D" target="_blank" rel="external">Vue 应用测试</a></p>
</li>
</ul>
<p>由于水平有限，以上如有误，欢迎指出，一起交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起来也惭愧，从事开发工作到现在将近 5 年，在此之前没有写过任何一行单元测试代码。直到最近，公司在推动每个项目需要写单元测试用例，而且代码覆盖率有一定的指标，目的在于保证代码质量。于是，我成为了整个前端组第一个写单元测试用例，提前踩踩坑，积累经验。如今负责写单元测试用例的
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="单元测试" scheme="http://panzeyong.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>响应式对象一：data</title>
    <link href="http://panzeyong.com/2020/09/23/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1%E4%B8%80%EF%BC%9Adata/"/>
    <id>http://panzeyong.com/2020/09/23/响应式对象一：data/</id>
    <published>2020-09-23T15:10:46.000Z</published>
    <updated>2020-09-23T15:12:37.988Z</updated>
    
    <content type="html"><![CDATA[<p>响应式对象，简单来说，就是对象拥有 <code>setter</code> 和 <code>getter</code> 方法。也就是说，给对象属性添加 <code>set</code> 和 <code>get</code>，<code>set</code> 提供 <code>setter</code> 方法，而 <code>get</code> 提供 <code>getter</code> 方法。当访问属性触发 <code>getter</code> 方法；当修改属性时触发 <code>setter</code>。</p>
<p>Vue 将 <code>data</code>、<code>props</code> 变为响应式对象。这里先分析 Vue 是如何把 <code>data</code> 变成响应式对象的。</p>
<p>在 Vue 初始化 <code>_init</code> 的过程中，有这么一个方法：<code>initState</code> 被执行，其实现逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  vm._watchers = []</div><div class="line">  <span class="keyword">const</span> opts = vm.$options</div><div class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</div><div class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</div><div class="line">  <span class="keyword">if</span> (opts.data) &#123;</div><div class="line">    initData(vm)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</div><div class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</div><div class="line">    initWatch(vm, opts.watch)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的作用是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>watch</code> 做了一系列初始化操作。而将 <code>data</code> 变成响应式对象的实现逻辑就在 <code>initData</code> 方法里，具体来看下其实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> data = vm.$options.data</div><div class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></div><div class="line">    ? getData(data, vm)</div><div class="line">    : data || &#123;&#125;</div><div class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</div><div class="line">    data = &#123;&#125;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">'data functions should return an object:\n'</span> +</div><div class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// proxy data on instance</span></div><div class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">  <span class="keyword">const</span> props = vm.$options.props</div><div class="line">  <span class="keyword">const</span> methods = vm.$options.methods</div><div class="line">  <span class="keyword">let</span> i = keys.length</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    <span class="keyword">const</span> key = keys[i]</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</div><div class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</div><div class="line">        <span class="string">`Use prop default value instead.`</span>,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">      proxy(vm, <span class="string">`_data`</span>, key)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// observe data</span></div><div class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 <code>3</code> ~ <code>5</code> 行判断 <code>data</code> 数据类型是否为 <code>function</code>，满足的话则调用方法 <code>getData(data, vm)</code>，执行其逻辑返回对象 <code>data</code>；否则的话则返回 <code>data</code>。将其返回结果赋值给 <code>data</code> 和 <code>vm._data</code>。</p>
<p>需要注意的是组件里 <code>data</code> 是一个函数，好处是每个 Vue 组件是一个 Vue 实例，通过函数返回的 <code>data</code> 对象保证其独立性，组件之间互不影响。</p>
<p>第 <code>6</code> ~ <code>13</code> 行判断 <code>data</code> 数据类型是为对象，不是对象的话则开发环境下抛出警告。</p>
<p>第 <code>19</code> ~ <code>38</code> 行遍历 <code>data</code> 属性，检验其键名是否与 <code>methods</code> 或者 <code>props</code> 对象包含的键名相同。如果存在相同的话，则在开发环境下抛出警告。除此之外，将 <code>data</code> 对象属性代理到 Vue 实例上，即调用方法 <code>proxy(vm,</code>_data<code>, key)</code>。那么来看下是如何实现代理的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: Object, sourceKey: string, key: string</span>) </span>&#123;</div><div class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</div><div class="line">  &#125;</div><div class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>[sourceKey][key] = val</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实现逻辑很简单，先在对象 <code>sharedPropertyDefinition</code> 定义 <code>set</code> 和 <code>get</code>，然后 <code>sharedPropertyDefinition</code> 作为 <code>key</code> 属性描述符，调用方法 <code>Object.defineProperty</code> 在 Vue 实例上定义属性 <code>key</code> 以及其属性描述符。通过一个简单的例子来分析下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">	mounted() &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	data () &#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			message: <span class="string">'Hello World'</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>不知会不会有这样的疑问：为什么 <code>this.message</code> 就能访问到呢？这是因为 Vue 将 <code>data</code> 属性代理到 Vue 实例上，而此时 <code>this</code> 指向 Vue 实例，所以能访问到；而实际上真正访问到其值是通过 <code>this._data.message</code> 获取的。<code>_data</code> 是 Vue 私有属性，一般不让外部访问，通过代理到 Vue 实例来访问其值。</p>
<p>回到 <code>initData</code> 方法，<code>observe(data, true /* asRootData */)</code> 是将 <code>data</code> 变成响应式对象的核心方法。那么来看下其具体实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Attempt to create an observer instance for a value,</div><div class="line"> * returns the new observer if successfully observed,</div><div class="line"> * or the existing observer if the value already has one.</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></div><div class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</div><div class="line">    ob = value.__ob__</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</div><div class="line">    shouldObserve &amp;&amp;</div><div class="line">    !isServerRendering() &amp;&amp;</div><div class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</div><div class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</div><div class="line">    !value._isVue</div><div class="line">  ) &#123;</div><div class="line">    ob = <span class="keyword">new</span> Observer(value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</div><div class="line">    ob.vmCount++</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ob</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 <code>7</code> ~ <code>9</code> 行对 <code>value</code> 进行校验，如果其数据类型不是对象或者是 <code>VNode</code> 实例，则返回。</p>
<p><code>data</code> 在转换为响应式对象的过程中，添加属性 <code>__ob__</code>，指向 Observer 实例。因此第 <code>11</code> ~ <code>21</code> 行首先判断 <code>data</code> 是否有属性 <code>__ob__</code>，满足的话则将其赋值给 <code>ob</code>，并且返回 <code>ob</code>；否则创建 Observer 实例，并将其返回。</p>
<p>那么是如何创建 Observer 实例的呢？具体实现逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (value: any) &#123;</div><div class="line">  <span class="keyword">this</span>.value = value</div><div class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</div><div class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span></div><div class="line">  def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">    <span class="keyword">if</span> (hasProto) &#123;</div><div class="line">      protoAugment(value, arrayMethods)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      copyAugment(value, arrayMethods, arrayKeys)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.observeArray(value)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.walk(value)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对三个变量进行初始化：<code>value</code>、<code>dep</code>、<code>vmCount</code>；然后在 <code>data</code> 定义属性 <code>__ob__</code>，指向 Observer 实例；接着判断 <code>value</code> 数据类型是否为数组，是的话则进入第 <code>7</code> ~ <code>12</code>；否则执行第 <code>14</code> 行。</p>
<p>先来看下第 <code>14</code> 行，即 <code>walk</code> 的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Walk through all properties and convert them into</div><div class="line"> * getter/setters. This method should only be called when</div><div class="line"> * value type is Object.</div><div class="line"> */</div><div class="line">walk (obj: <span class="built_in">Object</span>) &#123;</div><div class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    defineReactive(obj, keys[i])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实现逻辑很简单，即遍历 <code>obj</code>，然后调用方法 <code>defineReactive</code>。那么 <code>defineReactive</code> 方法又是什么呢？其作用是在对象上定义响应式属性。来看下具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Define a reactive property on an Object.</div><div class="line"> */</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></div><div class="line">  obj: Object,</div><div class="line">  key: string,</div><div class="line">  val: any,</div><div class="line">  customSetter?: ?Function,</div><div class="line">  shallow?: boolean</div><div class="line">) &#123;</div><div class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</div><div class="line"></div><div class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</div><div class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// cater for pre-defined getter/setters</span></div><div class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</div><div class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</div><div class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">    val = obj[key]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">        dep.depend()</div><div class="line">        <span class="keyword">if</span> (childOb) &#123;</div><div class="line">          childOb.dep.depend()</div><div class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">            dependArray(value)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></div><div class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</div><div class="line">        customSetter()</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// #7981: for accessor properties without setter</span></div><div class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></div><div class="line">      <span class="keyword">if</span> (setter) &#123;</div><div class="line">        setter.call(obj, newVal)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        val = newVal</div><div class="line">      &#125;</div><div class="line">      childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">      dep.notify()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第 <code>11</code> 行创建 <code>dep</code> 实例，用于后续依赖收集。</p>
<p>第 <code>13</code> ~ <code>16</code> 行获取 <code>key</code> 的属性描述符，并且判断该属性是否可配置。</p>
<p>第 <code>21</code> ~ <code>23</code> 行在满足条件的情况下，获取 <code>key</code> 对应的值。</p>
<p>第 <code>25</code> 行作用是属性 <code>key</code> 对应的值是对象或者数组，则会递归遍历其属性，将它们设置为响应式属性。</p>
<p>第 <code>26</code> ~ <code>62</code> 行是将属性设置成响应式属性的核心逻辑，即调用方法 <code>Object.defineProperty</code> 在属性上设置 <code>set</code> 和 <code>get</code>，使其变成响应式属性，进而使拥有该属性的对象变成响应式对象。</p>
<p>当访问属性值时，则会触发 <code>reactiveGetter</code> 方法，该方法会做一些依赖收集的工作；而当为属性赋值时，则会触发 <code>reactiveSetter</code> 方法，该方法会做派发更新的工作，即通知监听它的观察者需要做更新操作。至于如何做依赖收集和派发更新，后续章节再做分析。</p>
<p>核心方法 <code>defineReactive</code> 分析完了，再回到 <code>Observer</code> 实例的创建，来看下 <code>data</code> 是数组时，又是怎么实现的呢？</p>
<p>第 <code>7</code> ~ <code>11</code> 行实际上在 <code>value</code> 定义数组方法。核心逻辑在第 <code>12</code> 行，看下其具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/**</span></div><div class="line">   * Observe a list of Array items.</div><div class="line">   */</div><div class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</div><div class="line">      observe(items[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遍历数组每个元素，调用方法 <code>observe</code> 将其转换为响应式。</p>
<p>至此，<code>data</code> 对象如何转换成响应式对象已分析完了。下面通过一张图来概述其整体流程：</p>
<p><img src="/images/vue/reactive_data.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/reactive-object.html#object-defineproperty" target="_blank" rel="external">响应式对象
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式对象，简单来说，就是对象拥有 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 方法。也就是说，给对象属性添加 &lt;code&gt;set&lt;/code&gt; 和 &lt;code&gt;get&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt; 提供 &lt;code
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>createComponent 实现原理</title>
    <link href="http://panzeyong.com/2020/09/02/createComponent-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/09/02/createComponent-实现原理/</id>
    <published>2020-09-02T15:59:17.000Z</published>
    <updated>2020-09-04T15:41:07.428Z</updated>
    
    <content type="html"><![CDATA[<p>在《render 实现原理》这一节中，有分析到 <code>createElement</code> 的实现过程，其最终调用的是 <code>_createElement</code>；而在该方法里有一段逻辑对 <code>tag</code> 的判断，如果 <code>tag</code> 类型为 <code>string</code> 时，则进入处理 <code>string</code> 类型的逻辑，前面已经分析过；否则则进入创建组件 Vnode 的逻辑，即要分析 <code>createComponent</code> 的实现过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params"></span></span></div><div class="line">    Ctor,</div><div class="line">    data,</div><div class="line">    context,</div><div class="line">    children,</div><div class="line">    tag</div><div class="line">) &#123;</div><div class="line">    <span class="keyword">if</span> (isUndef(Ctor)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> baseCtor = context.$options._base;</div><div class="line"></div><div class="line">    <span class="comment">// plain options object: turn it into a constructor</span></div><div class="line">    <span class="keyword">if</span> (isObject(Ctor)) &#123;</div><div class="line">        Ctor = baseCtor.extend(Ctor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// if at this stage it's not a constructor or an async component factory,</span></div><div class="line">    <span class="comment">// reject.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Ctor !== <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">            warn((<span class="string">"Invalid Component definition: "</span> + (<span class="built_in">String</span>(Ctor))), context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// async component</span></div><div class="line">    <span class="keyword">var</span> asyncFactory;</div><div class="line">    <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</div><div class="line">        asyncFactory = Ctor;</div><div class="line">        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</div><div class="line">        <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</div><div class="line">            <span class="comment">// return a placeholder node for async component, which is rendered</span></div><div class="line">            <span class="comment">// as a comment node but preserves all the raw information for the node.</span></div><div class="line">            <span class="comment">// the information will be used for async server-rendering and hydration.</span></div><div class="line">            <span class="keyword">return</span> createAsyncPlaceholder(</div><div class="line">                asyncFactory,</div><div class="line">                data,</div><div class="line">                context,</div><div class="line">                children,</div><div class="line">                tag</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    data = data || &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="comment">// resolve constructor options in case global mixins are applied after</span></div><div class="line">    <span class="comment">// component constructor creation</span></div><div class="line">    resolveConstructorOptions(Ctor);</div><div class="line"></div><div class="line">    <span class="comment">// transform component v-model data into props &amp; events</span></div><div class="line">    <span class="keyword">if</span> (isDef(data.model)) &#123;</div><div class="line">        transformModel(Ctor.options, data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// extract props</span></div><div class="line">    <span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag);</div><div class="line"></div><div class="line">    <span class="comment">// functional component</span></div><div class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</div><div class="line">        <span class="keyword">return</span> createFunctionalComponent(Ctor, propsData, data, context, children)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// extract listeners, since these needs to be treated as</span></div><div class="line">    <span class="comment">// child component listeners instead of DOM listeners</span></div><div class="line">    <span class="keyword">var</span> listeners = data.on;</div><div class="line">    <span class="comment">// replace with listeners with .native modifier</span></div><div class="line">    <span class="comment">// so it gets processed during parent component patch.</span></div><div class="line">    data.on = data.nativeOn;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isTrue(Ctor.options.abstract)) &#123;</div><div class="line">        <span class="comment">// abstract components do not keep anything</span></div><div class="line">        <span class="comment">// other than props &amp; listeners &amp; slot</span></div><div class="line"></div><div class="line">        <span class="comment">// work around flow</span></div><div class="line">        <span class="keyword">var</span> slot = data.slot;</div><div class="line">        data = &#123;&#125;;</div><div class="line">        <span class="keyword">if</span> (slot) &#123;</div><div class="line">            data.slot = slot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// install component management hooks onto the placeholder node</span></div><div class="line">    installComponentHooks(data);</div><div class="line"></div><div class="line">    <span class="comment">// return a placeholder vnode</span></div><div class="line">    <span class="keyword">var</span> name = Ctor.options.name || tag;</div><div class="line">    <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</div><div class="line">        (<span class="string">"vue-component-"</span> + (Ctor.cid) + (name ? (<span class="string">"-"</span> + name) : <span class="string">''</span>)),</div><div class="line">        data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,</div><div class="line">        asyncFactory</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法接收 5 个参数：</p>
<ul>
<li><p><code>Ctor</code>：表示一个组件对象；</p>
<p>  <img src="/images/vue/create_component_ctor.png" alt="init 逻辑实现"></p>
</li>
<li><p><code>data</code>：表示 vnode 数据；</p>
</li>
<li><p><code>context</code>：表示 Vue 实例；</p>
</li>
<li><p><code>children</code>：表示 vnode 子节点；</p>
</li>
<li><p><code>tag</code>：表示标签。</p>
</li>
</ul>
<p>其逻辑实现如下：</p>
<ul>
<li><p>第 <code>8</code> ~ <code>10</code> ：判断 <code>Ctor</code> 是否为 <code>null</code>。如果为 <code>null</code> 的话则返回，否则继续执行。</p>
</li>
<li><p>第 <code>12</code> ~ <code>17</code> 行：基于 Vue 构造函数<strong>构造子类构造函数</strong>。<code>baseCtor</code> 指向 Vue 构造函数，原因是在初始化 Vue 阶段时，在 <code>src/core/global-api/index.js</code> 文件有这么一段逻辑：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this is used to identify the "base" constructor to extend all plain-object</span></div><div class="line"><span class="comment">// components with in Weex's multi-instance scenarios.</span></div><div class="line">Vue.options._base = Vue</div></pre></td></tr></table></figure>
<p>可能你会发现 <code>_base</code> 是在定义在 <code>Vue.options</code>，而使用的是 <code>Vue.$options._base</code>，究竟是怎么回事呢？其实在创建 Vue 实例时调用的方法 <code>_init</code> 里，有这么一段逻辑：</p>
<p>  <code>vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);</code></p>
<p>将用户传入的 <code>options</code> 和 Vue 构造函数的 <code>options</code> 进行合并，最后将合并后的 <code>options</code> 赋值给 <code>vm.$options</code>，因此能访问到。</p>
<p>  <code>baseCtor.extend(Ctor)</code> 即 <code>Vue.extend(Ctor)</code>，构造子类构造函数。</p>
</li>
<li><p>第 <code>29</code> ~ <code>45</code> 行：异步组件处理。</p>
</li>
<li><p>第 <code>54</code> ~ <code>56</code> 行：把组件 <code>v-model</code> 转换为 <code>props</code>  和 <code>events</code>。</p>
</li>
<li><p>第 <code>59</code> 行：提取 <code>props</code>。</p>
</li>
<li><p>第 <code>61</code> ~ <code>64</code> 行：存在函数式组件的则创建函数式组件。</p>
</li>
<li><p>第 <code>68</code> 行：提取监听器，因为 <code>data.on</code> 需要被作为子组件的监听器以代替 DOM 监听器。</p>
</li>
<li><p>第 <code>71</code> 行：用 <code>.native</code> 代替监听器 <code>data.on</code>。（在父组件 patch 过程会被处理）</p>
</li>
<li><p>第 <code>73</code> ~ <code>83</code>：存在抽象组件的话则处理抽象组件。</p>
</li>
<li><p>第 <code>86</code> 行：安装组件钩子函数 <code>installComponentHooks</code>。</p>
</li>
<li><p>第 <code>90</code> ~ <code>94</code> 行：实例化组件 Vnode</p>
</li>
<li><p>返回组件 vnode。</p>
</li>
</ul>
<p>在创建组件的过程中，核心的逻辑有三步：</p>
<ul>
<li><p><strong>构造子类构造函数</strong>：<code>Ctor = baseCtor.extend(Ctor)</code>。</p>
</li>
<li><p><strong>安装组件钩子函数</strong>：<code>installComponentHooks(data)</code>。</p>
</li>
<li><p><strong>实例化组件 Vnode</strong>：<code>var vnode = new VNode( (&quot;vue-component-&quot; + (Ctor.cid) + (name ? (&quot;-&quot; + name) : &#39;&#39;)), data, undefined, undefined, undefined, context,{ Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children:children },asyncFactory);</code></p>
</li>
</ul>
<p>注意点：<strong>创建组件时 <code>children</code> 为 <code>undefined</code>。</strong></p>
<p>那么接下来对核心三个步骤进行简要分析，先来看下 <code>baseCtor.extend(Ctor)</code> 的具体实现，位于 <code>src/core/global-api/extend.js</code> 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Class inheritance</div><div class="line">   */</div><div class="line">  Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</div><div class="line">    extendOptions = extendOptions || &#123;&#125;</div><div class="line">    <span class="keyword">const</span> Super = <span class="keyword">this</span></div><div class="line">    <span class="keyword">const</span> SuperId = Super.cid</div><div class="line">    <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</div><div class="line">      <span class="keyword">return</span> cachedCtors[SuperId]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> name = extendOptions.name || Super.options.name</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; name) &#123;</div><div class="line">      validateComponentName(name)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>._init(options)</div><div class="line">    &#125;</div><div class="line">    Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</div><div class="line">    Sub.prototype.constructor = Sub</div><div class="line">    Sub.cid = cid++</div><div class="line">    Sub.options = mergeOptions(</div><div class="line">      Super.options,</div><div class="line">      extendOptions</div><div class="line">    )</div><div class="line">    Sub[<span class="string">'super'</span>] = Super</div><div class="line"></div><div class="line">    <span class="comment">// For props and computed properties, we define the proxy getters on</span></div><div class="line">    <span class="comment">// the Vue instances at extension time, on the extended prototype. This</span></div><div class="line">    <span class="comment">// avoids Object.defineProperty calls for each instance created.</span></div><div class="line">    <span class="keyword">if</span> (Sub.options.props) &#123;</div><div class="line">      initProps(Sub)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (Sub.options.computed) &#123;</div><div class="line">      initComputed(Sub)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// allow further extension/mixin/plugin usage</span></div><div class="line">    Sub.extend = Super.extend</div><div class="line">    Sub.mixin = Super.mixin</div><div class="line">    Sub.use = Super.use</div><div class="line"></div><div class="line">    <span class="comment">// create asset registers, so extended classes</span></div><div class="line">    <span class="comment">// can have their private assets too.</span></div><div class="line">    ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">      Sub[type] = Super[type]</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// enable recursive self-lookup</span></div><div class="line">    <span class="keyword">if</span> (name) &#123;</div><div class="line">      Sub.options.components[name] = Sub</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// keep a reference to the super options at extension time.</span></div><div class="line">    <span class="comment">// later at instantiation we can check if Super's options have</span></div><div class="line">    <span class="comment">// been updated.</span></div><div class="line">    Sub.superOptions = Super.options</div><div class="line">    Sub.extendOptions = extendOptions</div><div class="line">    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</div><div class="line"></div><div class="line">    <span class="comment">// cache constructor</span></div><div class="line">    cachedCtors[SuperId] = Sub</div><div class="line">    <span class="keyword">return</span> Sub</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法接收一个参数：<code>extendOptions</code>，指向 <code>export default {}</code> 即平时我们在编写 Vue 组件时导出的对象。</p>
<ul>
<li><p>第 <code>6</code> 行：<code>Super</code> 指向的是 Vue 构造函数。</p>
</li>
<li><p>第 <code>8</code> ~ <code>11</code> 行：变量 <code>cachedCtors</code> 通过 <code>SuperId</code> 来缓存组件，即同一个组件在多个地方导入，只会创建一次，其余都是直接从缓存获取。</p>
</li>
<li><p>第 <code>14</code> ~ <code>16</code> 行：在非生产环境对组件名称做校验。</p>
</li>
<li><p>第 <code>18</code> ~ <code>20</code> 行：声明 VueComponent 构造函数赋值给 <code>Sub</code>。</p>
</li>
<li><p>第 <code>21</code> ~ <code>22</code> 行：采用经典的原型继承方式把一个纯对象转换为一个继承于 Vue 的 <code>Sub</code>，并在后续对 <code>Sub</code> 进行扩展。</p>
</li>
<li><p>第 <code>24</code> ~ <code>27</code> 行：对 <code>Super</code> 构造函数自带的 <code>options</code> 和用户传进来的 <code>options</code> 进行合并，并赋值给 <code>Sub.options</code>。</p>
</li>
<li><p>第 <code>33</code> ~ <code>35</code> 行：如果存在 <code>props</code> 的话，则初始化 <code>props</code>。</p>
</li>
<li><p>第 <code>36</code> ~ <code>38</code> 行：如果存在 <code>computed</code> 的话，则初始化 <code>computed</code>。</p>
</li>
<li><p>第 <code>63</code> 行：缓存 <code>Sub</code> 构造函数。</p>
</li>
<li><p>返回 <code>Sub</code> 构造函数。</p>
</li>
</ul>
<p>接着来看下安装组件钩子函数的具体实现，即 <code>installComponentHooks</code> 方法，位于 <code>src/core/vdom/create-component.js</code> 中</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span> (<span class="params">data: VNodeData</span>) </span>&#123;</div><div class="line"> 	<span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;)</div><div class="line"> 	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</div><div class="line"> 		<span class="keyword">const</span> key = hooksToMerge[i]</div><div class="line"> 		<span class="keyword">const</span> existing = hooks[key]</div><div class="line"> 		<span class="keyword">const</span> toMerge = componentVNodeHooks[key]</div><div class="line"> 		<span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</div><div class="line"> 			hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge</div><div class="line"> 		&#125;</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看下两个变量：<code>hooksToMerge</code> 和 <code>componentVNodeHooks</code> 具体指的是什么？</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// inline hooks to be invoked on component VNodes during patch</span></div><div class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</div><div class="line">  init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;</div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      vnode.componentInstance &amp;&amp;</div><div class="line">      !vnode.componentInstance._isDestroyed &amp;&amp;</div><div class="line">      vnode.data.keepAlive</div><div class="line">    ) &#123;</div><div class="line">      <span class="comment">// kept-alive components, treat as a patch</span></div><div class="line">      <span class="keyword">const</span> mountedNode: any = vnode <span class="comment">// work around flow</span></div><div class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</div><div class="line">        vnode,</div><div class="line">        activeInstance</div><div class="line">      )</div><div class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> options = vnode.componentOptions</div><div class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</div><div class="line">    updateChildComponent(</div><div class="line">      child,</div><div class="line">      options.propsData, <span class="comment">// updated props</span></div><div class="line">      options.listeners, <span class="comment">// updated listeners</span></div><div class="line">      vnode, <span class="comment">// new parent vnode</span></div><div class="line">      options.children <span class="comment">// new children</span></div><div class="line">    )</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  insert (vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</div><div class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</div><div class="line">      componentInstance._isMounted = <span class="literal">true</span></div><div class="line">      callHook(componentInstance, <span class="string">'mounted'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</div><div class="line">      <span class="keyword">if</span> (context._isMounted) &#123;</div><div class="line">        <span class="comment">// vue-router#1212</span></div><div class="line">        <span class="comment">// During updates, a kept-alive component's child components may</span></div><div class="line">        <span class="comment">// change, so directly walking the tree here may call activated hooks</span></div><div class="line">        <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></div><div class="line">        <span class="comment">// be processed after the whole patch process ended.</span></div><div class="line">        queueActivatedComponent(componentInstance)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        activateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  destroy (vnode: MountedComponentVNode) &#123;</div><div class="line">    <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</div><div class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</div><div class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</div><div class="line">        componentInstance.$destroy()</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> hooksToMerge = <span class="built_in">Object</span>.keys(componentVNodeHooks)</div></pre></td></tr></table></figure>
<p><code>componentVNodeHooks</code> 是一个对象，定义了四个钩子函数：<code>init</code>、<code>prepatch</code>、<code>insert</code>、<code>destroy</code>；而 <code>hooksToMerge</code> 是一个数组，数组元素是这 4 个钩子函数。</p>
<p>回到 <code>installComponentHooks</code> 方法，其逻辑是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code>，然后在 VNode 执行 <code>patch</code> 过程中会执行相应的钩子函数。需要注意下合并策略，如果 <code>data.hook</code> 已经存在相应的钩子函数，则调用 <code>mergeHook</code> 函数进行合并。</p>
<p>最后通过一一张流程图简单地概括下其主线逻辑：</p>
<p><img src="/images/vue/create_component.png" alt="init 逻辑实现"></p>
<p>以上对组件创建的过程做了简要分析，随着不断地学习以及更进一步地加深理解，会继承完善。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/components/create-component.html#%E6%9E%84%E9%80%A0%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" target="_blank" rel="external">createComponent</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《render 实现原理》这一节中，有分析到 &lt;code&gt;createElement&lt;/code&gt; 的实现过程，其最终调用的是 &lt;code&gt;_createElement&lt;/code&gt;；而在该方法里有一段逻辑对 &lt;code&gt;tag&lt;/code&gt; 的判断，如果 &lt;code&gt;t
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>普通节点 patch 过程</title>
    <link href="http://panzeyong.com/2020/08/30/%E6%99%AE%E9%80%9A%E8%8A%82%E7%82%B9-patch%20%E8%BF%87%E7%A8%8B/"/>
    <id>http://panzeyong.com/2020/08/30/普通节点-patch 过程/</id>
    <published>2020-08-30T09:44:17.000Z</published>
    <updated>2020-10-16T14:28:25.062Z</updated>
    
    <content type="html"><![CDATA[<p>在 <strong>《Vue 实例挂载实现原理》</strong> 这一节中分析了 Vue 实例挂载实现逻辑中，得知有这么一行核心代码：<code>vm._update(vm._render(), hydrating)</code>。上一节 <strong>《render 实现原理》</strong> 中对 <code>vm._render</code> 进行了分析；那么这一节将要分析 <code>vm._update</code> 的实现原理。</p>
<p><code>_update</code> 是 Vue 实例的一个私有方法，有两个时机被调用：<strong>一个是首次渲染；一个是数据更新时触发调用。（响应式原理分析涉及）</strong>作用的是将 <code>render</code> 渲染生成的 VNode 转换为真实的 DOM 节点。</p>
<p>那么该方法是定义在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="keyword">const</span> prevEl = vm.$el</div><div class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</div><div class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</div><div class="line">  vm._vnode = vnode</div><div class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></div><div class="line">  <span class="comment">// based on the rendering backend used.</span></div><div class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">    <span class="comment">// initial render</span></div><div class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// updates</span></div><div class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">  &#125;</div><div class="line">  restoreActiveInstance()</div><div class="line">  <span class="comment">// update __vue__ reference</span></div><div class="line">  <span class="keyword">if</span> (prevEl) &#123;</div><div class="line">    prevEl.__vue__ = <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (vm.$el) &#123;</div><div class="line">    vm.$el.__vue__ = vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</div><div class="line">    vm.$parent.$el = vm.$el</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></div><div class="line">  <span class="comment">// updated in a parent's updated hook.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面结合例子来分析<strong>首次渲染</strong>调用时的实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    render: h =&gt; h(<span class="string">'div'</span>, &#123;</div><div class="line">        attrs: &#123;</div><div class="line">            id: <span class="string">'content'</span></div><div class="line">        &#125;</div><div class="line">    &#125;, [</div><div class="line">        h(<span class="string">'h1'</span>, <span class="string">'我是标题1'</span>),</div><div class="line">        h(<span class="string">'h2'</span>, <span class="string">'我是标题2'</span>)</div><div class="line">    ]),</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure>
<ul>
<li><p>第 <code>3</code> 行将在 <code>mountComponent</code> 方法获取到 <code>vm.$el</code> 赋值给变量 <code>prevEl</code>，它是一个真实的 DOM 节点，即 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>；</p>
</li>
<li><p>第 <code>4</code> 行 <code>vm._vnode</code> 为 <code>null</code>，赋值给变量 <code>prevVnode</code>；</p>
</li>
<li><p>由于 <code>prevVnode</code> 为 <code>null</code>，逻辑进入到第 <code>11</code> 行代码，也是该方法的核心逻辑实现。</p>
</li>
</ul>
<p>接下来重点来分析 <code>vm.__patch__</code> 的实现，该方法定义在 <code>src/platform/web/runtime/index.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</div></pre></td></tr></table></figure>
<p>这个方法实际上在不同的平台，其定义是不一样的。上面是在 Web 平台的定义；Weex 平台的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.__patch__ = patch</div></pre></td></tr></table></figure>
<p>在 Web 平台中，是否是服务端渲染对其也产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 渲染环境，不需要将 VNode 转换成真实 DOM，调用的是空函数；而在浏览器环境中，有真实的 DOM 渲染环境，需要将 VNode 转换成真实的 DOM，指向方法 <code>patch</code>。</p>
<p>方法 <code>patch</code> 定义在 <code>`src/platform/web/runtime/patch.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</div></pre></td></tr></table></figure>
<p>调用 <code>createPatchFunction</code> 方法，传入一个对象，包含两个参数：<code>nodeOps</code> 封装了一系列操作 DOM 的方法；<code>modules</code> 定义了一些模块（<code>attrs</code>、<code>style</code>、<code>class</code>、<code>event</code>、<code>transition</code>）钩子函数的实现，此处不展开分析。</p>
<p>那么再来看 <code>createPatchFunction</code> 是如何实现的？该方法定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> i, j</div><div class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</div><div class="line">    cbs[hooks[i]] = []</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</div><div class="line">      <span class="keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;</div><div class="line">        cbs[hooks[i]].push(modules[j][hooks[i]])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ......（此处省略定义一系列辅助方法的实现）</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</div><div class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></div><div class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</div><div class="line">      <span class="comment">// empty mount (likely as component), create new root element</span></div><div class="line">      isInitialPatch = <span class="literal">true</span></div><div class="line">      createElm(vnode, insertedVnodeQueue)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</div><div class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</div><div class="line">        <span class="comment">// patch existing root node</span></div><div class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (isRealElement) &#123;</div><div class="line">          <span class="comment">// mounting to a real element</span></div><div class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></div><div class="line">          <span class="comment">// a successful hydration.</span></div><div class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</div><div class="line">            oldVnode.removeAttribute(SSR_ATTR)</div><div class="line">            hydrating = <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</div><div class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</div><div class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</div><div class="line">              <span class="keyword">return</span> oldVnode</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">              warn(</div><div class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</div><div class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</div><div class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</div><div class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</div><div class="line">                <span class="string">'full client-side render.'</span></div><div class="line">              )</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></div><div class="line">          <span class="comment">// create an empty node and replace it</span></div><div class="line">          oldVnode = emptyNodeAt(oldVnode)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// replacing existing element</span></div><div class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</div><div class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</div><div class="line"></div><div class="line">        <span class="comment">// create new node</span></div><div class="line">        createElm(</div><div class="line">          vnode,</div><div class="line">          insertedVnodeQueue,</div><div class="line">          <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></div><div class="line">          <span class="comment">// leaving transition. Only happens when combining transition +</span></div><div class="line">          <span class="comment">// keep-alive + HOCs. (#4590)</span></div><div class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</div><div class="line">          nodeOps.nextSibling(oldElm)</div><div class="line">        )</div><div class="line"></div><div class="line">        <span class="comment">// update parent placeholder node element, recursively</span></div><div class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</div><div class="line">          <span class="keyword">let</span> ancestor = vnode.parent</div><div class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</div><div class="line">          <span class="keyword">while</span> (ancestor) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</div><div class="line">              cbs.destroy[i](ancestor)</div><div class="line">            &#125;</div><div class="line">            ancestor.elm = vnode.elm</div><div class="line">            <span class="keyword">if</span> (patchable) &#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</div><div class="line">                cbs.create[i](emptyNode, ancestor)</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// #6513</span></div><div class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></div><div class="line">              <span class="comment">// e.g. for directives that uses the "inserted" hook.</span></div><div class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</div><div class="line">              <span class="keyword">if</span> (insert.merged) &#123;</div><div class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</div><div class="line">                  insert.fns[i]()</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              registerRef(ancestor)</div><div class="line">            &#125;</div><div class="line">            ancestor = ancestor.parent</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// destroy old node</span></div><div class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</div><div class="line">          removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</div><div class="line">          invokeDestroyHook(oldVnode)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</div><div class="line">    <span class="keyword">return</span> vnode.elm</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>第 <code>7</code> ~ <code>14</code> 行循环遍历 <code>hooks</code>，其定义如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> hooks = [<span class="string">'create'</span>, <span class="string">'activate'</span>, <span class="string">'update'</span>, <span class="string">'remove'</span>, <span class="string">'destroy'</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<p> 和 <code>modules</code>，用遍历 <code>cbs</code> 来保存每个 <code>hook</code> 对应的钩子函数；</p>
<ul>
<li><p>省略一系列辅助方法；</p>
</li>
<li><p>返回函数 <code>patch</code>，也就是说，调用 <code>vm.__patch__</code> 方法时，其实调用的是 <code>patch</code> 方法。</p>
</li>
</ul>
<p><code>patch</code> 方法接收 4 个参数：</p>
<ul>
<li><p><code>oldVnode</code>：表示旧的 Vnode，它可以是一个 DOM 对象，也可以是不存在的；</p>
</li>
<li><p><code>vnode</code>：表示执行 <code>vm._render</code> 返回的 VNode 节点；</p>
</li>
<li><p><code>hydrating</code>：表示是否服务端渲染；</p>
</li>
<li><p><code>removeOnly</code>：表示给 <code>transition-group</code> 使用的。</p>
</li>
</ul>
<p>结合上面给出的例子来分析 <code>patch</code> 的实现：</p>
<ul>
<li><p>第 <code>19</code> ~ <code>22</code> 行代码中，由于传入的参数是 <code>vnode</code> 是上一步 <code>vm._render</code> 渲染生成的 vnode，不为 <code>null</code>，此逻辑跳过；</p>
<p>  <img src="/images/vue/param_vnode.png" alt=""></p>
</li>
<li><p>传入参数 <code>oldVnode</code> 是一个真实的 DOM 节点，即 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，没有进入到第 <code>27</code> ~ <code>30</code> 行代码，而是进入到 <code>else</code> 里面的逻辑了；</p>
<p>  <img src="/images/vue/param_old_vnode.png" alt=""></p>
</li>
<li><p>由于 <code>oldVnode</code> 是真实 DOM 节点，<code>isRealElement</code> 为 <code>true</code>，因此逻辑进入到第 <code>37</code> ~ <code>115</code> 里。其中有几处比较关键的代码实现：</p>
<ul>
<li><p>通过方法 <code>emptyNodeAt</code> 把 <code>oldVnode</code> 转换成虚拟 VNode，即</p>
<p><code>oldVnode = emptyNodeAt(oldVnode)</code></p>
</li>
<li><p>声明变量保存值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// replacing existing element</span></div><div class="line"><span class="keyword">const</span> oldElm = oldVnode.elm  <span class="comment">// 保存真实 DOM 节点 div#app</span></div><div class="line"><span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)（保存当前节的父节点，此处指的是 body）</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>第 <code>69</code> ~ <code>77</code> 调用方法 <code>createElm</code> 创建新节点，此方法是核心方法，稍后分析；</p>
</li>
<li><p>第 <code>110</code> ~ <code>112</code> 行由于创建了新节点，需要将旧节点删除。</p>
<p>   <img src="/images/vue/create_vnode.png" alt=""></p>
</li>
</ul>
<p>接着再来看核心方法 <code>createElm</code> 的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></div><div class="line">    vnode,</div><div class="line">    insertedVnodeQueue,</div><div class="line">    parentElm,</div><div class="line">    refElm,</div><div class="line">    nested,</div><div class="line">    ownerArray,</div><div class="line">    index</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</div><div class="line">      <span class="comment">// This vnode was used in a previous render!</span></div><div class="line">      <span class="comment">// now it's used as a new node, overwriting its elm would cause</span></div><div class="line">      <span class="comment">// potential patch errors down the road when it's used as an insertion</span></div><div class="line">      <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></div><div class="line">      <span class="comment">// associated DOM element for it.</span></div><div class="line">      vnode = ownerArray[index] = cloneVNode(vnode)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vnode.isRootInsert = !nested <span class="comment">// for transition enter check</span></div><div class="line">    <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> data = vnode.data</div><div class="line">    <span class="keyword">const</span> children = vnode.children</div><div class="line">    <span class="keyword">const</span> tag = vnode.tag</div><div class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</div><div class="line">          creatingElmInVPre++</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isUnknownElement(vnode, creatingElmInVPre)) &#123;</div><div class="line">          warn(</div><div class="line">            <span class="string">'Unknown custom element: &lt;'</span> + tag + <span class="string">'&gt; - did you '</span> +</div><div class="line">            <span class="string">'register the component correctly? For recursive components, '</span> +</div><div class="line">            <span class="string">'make sure to provide the "name" option.'</span>,</div><div class="line">            vnode.context</div><div class="line">          )</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      vnode.elm = vnode.ns</div><div class="line">        ? nodeOps.createElementNS(vnode.ns, tag)</div><div class="line">        : nodeOps.createElement(tag, vnode)</div><div class="line">      setScope(vnode)</div><div class="line"></div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> (__WEEX__) &#123;</div><div class="line">        <span class="comment">// in Weex, the default insertion order is parent-first.</span></div><div class="line">        <span class="comment">// List items can be optimized to use children-first insertion</span></div><div class="line">        <span class="comment">// with append="tree".</span></div><div class="line">        <span class="keyword">const</span> appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</div><div class="line">        <span class="keyword">if</span> (!appendAsTree) &#123;</div><div class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">          &#125;</div><div class="line">          insert(parentElm, vnode.elm, refElm)</div><div class="line">        &#125;</div><div class="line">        createChildren(vnode, children, insertedVnodeQueue)</div><div class="line">        <span class="keyword">if</span> (appendAsTree) &#123;</div><div class="line">          <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">            invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">          &#125;</div><div class="line">          insert(parentElm, vnode.elm, refElm)</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        createChildren(vnode, children, insertedVnodeQueue)</div><div class="line">        <span class="keyword">if</span> (isDef(data)) &#123;</div><div class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</div><div class="line">        &#125;</div><div class="line">        insert(parentElm, vnode.elm, refElm)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</div><div class="line">        creatingElmInVPre--</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</div><div class="line">      vnode.elm = nodeOps.createComment(vnode.text)</div><div class="line">      insert(parentElm, vnode.elm, refElm)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      vnode.elm = nodeOps.createTextNode(vnode.text)</div><div class="line">      insert(parentElm, vnode.elm, refElm)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>该方法接收 7 个参数：</p>
<ul>
<li><p><code>vnode</code>：表示执行 <code>vm._render</code> 返回的 VNode 节点；</p>
</li>
<li><p><code>insertedVnodeQueue</code>：用来保存 vnode 已经转换为真实 DOM 的 vnode 队列；</p>
</li>
<li><p><code>parentElm</code>：表示父节点；</p>
</li>
<li><p><code>refElm</code>：表示参考节点；</p>
</li>
</ul>
<p><strong>作用是把虚拟节点 VNode 转换为真实的 DOM 节点，并且插入它的父节点。</strong></p>
<p>简单分析其逻辑实现：</p>
<ul>
<li><p>第 <code>10</code> ~ <code>17</code> 行，不满足条件判断，跳过此处逻辑；</p>
</li>
<li><p>第 <code>20</code> 行尝试创建子组件，此处返回  <code>false</code>；</p>
</li>
<li><p>接着判断 vnode 是否包含 <code>tag</code> 标签，此 case 中，<code>tag</code> 为 <code>div</code>，因此满足条件，进入到逻辑里面，对其在开发环境做合法性校验，然后再调用平台 DOM 的操作去创建一个占位符元素，即 第 <code>42</code> ~ <code>45</code>；</p>
</li>
<li><p>第 <code>48</code> ~ <code>65</code> 是对 <code>weex</code> 平台的逻辑处理，暂时忽略；</p>
</li>
<li><p>接着进入到第 <code>67</code> ~ <code>71</code> 行的实现逻辑里，调用方法 <code>createChildren</code>，具体实现如下：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      checkDuplicateKeys(children)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</div><div class="line">      createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i)</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(vnode.text)) &#123;</div><div class="line">    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(<span class="built_in">String</span>(vnode.text)))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的作用遍历子虚拟节点，递归调用方法 <code>createElm</code> 创建真实 DOM，采用的是深度优先遍历的算法。</p>
<p>接着调用 <code>invokeCreateHooks</code> 方法执行所有的 <code>create</code> 的钩子函数并把 <code>vnode</code> push 到 <code>insertedVnodeQueue</code> 中。</p>
<p>最后调用方法 <code>insert</code> <strong>将真实 DOM 插入到父节点中，由于是递归调用，子节点会优先于父节点 <code>insert</code></strong>，所以整个 <code>vnode</code> 树的插入顺序是<strong>先子后父</strong>。 看下方法 <code>insert</code> 的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isDef(parent)) &#123;</div><div class="line">     <span class="keyword">if</span> (isDef(ref)) &#123;</div><div class="line">       <span class="keyword">if</span> (nodeOps.parentNode(ref) === parent) &#123;</div><div class="line">         nodeOps.insertBefore(parent, elm, ref)</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       nodeOps.appendChild(parent, elm)</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>该方法的实现逻辑挺简单，即在满足判断条件时，调用 <code>nodeOps</code> 的辅助方法将子节点插入到父节点中，我们来看下这些辅助方法是如何定义的，位于 <code>src/platform/web/runtime/node-ops.js</code> 中</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parentNode</span> (<span class="params">node: Node</span>): ?<span class="title">Node</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> node.parentNode</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</div><div class="line">	parentNode.insertBefore(newNode, referenceNode)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</div><div class="line">	node.appendChild(child)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p> 从源码实现可以看出，创建真实 DOM 的过程中，其实调用的是原生 DOM 的 API 来操作的。</p>
<ul>
<li>除了 vnode 包含 <code>tag</code> 外，vnode 还可以是注释节点或者文本节点，如果是这两者之一，则直接创建注释节点或者文本节点，并插入到其父节点中，即 第 <code>77</code> ~ <code>83</code>。</li>
</ul>
<p>那么至此简单分析了 <code>update</code> 的实现过程，下面再通过一张流程图简单地描述其主线：</p>
<p><img src="/images/vue/update.png" alt=""></p>
<p>那么至此把数据和模板如何渲染成最终 DOM 的过程分析完了，借助 <a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" target="_blank" rel="external">update</a> 里提供的图片更直观地来描述从初始化 Vue 到整个渲染完成的过程：</p>
<p><img src="/images/vue/init_to_render.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" target="_blank" rel="external">update</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;strong&gt;《Vue 实例挂载实现原理》&lt;/strong&gt; 这一节中分析了 Vue 实例挂载实现逻辑中，得知有这么一行核心代码：&lt;code&gt;vm._update(vm._render(), hydrating)&lt;/code&gt;。上一节 &lt;strong&gt;《render 
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>render 实现原理</title>
    <link href="http://panzeyong.com/2020/08/30/render-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/08/30/render-实现原理/</id>
    <published>2020-08-30T07:27:26.000Z</published>
    <updated>2020-09-23T15:35:17.108Z</updated>
    
    <content type="html"><![CDATA[<p>在 <strong><a href="http://panzeyong.com/2020/08/23/Vue-%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">《Vue 实例挂载实现原理》</a></strong> 这一节中分析了 Vue 实例挂载实现逻辑中，得知有这么一行核心代码：<code>vm._update(vm._render(), hydrating)</code>。那么这篇文章要分析的方法：<code>vm._render()</code>，如何把实例渲染成一个虚拟 Node。该方法的实现在 <code>src/code/instance/render.js</code> 文件里，源码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">   <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">   <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (_parentVnode) &#123;</div><div class="line">     vm.$scopedSlots = normalizeScopedSlots(</div><div class="line">       _parentVnode.data.scopedSlots,</div><div class="line">       vm.$slots,</div><div class="line">       vm.$scopedSlots</div><div class="line">     )</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// set parent vnode. this allows render functions to have access</span></div><div class="line">   <span class="comment">// to the data on the placeholder node.</span></div><div class="line">   vm.$vnode = _parentVnode</div><div class="line">   <span class="comment">// render self</span></div><div class="line">   <span class="keyword">let</span> vnode</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     <span class="comment">// There's no need to maintain a stack because all render fns are called</span></div><div class="line">     <span class="comment">// separately from one another. Nested component's render fns are called</span></div><div class="line">     <span class="comment">// when parent component is patched.</span></div><div class="line">     currentRenderingInstance = vm</div><div class="line">     vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">     handleError(e, vm, <span class="string">`render`</span>)</div><div class="line">     <span class="comment">// return error render result,</span></div><div class="line">     <span class="comment">// or previous vnode to prevent render error causing blank component</span></div><div class="line">     <span class="comment">/* istanbul ignore else */</span></div><div class="line">     <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; vm.$options.renderError) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">         vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</div><div class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">         handleError(e, vm, <span class="string">`renderError`</span>)</div><div class="line">         vnode = vm._vnode</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       vnode = vm._vnode</div><div class="line">     &#125;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">     currentRenderingInstance = <span class="literal">null</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// if the returned array contains only a single node, allow it</span></div><div class="line">   <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</div><div class="line">     vnode = vnode[<span class="number">0</span>]</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// return empty vnode in case the render function errored out</span></div><div class="line">   <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</div><div class="line">     <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</div><div class="line">       warn(</div><div class="line">         <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</div><div class="line">         <span class="string">'should return a single root node.'</span>,</div><div class="line">         vm</div><div class="line">       )</div><div class="line">     &#125;</div><div class="line">     vnode = createEmptyVNode()</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// set parent</span></div><div class="line">   vnode.parent = _parentVnode</div><div class="line">   <span class="keyword">return</span> vnode</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>简述下逻辑实现：</p>
<ul>
<li><p>第 <code>3</code> 行从 <code>vm.$options</code> 获取 <code>render</code> 函数；</p>
</li>
<li><p>第 <code>5</code> ~ <code>11</code> 行在 <code>_parentVnode</code> 不为空的情况下，对 <code>$scopedSlot</code> 做规范化处理；</p>
</li>
<li><p>第 <code>23</code> 行是核心处理逻辑，把实例渲染成虚拟 Node；</p>
</li>
<li><p>第 <code>25</code> ~ <code>38</code> 对创建 Node 抛出异常时做处理；</p>
</li>
<li><p>返回 vnode。</p>
</li>
</ul>
<p>该方法的实现逻辑中，第 <code>23</code> 行代码，即 <code>vnode = render.call(vm._renderProxy, vm.$createElement)</code> 是核心代码，调用 <code>render</code> 方法，把实例渲染成虚拟 Node。该方法接收两个参数：<code>vm._renderProxy</code> 在生产环境指代的是 vm 实例；<code>vm.$createElement</code> 是创建虚拟 Node 的方法。那么方法 <code>vm.$createElement</code> 又是如何实现的呢？</p>
<p><code>vm.$createElement</code> 方法在初始化 Vue 时已经定义，即在该方法 <code>initRender</code> 里已经定义了具体实现，从中可以创建有两个版本：</p>
<p><code>vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)</code>：系统内部将 <code>template</code> 编译成 <code>render</code> 函数时使用；</p>
<p><code>vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)</code>：用户手动编写 <code>render</code> 函数时使用。</p>
<p>两个版本最终都调用同一个方法：<code>createElement</code>，传递的参数也一样。</p>
<p><code>createElement</code> 的具体实现逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></div><div class="line">  context: Component,</div><div class="line">  tag: any,</div><div class="line">  data: any,</div><div class="line">  children: any,</div><div class="line">  normalizationType: any,</div><div class="line">  alwaysNormalize: boolean</div><div class="line">): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</div><div class="line">    normalizationType = children</div><div class="line">    children = data</div><div class="line">    data = <span class="literal">undefined</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</div><div class="line">    normalizationType = ALWAYS_NORMALIZE</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>第 <code>9</code> ~ 第 <code>13</code> 行代码作用是在要创建 vnode 的 data 属性满足条件的情况下，参数补齐处理；（需要更深入理解）</p>
</li>
<li><p>第 <code>17</code> 行是真正创建虚拟 Node 的方法。</p>
</li>
</ul>
<p>那么接下来看 <code>_createElement</code> 方法的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></div><div class="line">  context: Component,</div><div class="line">  tag?: string | Class&lt;Component&gt; | Function | Object,</div><div class="line">  data?: VNodeData,</div><div class="line">  children?: any,</div><div class="line">  normalizationType?: number</div><div class="line">): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;JSON.stringify(data)&#125;</span>\n`</span> +</div><div class="line">      <span class="string">'Always create fresh vnode data objects in each render!'</span>,</div><div class="line">      context</div><div class="line">    )</div><div class="line">    <span class="keyword">return</span> createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// object syntax in v-bind</span></div><div class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</div><div class="line">    tag = data.is</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!tag) &#123;</div><div class="line">    <span class="comment">// in case of component :is set to falsy value</span></div><div class="line">    <span class="keyword">return</span> createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// warn against non-primitive key</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">'@binding'</span> <span class="keyword">in</span> data.key)) &#123;</div><div class="line">      warn(</div><div class="line">        <span class="string">'Avoid using non-primitive value as key, '</span> +</div><div class="line">        <span class="string">'use string/number value instead.'</span>,</div><div class="line">        context</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// support single function children as default scoped slot</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</div><div class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">'function'</span></div><div class="line">  ) &#123;</div><div class="line">    data = data || &#123;&#125;</div><div class="line">    data.scopedSlots = &#123; <span class="keyword">default</span>: children[<span class="number">0</span>] &#125;</div><div class="line">    children.length = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</div><div class="line">    children = normalizeChildren(children)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</div><div class="line">    children = simpleNormalizeChildren(children)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> vnode, ns</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="keyword">let</span> Ctor</div><div class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</div><div class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</div><div class="line">      <span class="comment">// platform built-in elements</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">`The .native modifier for v-on is only valid on components but it was used on &lt;<span class="subst">$&#123;tag&#125;</span>&gt;.`</span>,</div><div class="line">          context</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">      vnode = <span class="keyword">new</span> VNode(</div><div class="line">        config.parsePlatformTagName(tag), data, children,</div><div class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</div><div class="line">      )</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</div><div class="line">      <span class="comment">// component</span></div><div class="line">      vnode = createComponent(Ctor, data, context, children, tag)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></div><div class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></div><div class="line">      <span class="comment">// parent normalizes children</span></div><div class="line">      vnode = <span class="keyword">new</span> VNode(</div><div class="line">        tag, data, children,</div><div class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// direct component options / constructor</span></div><div class="line">    vnode = createComponent(tag, data, context, children)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</div><div class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</div><div class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</div><div class="line">    <span class="keyword">return</span> vnode</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> createEmptyVNode()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法接收 6 参数：</p>
<ul>
<li><p><code>context</code>：VNode 的上下文环境，类型是 <code>Component</code>；</p>
</li>
<li><p><code>tag</code>：表示标签，可以是任意类型；</p>
</li>
<li><p><code>data</code>：表示 VNode 数据，它是一个 <code>VNodeData</code> 类型；</p>
</li>
<li><p><code>children</code>：表示当前 VNode 的子节点，它是任意类型，接下来需要被规范为标准的 VNode 数组；</p>
</li>
<li><p><code>normalizationType</code>：表示子节点规范的类型，类型不同调用的规范方法也不同；</p>
</li>
<li><p><code>alwaysNormalize</code>：规范化类型标志位，<code>true</code> 对应的是 <code>ALWAYS_NORMALIZE</code>；<code>false</code> 对应的是 <code>SIMPLE_NORMALIZE</code>。</p>
</li>
</ul>
<p>简述方法逻辑实现：</p>
<ul>
<li><p>第 <code>8</code> ~ <code>13</code> 行检验 VNode 的 <code>data</code> 属性是否是响应性，如果是响应式的话，则抛出警告（<strong>避免把 VNode 的 <code>data</code> 属性设置成响应式，否则始终会在每次渲染时创建新的 Vnode 数据对象。</strong>），并且创建注释节点返回；</p>
</li>
<li><p>第 <code>17</code> ~ <code>19</code> 行判断 Vnode 中 <code>data</code> 属性是否包含 <code>v-bind:is</code>，如果是的话则将其赋值给 <code>tag</code>。其作用是用于动态组件，传递已注册组件名称或者组件的选项对象；</p>
</li>
<li><p>第 <code>25</code> ~ <code>35</code> 行说明设置 <code>key</code> 时，数据类型为 <code>number</code> 或者 <code>string</code>；</p>
</li>
<li><p>第 <code>44</code> ~ <code>48</code> 行是核心代码，主要对子节点进行规范化，类型为 VNode，根据 <code>normalizationType</code> 值的不同调用不同的方法；（稍后分析）</p>
</li>
<li><p>第 <code>50</code> ~ <code>80</code> 行根据 <code>tag</code> 类型的不同调用不同的处理逻辑创建虚拟 Node。如果 <code>tag</code> 类型是 <code>string</code>，则接着判断如果是内置的一些节点，则直接创建普通的 VNode；如果是为已注册的组件名，则通过 <strong>createComponent</strong> 创建一个组件类型的 VNode，否则创建一个未知的标签的 VNode。如果 <code>tag</code> 是一个 <code>Component</code> 类型，则直接调用 <code>createComponent</code> 创建一个组件类型的 VNode。</p>
</li>
<li><p>返回创建的虚拟节点 node。</p>
</li>
</ul>
<p>那么来看下 <code>simpleNormalizeChildren</code> 方法和 <code>normalizeChildren</code> 方法的具体实现逻辑，位于 <code>src/code/vdom/helper/normalize-children.js</code> 文件中。</p>
<p><code>simpleNormalizeChildren</code> 这个方法实现比较简单，先看其实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children: any</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> children</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数的使用场景是 <code>render</code> 函数由编译生成的，理论上编译生成的 <code>children</code> 应该是 <code>VNode</code> 类型。但是有个例外，就是<strong>函数式组件</strong>返回的是数组，而不是单个节点，需要调用方法 <code>Array.prototype.concat</code> 将整个 <code>children</code> 数组打平，使其深度只有一层。</p>
<p><code>normalizeChildren</code> 方法的实现逻辑稍微复杂些，来看其具体实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span> (<span class="params">children: any</span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">return</span> isPrimitive(children)</div><div class="line">    ? [createTextVNode(children)]</div><div class="line">    : <span class="built_in">Array</span>.isArray(children)</div><div class="line">      ? normalizeArrayChildren(children)</div><div class="line">      : <span class="literal">undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的使用场景有两种：</p>
<ul>
<li><p><code>render</code> 函数是用户手写的，当  <code>children</code> 只有一个节点的时候，Vue.js 从接口层面允许用户把 <code>children</code> 写出基础类型用来创建简单的文本节点，此时调用方法 <code>createTextVNode(children)</code> 方法创建一个文本节点的 <code>VNode</code>；</p>
</li>
<li><p>当编译 <code>&lt;template&gt;</code>、<code>&lt;slot&gt;</code>、<code>v-for</code> 时会产生嵌套数组，此时会调用方法 <code>normalizeArrayChildren(children)</code> 来创建节点。</p>
</li>
</ul>
<p>看下 <code>normalizeArrayChildren(children)</code> 的具体实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeArrayChildren</span> (<span class="params">children: any, nestedIndex?: string</span>): <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">const</span> res = []</div><div class="line">  <span class="keyword">let</span> i, c, lastIndex, last</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</div><div class="line">    c = children[i]</div><div class="line">    <span class="keyword">if</span> (isUndef(c) || <span class="keyword">typeof</span> c === <span class="string">'boolean'</span>) <span class="keyword">continue</span></div><div class="line">    lastIndex = res.length - <span class="number">1</span></div><div class="line">    last = res[lastIndex]</div><div class="line">    <span class="comment">//  nested</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(c)) &#123;</div><div class="line">      <span class="keyword">if</span> (c.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        c = normalizeArrayChildren(c, <span class="string">`<span class="subst">$&#123;nestedIndex || ''&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span>)</div><div class="line">        <span class="comment">// merge adjacent text nodes</span></div><div class="line">        <span class="keyword">if</span> (isTextNode(c[<span class="number">0</span>]) &amp;&amp; isTextNode(last)) &#123;</div><div class="line">          res[lastIndex] = createTextVNode(last.text + (c[<span class="number">0</span>]: any).text)</div><div class="line">          c.shift()</div><div class="line">        &#125;</div><div class="line">        res.push.apply(res, c)</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(c)) &#123;</div><div class="line">      <span class="keyword">if</span> (isTextNode(last)) &#123;</div><div class="line">        <span class="comment">// merge adjacent text nodes</span></div><div class="line">        <span class="comment">// this is necessary for SSR hydration because text nodes are</span></div><div class="line">        <span class="comment">// essentially merged when rendered to HTML strings</span></div><div class="line">        res[lastIndex] = createTextVNode(last.text + c)</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">''</span>) &#123;</div><div class="line">        <span class="comment">// convert primitive to vnode</span></div><div class="line">        res.push(createTextVNode(c))</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (isTextNode(c) &amp;&amp; isTextNode(last)) &#123;</div><div class="line">        <span class="comment">// merge adjacent text nodes</span></div><div class="line">        res[lastIndex] = createTextVNode(last.text + c.text)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// default key for nested array children (likely generated by v-for)</span></div><div class="line">        <span class="keyword">if</span> (isTrue(children._isVList) &amp;&amp;</div><div class="line">          isDef(c.tag) &amp;&amp;</div><div class="line">          isUndef(c.key) &amp;&amp;</div><div class="line">          isDef(nestedIndex)) &#123;</div><div class="line">          c.key = <span class="string">`__vlist<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></div><div class="line">        &#125;</div><div class="line">        res.push(c)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的核心逻辑是遍历 <code>children</code>，获取节点 <code>c</code>，然后判断 <code>c</code> 的类型。如果 <code>c</code> 的类型是数组，则递归调用 <code>normalizeArrayChildren</code> 方法；如果 <code>c</code> 的类型是基础类型，则调用 <code>createTextVNode</code> 方法转换成 VNode 类型；如果 <code>children</code> 是一个列表并且列表还存在嵌套的情况下，则需要根据 <code>nestedIndex</code> 更新 <code>key</code>。</p>
<p>在遍历的过程中，有 3 种情况需要注意下：第 <code>14</code> ~ <code>17</code> 行、第 <code>20</code> ~ <code>25</code> 行和第 <code>31</code> ~ <code>33</code> 行，对于连续的两个 <code>text</code> 节点，则将其合并成一个 <code>text</code> 节点，算是一种优化。</p>
<p>最后返回规范化后 VNode 类型的数组。</p>
<p>下面通过一张流程图来简单描述其逻辑实现：</p>
<p><img src="/images/vue/render.png" alt="init 逻辑实现"></p>
<p>至此，我们对 <code>render</code> 的实现原理进行分析。由于能力有限，对其理解存在一定偏差，欢迎指正。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/render.html" target="_blank" rel="external">render</a></p>
</li>
<li><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html" target="_blank" rel="external">createElement</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;strong&gt;&lt;a href=&quot;http://panzeyong.com/2020/08/23/Vue-%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&quot;&gt;《Vue 实例
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue 实例挂载实现原理</title>
    <link href="http://panzeyong.com/2020/08/23/Vue-%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/08/23/Vue-实例挂载实现原理/</id>
    <published>2020-08-23T10:13:07.000Z</published>
    <updated>2020-10-16T14:32:39.116Z</updated>
    
    <content type="html"><![CDATA[<p>沿着上一节 <strong><a href="http://panzeyong.com/2020/08/22/new-Vue-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">《new Vue 实现原理》</a></strong> 继续分析，在初始化方法 <code>Vue.prototype._init</code> 实现逻辑里最后有一行代码：<code>vm.$mount(vm.$options.el)</code>，Vue 实例挂载的实现，接下来的核心就是来分析该方法的实现逻辑。</p>
<p>调用 <code>vm.$mount()</code> 方法时，实际上去调用 Vue 原型上 <code>$mount</code> 方法，即 <code>Vue.prototype.$mount()</code>。由于 Vue 提供两个版本：<code>Runtime Only</code> 和 <code>Runtime + Compiler</code>，使用不同的版本时，该方法的入口文件是不一样的。<code>Runtime Only</code> 版本调用的是在 <code>&#39;./runtime/index&#39;</code> 文件里定义的方法；而 <code>Runtime + Compiler</code> 版本调用的是在 <code>&#39;entry-runtime-with-compiler.js&#39;</code> 文件里定义的方法。而此次分析源码是基于 <code>Runtime + Compiler</code> 版本，因此接下来的核心是分析该文件里定义 <code>Vue.prototype.$mount</code> 的实现逻辑。</p>
<p>先从源码入手，来看看具体实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line">  el?: string | Element,</div><div class="line">  hydrating?: boolean</div><div class="line">): <span class="title">Component</span> &#123;</div><div class="line">  el = el &amp;&amp; query(el)</div><div class="line"></div><div class="line">  <span class="comment">/* istanbul ignore if */</span></div><div class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></div><div class="line">    )</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">  <span class="comment">// resolve template/el and convert to render function</span></div><div class="line">  <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">    <span class="keyword">let</span> template = options.template</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</div><div class="line">          template = idToTemplate(template)</div><div class="line">          <span class="comment">/* istanbul ignore if */</span></div><div class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</div><div class="line">              <span class="keyword">this</span></div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</div><div class="line">        template = template.innerHTML</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</div><div class="line">      template = getOuterHTML(el)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</div><div class="line">        mark(<span class="string">'compile'</span>)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</div><div class="line">        shouldDecodeNewlines,</div><div class="line">        shouldDecodeNewlinesForHref,</div><div class="line">        delimiters: options.delimiters,</div><div class="line">        comments: options.comments</div><div class="line">      &#125;, <span class="keyword">this</span>)</div><div class="line">      options.render = render</div><div class="line">      options.staticRenderFns = staticRenderFns</div><div class="line"></div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</div><div class="line">        mark(<span class="string">'compile end'</span>)</div><div class="line">        measure(<span class="string">`vue <span class="subst">$&#123;this._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在定义 <code>Vue.prototype.$mount</code> 之前，先将在 <code>./runtime/index</code> 文件里面定义的 <code>Vue.prototype.$mount</code> 缓存起来，保存在变量 <code>mount</code>，后面会用到。下面对 <code>Vue.prototype.$mount</code> 的实现逻辑简单介绍：</p>
<ul>
<li><p>获取 <code>el</code> 元素；</p>
</li>
<li><p>Vue 挂载元素 <code>el</code> 不能为 <code>document.body</code> 和 <code>document.documentElement</code>，因为挂载元素 <code>el</code> 会将其覆盖；如果是的话则会发出警告。</p>
</li>
<li><p>判断创建 Vue 实例时传入的参数是否有 <code>render</code> 函数，即 <code>vm.options.render</code> 是否为 <code>true</code>，是的话直接跳过；否则通过实现逻辑将 <code>templete</code> 或者 <code>el</code> 解析为 <code>render</code> 函数（编译环节，后续再分析）。</p>
<ul>
<li><p>判断实例化 Vue 时传入的参数 <code>options</code> 是否有 <code>template</code> 属性；如果有的话，则继续走下面逻辑：</p>
<ul>
<li><p>判断 <code>template</code> 数据类型是否为 <code>string</code>，是的话并且第一个字符为 <code>#</code> 时，则调用函数 <code>idToTemplate(template)</code> 获取模板，即 <code>template = idToTemplate(template)</code>；</p>
</li>
<li><p>判断 <code>template.nodeType</code> 是否为 <code>true</code>，是的话则调用 <code>template.innerHTML</code> 获取模板，即 <code>template = template.innerHTML</code>；</p>
</li>
<li><p>如果都不满足的话，则发出警告。</p>
</li>
</ul>
</li>
<li><p>判断 <code>el</code> 是否为 <code>true</code>，是的话则调用 <code>getOuterHTML(el)</code> 函数获取模板，即 <code>template = getOuterHTML(el)</code>。</p>
</li>
<li><p>如果通过以上的操作可以获取到 <code>template</code> 时，则通过调用 <code>compileToFunctions</code> 函数将 <code>template</code> 解析为 <code>render</code> 函数，这里涉及到编译操作，后面再分析。</p>
</li>
</ul>
</li>
</ul>
<p>最后一步是调用方法 <code>mount.call(this, el, hydrating)</code>，即是这里 <code>const mount = Vue.prototype.$mount</code> 缓存的方法。也就是说，<code>Runtime + Compiler</code> 版本最后还是得调用 <code>&#39;./runtime/index&#39;</code> 里的方法。那么接下来看看其源码实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// public mount method</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></div><div class="line">    el ? : string | Element,</div><div class="line">    hydrating ? : boolean</div><div class="line">): <span class="title">Component</span> &#123;</div><div class="line">    <span class="keyword">debugger</span>;</div><div class="line">    el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></div><div class="line">    <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码实现逻辑挺简单的，核心代码就一行：<code>mountComponent(this, el, hydrating)</code>，该方法是在 <code>&#39;core/instance/lifecycle&#39;</code> 定义的，我们来探探究竟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></div><div class="line">  vm: Component,</div><div class="line">  el: ?Element,</div><div class="line">  hydrating?: boolean</div><div class="line">): <span class="title">Component</span> &#123;</div><div class="line">  vm.$el = el</div><div class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</div><div class="line">    vm.$options.render = createEmptyVNode</div><div class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">      <span class="comment">/* istanbul ignore if */</span></div><div class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</div><div class="line">        vm.$options.el || el) &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</div><div class="line">          <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</div><div class="line">          <span class="string">'render functions, or use the compiler-included build.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        warn(</div><div class="line">          <span class="string">'Failed to mount component: template or render function not defined.'</span>,</div><div class="line">          vm</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</div><div class="line"></div><div class="line">  <span class="keyword">let</span> updateComponent</div><div class="line">  <span class="comment">/* istanbul ignore if */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</div><div class="line">    updateComponent = () =&gt; &#123;</div><div class="line">      <span class="keyword">const</span> name = vm._name</div><div class="line">      <span class="keyword">const</span> id = vm._uid</div><div class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></div><div class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></div><div class="line"></div><div class="line">      mark(startTag)</div><div class="line">      <span class="keyword">const</span> vnode = vm._render()</div><div class="line">      mark(endTag)</div><div class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</div><div class="line"></div><div class="line">      mark(startTag)</div><div class="line">      vm._update(vnode, hydrating)</div><div class="line">      mark(endTag)</div><div class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    updateComponent = () =&gt; &#123;</div><div class="line">      vm._update(vm._render(), hydrating)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// we set this to vm._watcher inside the watcher's constructor</span></div><div class="line">  <span class="comment">// since the watcher's initial patch may call $forceUpdate (e.g. inside child</span></div><div class="line">  <span class="comment">// component's mounted hook), which relies on vm._watcher being already defined</span></div><div class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</div><div class="line">    before () &#123;</div><div class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</div><div class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</div><div class="line">  hydrating = <span class="literal">false</span></div><div class="line"></div><div class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></div><div class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</div><div class="line">    vm._isMounted = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'mounted'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> vm</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的实现逻辑也不是很复杂，下面简单列出主要的实现步骤：</p>
<p>将 <code>el</code> 赋值给 <code>vm.$el</code>：<code>vm.$el = el</code>；</p>
<p>判断实例化 Vue 时传入的参数 <code>options</code> 是否 <code>render</code> 函数，通过前面的源码分析可知，此处是有 <code>render</code> 函数的；如果没有的话，则会调用 <code>createEmptyVNode</code> 方法创建一个空的 <code>vnode</code> 并且赋值给 <code>vm.$options.render</code>，即 <code>vm.$options.render = createEmptyVNode</code>；</p>
<p>调用 Vue 生命周期函数：<code>beforeMount</code>，即 <code>callHook(vm, &#39;beforeMount&#39;)</code>；</p>
<p>定义函数 <code>updateComponent</code>，调用了 <code>vm</code> 实例上两个核心方法：<code>vm._render()</code> 和 <code>vm._update</code>。（后续再分析）</p>
<p>创建 <code>render watcher</code> 实例，传入 5 个参数，具体含义如下：</p>
<ul>
<li><p><code>vm</code>：Vue 实例；</p>
</li>
<li><p><code>updateComponent</code>：前面定义的函数；</p>
</li>
<li><p><code>noop</code>：回调函数；</p>
</li>
<li><p><code>options</code>：传入一个对象；</p>
</li>
<li><p><code>isRenderWatcher</code>：表示是否为 <code>render watcher</code>，此处是为 <code>true</code>。因为 Vue 提供多种 <code>watcher</code>，不同的 <code>watcher</code> 具有不同的职责。</p>
</li>
</ul>
<p>下面来看看 <code>Watcher</code> 构造函数的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (</div><div class="line">   vm: Component,</div><div class="line">   expOrFn: string | Function,</div><div class="line">   cb: Function,</div><div class="line">   options?: ?Object,</div><div class="line">   isRenderWatcher?: boolean</div><div class="line"> ) &#123;</div><div class="line">   <span class="keyword">this</span>.vm = vm</div><div class="line">   <span class="keyword">if</span> (isRenderWatcher) &#123;</div><div class="line">     vm._watcher = <span class="keyword">this</span></div><div class="line">   &#125;</div><div class="line">   vm._watchers.push(<span class="keyword">this</span>)</div><div class="line">   <span class="comment">// options</span></div><div class="line">   <span class="keyword">if</span> (options) &#123;</div><div class="line">     <span class="keyword">this</span>.deep = !!options.deep</div><div class="line">     <span class="keyword">this</span>.user = !!options.user</div><div class="line">     <span class="keyword">this</span>.lazy = !!options.lazy</div><div class="line">     <span class="keyword">this</span>.sync = !!options.sync</div><div class="line">     <span class="keyword">this</span>.before = options.before</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.cb = cb</div><div class="line">   <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for  batching</span></div><div class="line">   <span class="keyword">this</span>.active = <span class="literal">true</span></div><div class="line">   <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></div><div class="line">   <span class="keyword">this</span>.deps = []</div><div class="line">   <span class="keyword">this</span>.newDeps = []</div><div class="line">   <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">   <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">   <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></div><div class="line">     ? expOrFn.toString()</div><div class="line">     : <span class="string">''</span></div><div class="line">   <span class="comment">// parse expression for getter</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</div><div class="line">     <span class="keyword">this</span>.getter = expOrFn</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="keyword">this</span>.getter = parsePath(expOrFn)</div><div class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</div><div class="line">       <span class="keyword">this</span>.getter = noop</div><div class="line">       process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">         <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</div><div class="line">         <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</div><div class="line">         <span class="string">'For full control, use a function instead.'</span>,</div><div class="line">         vm</div><div class="line">       )</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看下第 <code>9 ~ 11</code> 行，由于 <code>isRenderWatcher</code> 为 <code>true</code>，将 <code>Watcher</code> 实例赋值给 <code>vm._watcher</code>，即 <code>vm._watcher = this</code>；第 <code>35 ~ 37</code> 行，由于传入实参 <code>updateComponent</code> 数据类型为 <code>function</code>，则会执行该逻辑，即 <code>this.getter = expOrFn</code>；第 <code>49</code> 行，由于 <code>this.lazy</code> 为 <code>false</code>，则最终会调用 <code>this.get()</code> 方法。而该方法的具体实现逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">get () &#123;</div><div class="line">	pushTarget(<span class="keyword">this</span>)</div><div class="line">	<span class="keyword">let</span> value</div><div class="line">	<span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		value = <span class="keyword">this</span>.getter.call(vm, vm)</div><div class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</div><div class="line">			handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;this.expression&#125;</span>"`</span>)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">throw</span> e</div><div class="line">	&#125;</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="comment">// "touch" every property so they are all tracked as</span></div><div class="line">		<span class="comment">// dependencies for deep watching</span></div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</div><div class="line">			traverse(value)</div><div class="line">		&#125;</div><div class="line">		popTarget()</div><div class="line">		<span class="keyword">this</span>.cleanupDeps()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心代码在第 <code>6</code> 行，即 <code>value = this.getter.call(vm, vm)</code>，实际上调用的是之前定义的函数：<code>updateComponent</code>。至于该方法的其它逻辑，后面响应式会详细分析。</p>
<blockquote>
<pre><code>`watcher` 在这里起到两个作用：一个是初始化时候回执行回调函数；另一个是当 `vm` 实例中监测的数据发生变化时，也会执行回调函数。
</code></pre></blockquote>
<p>最后判断为根节点，即 <code>vm.$vnode == null</code> 成立时，则设置 <code>vm._isMounted</code> 为 <code>true</code>，表示实例已经挂载完成，并且执行 Vue 生命周期函数：<code>mounted</code>。</p>
<p>以上从主线分析了 Vue 实例挂载的实现逻辑，至于其它细节，比如编译、响应式等得到后面章节再分析。最后通过一张流程图来概括其主线逻辑：</p>
<p><img src="/images/vue/vue_mount.png" alt="init 逻辑实现"></p>
<p>参考链接：</p>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/mounted.html#%E6%80%BB%E7%BB%93" target="_blank" rel="external">Vue 实例挂载的实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;沿着上一节 &lt;strong&gt;&lt;a href=&quot;http://panzeyong.com/2020/08/22/new-Vue-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&quot;&gt;《new Vue 实现原理》&lt;/a&gt;&lt;/strong&gt; 继续分析，在初
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>new Vue 实现原理</title>
    <link href="http://panzeyong.com/2020/08/22/new-Vue-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://panzeyong.com/2020/08/22/new-Vue-实现原理/</id>
    <published>2020-08-22T15:23:29.000Z</published>
    <updated>2020-09-23T15:26:21.292Z</updated>
    
    <content type="html"><![CDATA[<p>不知大家有没有好奇过：<code>new Vue()</code> 背后究竟做了什么操作？这一节我们就来探个究竟。</p>
<p>当我们执行 <code>new Vue()</code> 代码创建 <code>Vue</code> 实例时，其背后做了很多初始化工作，源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</div><div class="line">  ) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>核心逻辑在于调用 <code>this._init(options)</code> 方法，接下来我们看下该方法的实现逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="comment">// a uid</span></div><div class="line">  vm._uid = uid++</div><div class="line"></div><div class="line">  <span class="keyword">let</span> startTag, endTag</div><div class="line">  <span class="comment">/* istanbul ignore if */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</div><div class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></div><div class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></div><div class="line">    mark(startTag)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// a flag to avoid this being observed</span></div><div class="line">  vm._isVue = <span class="literal">true</span></div><div class="line">  <span class="comment">// merge options</span></div><div class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</div><div class="line">    <span class="comment">// optimize internal component instantiation</span></div><div class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></div><div class="line">    <span class="comment">// internal component options needs special treatment.</span></div><div class="line">    initInternalComponent(vm, options)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm.$options = mergeOptions(</div><div class="line">      resolveConstructorOptions(vm.constructor),</div><div class="line">      options || &#123;&#125;,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* istanbul ignore else */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    initProxy(vm)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm._renderProxy = vm</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// expose real self</span></div><div class="line">  vm._self = vm</div><div class="line">  initLifecycle(vm)</div><div class="line">  initEvents(vm)</div><div class="line">  initRender(vm)</div><div class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></div><div class="line">  initState(vm)</div><div class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></div><div class="line">  callHook(vm, <span class="string">'created'</span>)</div><div class="line"></div><div class="line">  <span class="comment">/* istanbul ignore if */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</div><div class="line">    vm._name = formatComponentName(vm, <span class="literal">false</span>)</div><div class="line">    mark(endTag)</div><div class="line">    measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">    vm.$mount(vm.$options.el)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法是在执行 <code>import Vue from Vue</code> 代码就已经定义好，从源码中可以很清晰地看出该方法具体的实现逻辑，下面通过流程图来描述该方法的实现逻辑：</p>
<p><img src="/images/vue/new_vue.png" alt="init 逻辑实现"></p>
<p>在该方法的实现中，做了很多初始化操作，比如：<code>lifecycle</code>、<code>events</code>、<code>inject</code>、<code>data</code>、<code>props</code>、<code>watch</code>、<code>methods</code>、<code>computed</code>、<code>provide</code> 等一系列初始化操作，至于初始化背后的逻辑，后续会一一分析。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/new-vue.html" target="_blank" rel="external">new Vue 发生了什么
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知大家有没有好奇过：&lt;code&gt;new Vue()&lt;/code&gt; 背后究竟做了什么操作？这一节我们就来探个究竟。&lt;/p&gt;
&lt;p&gt;当我们执行 &lt;code&gt;new Vue()&lt;/code&gt; 代码创建 &lt;code&gt;Vue&lt;/code&gt; 实例时，其背后做了很多初始化工作，源码如下
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>源码构建流程</title>
    <link href="http://panzeyong.com/2020/08/18/%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://panzeyong.com/2020/08/18/源码构建流程/</id>
    <published>2020-08-18T13:17:26.000Z</published>
    <updated>2020-09-23T15:22:47.486Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 源码是基于 <a href="https://github.com/rollup/rollup" target="_blank" rel="external">Rollup</a> 构建的。</p>
<p>当我们在终端执行命令：<code>npm run build</code> 时，会去加载 <code>package.json</code> 文件，执行字段 <code>script</code> 对应的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scripts: &#123;</div><div class="line">	<span class="string">"build"</span>: <span class="string">"node scripts/build.js"</span>,</div><div class="line">    <span class="string">"build:ssr"</span>: <span class="string">"npm run build -- web-runtime-cjs,web-server-renderer"</span>,</div><div class="line">    <span class="string">"build:weex"</span>: <span class="string">"npm run build -- weex"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即执行命令：<code>&quot;build&quot;: &quot;node scripts/build.js&quot;</code>。也就是说，构建时执行的文件是：<code>scripts/build.js</code>。</p>
<p>##一、 <code>scripts/build.js</code> 逻辑分析</p>
<h3 id="1、引入依赖及文件夹创建"><a href="#1、引入依赖及文件夹创建" class="headerlink" title="1、引入依赖及文件夹创建"></a>1、引入依赖及文件夹创建</h3><p>引入相关依赖，并且判断文件夹 <code>dist</code> 是否存在；如果不存在的话，则创建该文件夹。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!fs.existsSync(<span class="string">'dist'</span>)) &#123;</div><div class="line">    fs.mkdirSync(<span class="string">'dist'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、获取构建不同版本-vue-配置"><a href="#2、获取构建不同版本-vue-配置" class="headerlink" title="2、获取构建不同版本 vue 配置"></a>2、获取构建不同版本 vue 配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> builds = <span class="built_in">require</span>(<span class="string">'./config'</span>).getAllBuilds()</div></pre></td></tr></table></figure>
<p>备注：下面再来分析如何获取配置</p>
<h3 id="3、根据命令行参数过滤配置"><a href="#3、根据命令行参数过滤配置" class="headerlink" title="3、根据命令行参数过滤配置"></a>3、根据命令行参数过滤配置</h3><p>获取所有构建配置 <code>builds</code>，根据命令行参数过滤不需要的构建配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// filter builds via command line arg（只需要命令行参数的配置）</span></div><div class="line"><span class="keyword">if</span> (process.argv[<span class="number">2</span>]) &#123;</div><div class="line">    <span class="keyword">const</span> filters = process.argv[<span class="number">2</span>].split(<span class="string">','</span>)</div><div class="line">    builds = builds.filter(b =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> filters.some(f =&gt; b.output.file.indexOf(f) &gt; <span class="number">-1</span> || b._name.indexOf(f) &gt; <span class="number">-1</span>)</div><div class="line">    &#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// filter out weex builds by default（默认过滤 weex 版本）</span></div><div class="line">    builds = builds.filter(b =&gt; &#123;</div><div class="line">        <span class="keyword">return</span> b.output.file.indexOf(<span class="string">'weex'</span>) === <span class="number">-1</span></div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、调用-rollup-rollup-方法构建，并且输出构建产物"><a href="#4、调用-rollup-rollup-方法构建，并且输出构建产物" class="headerlink" title="4、调用 rollup.rollup 方法构建，并且输出构建产物"></a>4、调用 <code>rollup.rollup</code> 方法构建，并且输出构建产物</h3><p>构建流程如下：</p>
<ul>
<li><p><code>build</code> 方法：通过计数器 <code>built</code> 循环调用 <code>buildEntry</code> 方法进行构建。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">builds</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> built = <span class="number">0</span></div><div class="line">    <span class="keyword">const</span> total = builds.length</div><div class="line">    <span class="keyword">const</span> next = () =&gt; &#123;</div><div class="line">        buildEntry(builds[built]).then(() =&gt; &#123;</div><div class="line">            built++</div><div class="line">            <span class="keyword">if</span> (built &lt; total) &#123;</div><div class="line">                next()</div><div class="line">            &#125;</div><div class="line">        &#125;).catch(logError)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    next()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>buildEntry</code> 方法：调用方法 <code>rollup.rollup</code> 打包构建，并且输出构建产物。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">buildEntry</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> output = config.output</div><div class="line">    <span class="keyword">const</span> &#123; file, banner &#125; = output</div><div class="line">    <span class="keyword">const</span> isProd = <span class="regexp">/(min|prod)\.js$/</span>.test(file)</div><div class="line">    <span class="keyword">return</span> rollup.rollup(config)</div><div class="line">        .then(bundle =&gt; bundle.generate(output))</div><div class="line">        .then((&#123; output: [&#123; code &#125;] &#125;) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (isProd) &#123;</div><div class="line">                <span class="keyword">const</span> minified = (banner ? banner + <span class="string">'\n'</span> : <span class="string">''</span>) + terser.minify(code, &#123;</div><div class="line">                    toplevel: <span class="literal">true</span>,</div><div class="line">                    output: &#123;</div><div class="line">                        ascii_only: <span class="literal">true</span></div><div class="line">                    &#125;,</div><div class="line">                    compress: &#123;</div><div class="line">                        pure_funcs: [<span class="string">'makeMap'</span>]</div><div class="line">                    &#125;</div><div class="line">                &#125;).code</div><div class="line">                <span class="keyword">return</span> write(file, minified, <span class="literal">true</span>)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> write(file, code)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、-scripts-config-js-逻辑分析"><a href="#二、-scripts-config-js-逻辑分析" class="headerlink" title="二、 scripts/config.js 逻辑分析"></a>二、 <code>scripts/config.js</code> 逻辑分析</h2><p><code>config.js</code> 文件的作用是根据 <code>rollup</code> 的规范重新组合配置，得到 <code>Vue</code> 构建的所有版本。</p>
<h3 id="1、声明构建-Vue-所有版本常量-builds。"><a href="#1、声明构建-Vue-所有版本常量-builds。" class="headerlink" title="1、声明构建 Vue 所有版本常量 builds。"></a>1、声明构建 <code>Vue</code> 所有版本常量 <code>builds</code>。</h3><p>举例说明如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span></div><div class="line"><span class="string">'web-runtime-cjs-dev'</span>: &#123;</div><div class="line">    entry: resolve(<span class="string">'web/entry-runtime.js'</span>),</div><div class="line">    dest: resolve(<span class="string">'dist/vue.runtime.common.dev.js'</span>),</div><div class="line">    format: <span class="string">'cjs'</span>,</div><div class="line">    env: <span class="string">'development'</span>,</div><div class="line">    banner</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><code>entry</code>：表示构建的入口 <code>JS</code> 文件地址。</p>
<p><code>dest</code>：表示构建后的 <code>JS</code> 文件地址。</p>
<p><code>format</code>：表示构建出来的文件遵循 <code>CommonJS</code> 格式。</p>
<p><code>env</code>：指定构建环境。</p>
<p><code>banner</code>：构建说明。</p>
<h3 id="2、根据-rollup-规范生成配置（genConfig）"><a href="#2、根据-rollup-规范生成配置（genConfig）" class="headerlink" title="2、根据 rollup 规范生成配置（genConfig）"></a>2、根据 <code>rollup</code> 规范生成配置（genConfig）</h3><h3 id="3、导出配置"><a href="#3、导出配置" class="headerlink" title="3、导出配置"></a>3、导出配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (process.env.TARGET) &#123;</div><div class="line">    <span class="built_in">module</span>.exports = genConfig(process.env.TARGET)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    exports.getBuild = genConfig</div><div class="line">    exports.getAllBuilds = () =&gt; <span class="built_in">Object</span>.keys(builds).map(genConfig)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/build.html" target="_blank" rel="external">Vue.js 源码构建
</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 源码是基于 &lt;a href=&quot;https://github.com/rollup/rollup&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rollup&lt;/a&gt; 构建的。&lt;/p&gt;
&lt;p&gt;当我们在终端执行命令：&lt;code&gt;npm run build
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Vue 入口初始化</title>
    <link href="http://panzeyong.com/2020/03/29/Vue-%E5%85%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://panzeyong.com/2020/03/29/Vue-入口初始化/</id>
    <published>2020-03-29T13:32:55.000Z</published>
    <updated>2020-08-29T08:52:49.147Z</updated>
    
    <content type="html"><![CDATA[<p>这节主要介绍 Vue 是如何初始化以及初始化过程中做了哪些事情。通过自己整理出来的流程图来说明其主线：</p>
<p><img src="/images/vue/vue_init.png" alt=""></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/entrance.html#vue-%E7%9A%84%E5%85%A5%E5%8F%A3" target="_blank" rel="external">从入口开始</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这节主要介绍 Vue 是如何初始化以及初始化过程中做了哪些事情。通过自己整理出来的流程图来说明其主线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/vue/vue_init.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; 
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 之原型及原型链</title>
    <link href="http://panzeyong.com/2019/11/19/Javascript-%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://panzeyong.com/2019/11/19/Javascript-之原型及原型链/</id>
    <published>2019-11-18T23:53:16.000Z</published>
    <updated>2019-11-23T09:29:09.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Javascript 函数有一个 <code>prototype</code> 属性，该属性是一个指针，指向一个对象，该对象包含特定类型的所有实例共享的属性和方法，称为实例对象的<strong>原型对象</strong>。</p>
<p>简单来说，在 JavaScript 中创建一个新函数，就会自动获取 <code>prototype</code> 属性，通过 <code>new</code> 命令创建实例对象，实例对象会获取 <code>prototype</code> 属性所指向的原型对象的属性和方法。打个比方，在 Java 中有类和继承的概念，<code>prototype</code> 所指向的原型对象就好比 Java 中的基类，而新函数好比是 Java 中的新类，继承基类中的属性和方法，那么创建实例后，除了能访问到本身的属性和方法外，还能访问到基类中的属性和方法。</p>
<h1 id="构造函数与原型对象之间的关系"><a href="#构造函数与原型对象之间的关系" class="headerlink" title="构造函数与原型对象之间的关系"></a>构造函数与原型对象之间的关系</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.age = <span class="number">12</span>;</div><div class="line"><span class="built_in">console</span>.log(person.age);    <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>以上例子，Person 是一个构造函数，通过 <code>new</code> 命令实例化对象。通过构造函数实例化对象的方式，如果多个实例对象都拥有属性 <code>age</code> 时，则需要在每个实例对象本身设置该属性，这样的操作显得有点冗余。那么有没有一种方式可以把属性 <code>age</code> 设置为公有，实例化对象时就自动拥有公共的属性呢，而对于实例对象本身只需要添加自己需要的属性即可。答案是有的。</p>
<p>这里就需要引出 <code>prototype</code> 属性，那么 <code>prototype</code> 属性是什么呢？除了<strong>bind 函数</strong>、<strong>箭头函数</strong>以及 <strong>Function.prototype</strong> 外，每个函数都有一个属性 <strong>prototype</strong>，该属性是一个指针，指向一个对象，该对象是函数的<strong>原型对象</strong>，原型对象包含了公共的属性和方法，实例化的所有对象都共享原型对象的属性和方法。<em>需要注意的是 <em>*<code>prototype</code> 属性是函数才拥有的。</em></em> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Person.prototype.age = <span class="number">12</span>;</div><div class="line">Person.prototype.name = <span class="string">"Jack"</span>;</div><div class="line"></div><div class="line">Person.prototype.say = () =&gt; &#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello World !"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.age);    <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(person1.name);   <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(person2.age);    <span class="comment">// 12</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// Jack</span></div><div class="line"><span class="built_in">console</span>.log(person1.say());  <span class="comment">// Hello World</span></div><div class="line"><span class="built_in">console</span>.log(person2.say());  <span class="comment">// Hello World</span></div><div class="line"></div><div class="line">person1.job = <span class="string">"test"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.job);    <span class="comment">// test</span></div><div class="line"><span class="built_in">console</span>.log(person2.job);    <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>从以上例子可以得知，通过 <code>prototype</code> 属性添加 <code>age</code> 和 <code>name</code> 属性，然后实例化两个对象，分别打印出两个属性是有值的，说明实例对象拥有了原型对象的属性和方法。</p>
<p>现在我们已经知道构造函数与原型对象的单向关系，即构造函数通过 <code>prototype</code> 属性指向原型对象。那么原型对象能反过来通过某种方式指向原先的构造函数吗？答案是可以的，这时就需要 <code>constructor</code> 派上场了。</p>
<p>每个原型对象都会有一个 <code>constructor</code> 属性，而 <code>constructor</code> 属性包含一个指向 <code>prototype</code> 属性所在函数的指针。以上面例子为例，即</p>
<p><code>Person.prototype.constructor === Person</code>（<code>true</code>）。</p>
<p>至此，我们理清了构造函数与原型对象之间的关系，关系图如下：</p>
<p><img src="/images/javascript/prototype/constructor_prototype_object_relation.png" alt=""></p>
<h1 id="实例对象与原型对象之间的关系"><a href="#实例对象与原型对象之间的关系" class="headerlink" title="实例对象与原型对象之间的关系"></a>实例对象与原型对象之间的关系</h1><p>当读取实例对象属性时，首先会在实例对象本身查找该属性是否存在，不存在的话，就会往实例对象与之关联的原型对象查找，再查找不到时，直向原型的原型查找，查找到最上层为止。</p>
<p>例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Jack"</span>;</div><div class="line">Person.prototype.desc = <span class="string">"desc"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// Jack</span></div></pre></td></tr></table></figure>
<p>可见，实例对象 <code>person</code> 本身没有属性 <code>name</code>，但是还能查找到该属性，这是通过原型对象找到的。那么实例对象是通过什么方式与原型对象关联呢？其实实例对象有一个属性 <code>__proto__</code>，指向原型对象，即 </p>
<p><code>person.__proto__ === Person.prototype</code>（<code>true</code>）。</p>
<p><img src="/images/javascript/prototype/proto_to_prototype.png" alt=""></p>
<h1 id="原型对象的原型对象"><a href="#原型对象的原型对象" class="headerlink" title="原型对象的原型对象"></a>原型对象的原型对象</h1><p>从上面我们已经理清了构造函数与原型对象、实例对象与原型对象之间的关系，那么我们会不会产生一个疑惑：原型对象的原型对象是什么，即 <code>Person.prototype</code> 的原型对象是什么？</p>
<p>JavaScript 中的所有对象都来自 <code>Object</code>，并且所有对象都从 <code>Object.prototype</code> 继承属性和方法，尽管它们可能被覆盖。因此可以推出：</p>
<p><code>Person.prototype.__proto__ === Object.prototype</code>（<strong>true</strong>）。</p>
<p><img src="/images/javascript/prototype/object_prototype.png" alt=""></p>
<p>图中画虚线的表示通过 <code>__prototype__</code> 形成原型链；至此，已经把原型对象及原型链的知识讲完。最后放一张网上对原型的理解画得比较全面的关系图，如下：</p>
<p><img src="/images/javascript/prototype/prototype_all.png" alt=""></p>
<p>注：以上只是自己整理的学习笔记，由于水平有限难免有错误，欢迎指出。随着自己对原型的深入理解，笔记也会做相应的修改，最后放上资料参考来源。</p>
<ul>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">https://github.com/mqyqingfeng/Blog/issues/2</a></p>
</li>
<li><p>《JavaScript 高级程序设计》（第 3 版）</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Javascript 函数有一个 &lt;code&gt;prototype&lt;/code&gt; 属性，该属性是一个指针，指向一个对象，该对象包含特定类型的所
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="知识点整理" scheme="http://panzeyong.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>函数的扩展</title>
    <link href="http://panzeyong.com/2019/03/12/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/12/函数的扩展/</id>
    <published>2019-03-12T12:04:48.000Z</published>
    <updated>2020-08-29T09:46:53.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、函数参数的默认值"><a href="#一、函数参数的默认值" class="headerlink" title="一、函数参数的默认值"></a>一、函数参数的默认值</h1><h3 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><p>ES6 允许为函数的参数指定默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">default</span> (<span class="params">x, y = 'hello'</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的点： </p>
<ul>
<li><p>参数变量是默认声明的，因此不能使用 <code>let</code> 或者 <code>const</code> 再次声明。</p>
</li>
<li><p>使用参数默认值时，函数不能有同名参数。</p>
</li>
<li><p>参数默认值是惰性求值的。（默认值是表达式求值）。</p>
</li>
<li><p>将参数默认值指定为 <code>undefined</code>，表示该参数可以省略。</p>
</li>
</ul>
<h3 id="2、对象的解构赋值与函数参数的默认值"><a href="#2、对象的解构赋值与函数参数的默认值" class="headerlink" title="2、对象的解构赋值与函数参数的默认值"></a>2、对象的解构赋值与函数参数的默认值</h3><p>对象的解构赋值例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
<p>函数 foo 的参数是一个对象，需要传递对象才能对 <code>x</code> 和 <code>y</code> 变量解析；如果不传的参数，那么则会报错。</p>
<p>函数参数指定默认值例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = 5&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x, y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、参数默认值的位置"><a href="#3、参数默认值的位置" class="headerlink" title="3、参数默认值的位置"></a>3、参数默认值的位置</h3><p>通常情况下，指定函数参数的默认值，应该是函数参数的最后一个。</p>
<h3 id="4、函数的-length-属性"><a href="#4、函数的-length-属性" class="headerlink" title="4、函数的 length 属性"></a>4、函数的 length 属性</h3><p><code>length</code> 属性的定义是预期函数传入参数的个数，如果我们指定了函数参数的默认值，那么该参数就不属于预期参数，不能计算进去。即函数 <code>length</code> 属性的值等于函数参数的个数减去指定默认值参数的个数。</p>
<p>需要注意的点：</p>
<ul>
<li><p><code>rest</code> 参数不会计入 <code>length</code> 属性；</p>
</li>
<li><p>如果指定默认值的参数不是尾参数，那么 <code>length</code> 属性的值等于指定默认值参数之前参数的个数。</p>
</li>
</ul>
<h3 id="5、作用域"><a href="#5、作用域" class="headerlink" title="5、作用域"></a>5、作用域</h3><p>当函数参数指定默认值时，函数进行声明初始化时，参数会形成一个单独的作用域；直到初始化结束后，作用域才会消失。</p>
<h1 id="二、rest（…test）"><a href="#二、rest（…test）" class="headerlink" title="二、rest（…test）"></a>二、rest（…test）</h1><p>用于获取函数多余的参数，并将参数存放于数组。<code>rest</code> 参数可以替代 <code>arguments</code>，因为 <code>arguments</code> 是一个类数组的对象，需要使用 <code>Array.prototype.slice.call()</code> 方法将其转为真正的数组；而 <code>rest</code> 参数本身是真正的数组，使用起来很方便。</p>
<p><code>rest</code> 参数必须是函数参数列表中的最后一个参数，否则使用起来会报错。</p>
<h1 id="三、严格模式"><a href="#三、严格模式" class="headerlink" title="三、严格模式"></a>三、严格模式</h1><p>ES6 规定：只要函数使用了<strong>默认值</strong>、<strong>解构赋值</strong>或者<strong>扩展运算符</strong>，函数内部就不能显示设定为严格模式；否则使用起来会报错。</p>
<h3 id="规避这种限制的两种方法："><a href="#规避这种限制的两种方法：" class="headerlink" title="规避这种限制的两种方法："></a>规避这种限制的两种方法：</h3><ul>
<li><p>设定全局的严格模式；</p>
</li>
<li><p>把函数包含在一个无参数的立即执行函数里面。（IIF）</p>
</li>
</ul>
<h1 id="四、name-属性"><a href="#四、name-属性" class="headerlink" title="四、name 属性"></a>四、name 属性</h1><p>函数 <code>name</code> 属性，返回函数的名称。但是在 ES6 和 ES5 稍微有点区别，具体表现在：</p>
<ul>
<li><p>如果将一个匿名函数赋值给变量，那么在 ES5 中 <code>name</code> 属性会返回<strong>空字符串</strong>；而 ES6 则会返回实际的函数名称。</p>
</li>
<li><p>如果将一个有具体名称的函数赋值给一个变量，那么在 ES5 和 ES6 中，<code>name</code> 属性返回的值是一样，都是具体的函数名字。</p>
</li>
</ul>
<h1 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h1><h3 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h3><p>ES6 允许使用 “箭头”（<code>=&gt;</code>）定义函数，称为箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = x =&gt; x;</div><div class="line"></div><div class="line">等同于</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// foo(5)</span></div></pre></td></tr></table></figure>
<p>使用时需要注意的点：</p>
<ul>
<li><p>如果箭头函数不需要参数或者需要多个参数，可以使用<strong>圆括号</strong>代表参数一部分。</p>
</li>
<li><p>如果箭头函数的代码块语句多于一行代码的话，则需要使用大括号将代码块括起来，并且使用 <code>return</code> 语句返回。</p>
</li>
<li><p>如果箭头函数直接返回一个对象，则需要在对象使用<strong>圆括号</strong>将其括起来，否则会报错；或者在对象外使用<strong>大括号</strong>并且 <code>return</code> 语句。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> getTempItem = id =&gt; (&#123; id: id, name: <span class="string">"Temp"</span> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> getTempItem = id =&gt; &#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		id: id,</div><div class="line">		name: <span class="string">"Temp"</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>函数体内的 <code>this</code> 对象，就是<strong>定义时</strong>所在的对象，而<strong>不是使用时</strong>所在的对象。</p>
</li>
<li><p><strong>不可以</strong>当作<strong>构造函数</strong>，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</p>
</li>
<li><p><strong>不可以</strong>使用 <code>arguments</code> 对象，该对象在函数体内<strong>不存在</strong>。如果要用，可以用 <code>rest</code> 参数代替。</p>
</li>
<li><p><strong>不可以</strong>使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数。</p>
</li>
<li><p><code>arguments</code>、<code>super</code>、<code>new.target</code> 这三个变量在箭头函数中是不存在的，而是指向外层函数的变量。</p>
</li>
<li><p>由于箭头函数没有自己的 <code>this</code>，因此也就无法使用 <code>call()</code>、<code>apply()</code> 和 <code>bind()</code> 改变 <code>this</code> 指向。</p>
</li>
<li><p>在箭头函数中，<code>this</code> 的指向是固定的。原因是因为箭头函数内部没有自己的 <code>this</code>，导致内部的 <code>this</code> 就是外部代码块的 <code>this</code>。</p>
</li>
</ul>
<h3 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h3><ul>
<li>简化回调函数</li>
</ul>
<h3 id="3、不适合使用场景"><a href="#3、不适合使用场景" class="headerlink" title="3、不适合使用场景"></a>3、不适合使用场景</h3><ul>
<li><p>定义函数的方法，且该方法内部包括 <code>this</code>。</p>
</li>
<li><p>需要动态使用 <code>this</code>。</p>
</li>
</ul>
<h1 id="六、双冒号运算符（提案）"><a href="#六、双冒号运算符（提案）" class="headerlink" title="六、双冒号运算符（提案）"></a>六、双冒号运算符（提案）</h1><p>函数绑定运算符是使用并排的两个冒号 <code>::</code>，双冒号的左边是一个对象，而右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（<code>this</code>），绑定到右边的函数上。</p>
<h1 id="七、尾调用优化"><a href="#七、尾调用优化" class="headerlink" title="七、尾调用优化"></a>七、尾调用优化</h1><h3 id="1、尾调用"><a href="#1、尾调用" class="headerlink" title="1、尾调用"></a>1、尾调用</h3><p>某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> g();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用函数时，会在内存中开辟一块内存空间来存储函数信息，比如变量、调用位置之类的，我们可以称之为 “调用记录”，或者称为 “调用帧”；如果函数内部又调用其它函数，类似的也会有自己的 “调用帧”，以此类推，所有的 “调用帧” 会形成 “调用栈”。</p>
<p>而尾调用是函数最后一步操作，因此不需要外层函数的信息，即不需要保留外层函数的 “调用帧”，而只需要保留内层函数的 “调用帧”，即只保存一条记录，称为 “尾调用优化”。</p>
<h3 id="2、尾递归"><a href="#2、尾递归" class="headerlink" title="2、尾递归"></a>2、尾递归</h3><p>某个函数的最后一步是调用自身函数，称为尾递归。</p>
<p>柯里化：将多参数的函数改为单参数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</div><div class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</div><div class="line"></div><div class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></div></pre></td></tr></table></figure>
<h3 id="3、严格模式"><a href="#3、严格模式" class="headerlink" title="3、严格模式"></a>3、严格模式</h3><p>ES6 规定尾调用递归只在严格模式下生效，正常模式时无效的。</p>
<p>正常模式下，函数内部有两个变量可以跟踪函数调用栈：</p>
<ul>
<li><p><code>func.arguments</code>：返回调用时函数的参数。</p>
</li>
<li><p><code>func.caller</code>：返回调用当前函数的那个函数。</p>
</li>
</ul>
<p>但是在严格模式下禁用这两个变量。</p>
<h3 id="4、尾递归优化的实现"><a href="#4、尾递归优化的实现" class="headerlink" title="4、尾递归优化的实现"></a>4、尾递归优化的实现</h3><ul>
<li><p>为了减少调用栈，可以使用<strong>循环</strong>替代递归。</p>
</li>
<li><p>蹦床函数：每一步返回一个函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fun <span class="comment">/*, args */</span></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> result = fun.apply(fun, _.rest(<span class="built_in">arguments</span>));</div><div class="line">  		<span class="keyword">while</span> (_.isFunction(result)) &#123;</div><div class="line">  			result = result();</div><div class="line">  		&#125;</div><div class="line">  		<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="八、函数参数的尾逗号"><a href="#八、函数参数的尾逗号" class="headerlink" title="八、函数参数的尾逗号"></a>八、函数参数的尾逗号</h1><p>ES7 允许函数的最后一个参数可以有尾逗号。</p>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/function" target="_blank" rel="external">函数的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、函数参数的默认值&quot;&gt;&lt;a href=&quot;#一、函数参数的默认值&quot; class=&quot;headerlink&quot; title=&quot;一、函数参数的默认值&quot;&gt;&lt;/a&gt;一、函数参数的默认值&lt;/h1&gt;&lt;h3 id=&quot;1、基本用法&quot;&gt;&lt;a href=&quot;#1、基本用法&quot; class=&quot;
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>数值的扩展</title>
    <link href="http://panzeyong.com/2019/03/03/%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/03/数值的扩展/</id>
    <published>2019-03-03T09:37:39.000Z</published>
    <updated>2020-08-29T09:44:40.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、二进制和八进制的表示法"><a href="#1、二进制和八进制的表示法" class="headerlink" title="1、二进制和八进制的表示法"></a>1、二进制和八进制的表示法</h3><p>从 ES5 开始，在严格模式下，不允许使用前缀 <code>0</code> 来表示八进制，否则会报错。在ES 6 中，提供了新的表示方法，即用前缀 <code>0b</code> 或者 <code>0B</code> 表示二进制，<code>0o</code> 或者 <code>0O</code> 表示八进制。</p>
<h3 id="2、安全整数"><a href="#2、安全整数" class="headerlink" title="2、安全整数"></a>2、安全整数</h3><p>JavaScript 能够准确表示整数范围为 <code>-2^53</code> ~ <code>2^53</code>（不包括两端），超过这个范围，计算就不准确了。ES6 提供两个常量来表示最大值和最小值：</p>
<ul>
<li><p><code>Number.MAX_SAFE_INTEGER</code>：最大安全整数，9007199254740991。</p>
</li>
<li><p><code>Number.MIN_SAFE_INTEGER</code>：最小安全整数，-9007199254740991。</p>
</li>
</ul>
<h3 id="3、Number-对象提供方法"><a href="#3、Number-对象提供方法" class="headerlink" title="3、Number 对象提供方法"></a>3、Number 对象提供方法</h3><ul>
<li><p><code>Number.isFinite()</code>：检查一个数值是否有限的（finite），即不是 <code>Infinity</code>。需要注意的是：<strong>参数类型不是数值，一律返回 <code>false</code>。</strong></p>
</li>
<li><p><code>Number.isNaN()</code>：检查一个值是否为 <code>NaN</code>。需要注意的是：<strong>参数类型不是 NaN，一律返回 <code>false</code>。</strong></p>
<p>  与传统方法 <code>isFiniter</code> 和 <code>isNaN</code> 的区别：传统方法需要先将非数值转换为数值，然后再进行判断，而新方法直接对数值进行判断。</p>
</li>
<li><p><code>Number.parseInt()</code>：与传统全局方法 <code>parseInt()</code> 行为实现完全一样。</p>
</li>
<li><p><code>Number.parseFloat()</code>：与传统全局方法 <code>parseFloat()</code> 行为实现完全一样。</p>
</li>
<li><p><code>Number.isInteger()</code>：判断一个数值是否为整数。在 JaveScript 内部，整数和浮点数采用的是同样的存储方法，因此 20 与 20.0 是同一个值。需要注意的是：<strong>参数类型不是数值，一律返回 <code>false</code>，以及精确度。</strong></p>
</li>
<li><p><code>Number.EPSILON()</code>：一个极小的常量，表示 1 和大于 1 的最小浮点数之间的差。可以用来计算浮点数时，设置可以接受的最小误差范围。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.EPSILON</div><div class="line"><span class="comment">// 2.220446049250313e-16</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>Number.isSafeInteger()</code>：用来判断一个数是否落在安全整数范围内。在验证的过程中，不仅要验证运算结果，还要验证参与运算的值。</li>
</ul>
<h3 id="4、Math-对象的扩展"><a href="#4、Math-对象的扩展" class="headerlink" title="4、Math 对象的扩展"></a>4、Math 对象的扩展</h3><ul>
<li><p><code>Math.trunc()</code>：去除一个数的小数部分，返回整数部分。对于非数值，内部先使用 <code>Number</code> 方法将其转换为数值；对于空值和无法截取整数的值，则返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.sign()</code>：用来判断一个值是正数、负数和零，对于非数值，会先将其返回数值。返回值有 5 种情况：</p>
<ul>
<li><p><code>+1</code>：正数；</p>
</li>
<li><p><code>-1</code>：负数；</p>
</li>
<li><p><code>0</code>：0；</p>
</li>
<li><p><code>-0</code>：-0；</p>
<p><code>NaN</code>：其他值。</p>
</li>
</ul>
</li>
<li><p><code>Math.cbrt()</code>：用于计算一个数的立方根，对于非数值，内部先使用 <code>Number</code> 方法将其转换为数值。</p>
</li>
<li><p><code>Math.clz32()</code>：将参数转为 32 位无符号整数的形式，返回 32 位值里面有多少个 0。对于小数，只考虑整数部分；对于空值或者其它类型的，会先将他们转换为数值。</p>
</li>
<li><p><code>Math.imul()</code>：返回两个数以 32 位带符号整数形式相乘的结果，可以返回正确的低位数值。</p>
</li>
<li><p><code>Math.fround()</code>：返回一个数的 32 位单精度浮点数形式。对于 <code>NaN</code> 和 <code>Infinity</code> 此方法返回原值；对于其它类型的值，会先将它们转为数值，再返回单精度浮点数。</p>
<p>  对于 32 位单精度浮点数格式来说，数值精度是 24 个二进制位（1 + 23），范围 -2^24 ~ 2^24。</p>
</li>
<li><p><code>Math.hypot()</code>：返回所有参数的平方和的平方根。对于非数值，会先将它们转为数值。</p>
</li>
</ul>
<h3 id="5、对数方法"><a href="#5、对数方法" class="headerlink" title="5、对数方法"></a>5、对数方法</h3><ul>
<li><p><code>Math.expm1()</code>：返回 e^x - 1，即 <code>Math.exp(x) - 1</code>。</p>
</li>
<li><p><code>Math.log1p()</code>：返回 <code>1 + x</code> 的自然对数，即 <code>Math.log(1 + x)</code>。如果 x 小于 -1，返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.log10()</code>：返回以 10 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 <code>NaN</code>。</p>
</li>
<li><p><code>Math.log2()</code>：返回以 2 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 <code>NaN</code>。</p>
</li>
</ul>
<h3 id="6、双曲函数方法"><a href="#6、双曲函数方法" class="headerlink" title="6、双曲函数方法"></a>6、双曲函数方法</h3><ul>
<li><p><code>Math.sinh(x)</code>：返回 <code>x</code> 的双曲正弦。</p>
</li>
<li><p><code>Math.cosh(x)</code>：返回 <code>x</code> 的双曲余弦。</p>
</li>
<li><p><code>Math.tanh(x)</code>：返回 <code>x</code> 的双曲正切。</p>
</li>
<li><p><code>Math.asinh(x)</code>：返回 <code>x</code> 的反双曲正弦。</p>
</li>
<li><p><code>Math.acosh(x)</code>：返回 <code>x</code> 的反双曲余弦。</p>
</li>
<li><p><code>Math.atanh(x)</code>：返回 <code>x</code> 的反双曲正切。</p>
</li>
</ul>
<h3 id="7、指数运算符"><a href="#7、指数运算符" class="headerlink" title="7、指数运算符"></a>7、指数运算符</h3><p><code>**</code>：指数运算符，有个特点是右结合。</p>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/number#Math-sign" target="_blank" rel="external">数值的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、二进制和八进制的表示法&quot;&gt;&lt;a href=&quot;#1、二进制和八进制的表示法&quot; class=&quot;headerlink&quot; title=&quot;1、二进制和八进制的表示法&quot;&gt;&lt;/a&gt;1、二进制和八进制的表示法&lt;/h3&gt;&lt;p&gt;从 ES5 开始，在严格模式下，不允许使用前缀 &lt;c
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="http://panzeyong.com/2019/03/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://panzeyong.com/2019/03/03/字符串的扩展/</id>
    <published>2019-03-03T07:14:34.000Z</published>
    <updated>2020-08-29T09:40:38.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、字符串的遍历接口"><a href="#1、字符串的遍历接口" class="headerlink" title="1、字符串的遍历接口"></a>1、字符串的遍历接口</h3><p><code>for...of</code> 不仅能遍历字符串，还能识别大于 <code>0xFFFF</code> 的码点，但是传统的 <code>for</code> 循环是无法识别的。</p>
<h3 id="2、字符串实例方法"><a href="#2、字符串实例方法" class="headerlink" title="2、字符串实例方法"></a>2、字符串实例方法</h3><ul>
<li><p><code>normalize()</code>：将字符串的不同表示方法统一为同样的形式，称为 Unicode 正规化。(Unicode 提供两种方法：一种是直接提供带重音符号的字符；另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，)</p>
<p>  <code>normalize</code> 方法提供一个参数来指定 <code>normalize</code> 的方式，共有四个选项：</p>
<ul>
<li><p><code>NFC</code>：默认参数，表示 “标准等价合成”，返回合成字符；</p>
</li>
<li><p><code>NFD</code>：表示 “标准等价分解”；</p>
</li>
<li><p><code>NFKC</code>：表示 “兼容等价合成”，返回合成字符；</p>
</li>
<li><p><code>NFKD</code>：表示 “兼容等价分解”。</p>
</li>
</ul>
</li>
<li><p>对于一个字符串是否包含在另一个字符串中，ES6 提供了三个新方法：</p>
<ul>
<li><p><code>includes()</code>：表示是否找到了参数字符串，返回布尔值。</p>
</li>
<li><p><code>startsWith()</code>：表示参数字符串是否在原字符串的头部，返回布尔值。</p>
</li>
<li><p><code>endsWith()</code>：表示参数字符串是否在原字符串的尾部，返回布尔值。</p>
<p>  这三个方法都接受两个参数：参数字符串 str 和从原始字符串开始搜索的位置 n。</p>
</li>
</ul>
</li>
<li><p><code>repeat()</code>：表示将原字符串复制 n 次，返回新的字符串。对于参数，有几种情况需要注意下：</p>
<ul>
<li><p>参数是小数时，会被取整；</p>
</li>
<li><p>参数是负数或者 Infinity，会报错；</p>
</li>
<li><p>参数是 0 ~ 1 之间的小数，则视为 0；</p>
</li>
<li><p>参数是 0 ~ -1 之间，也视为 0；</p>
</li>
<li><p>参数是 NaN，视为 0；</p>
</li>
<li><p>参数是字符串，会先转为数字。</p>
</li>
</ul>
</li>
<li><p>字符串补全功能的两个方法：</p>
<ul>
<li><p><code>padStart()</code>：头部补全。</p>
</li>
<li><p><code>padEnd()</code>：尾部补全。</p>
<p>  这两个方法共接受两个参数：第一个参数是字符串补全生效的最大长度，第二个参    数是用来补全的字符串。对于方法的使用，需要说明的点如下：</p>
<ul>
<li><p>如果原字符串的长度，大于或等于最大长度，则补全字符串失效，返回原字符串；</p>
</li>
<li><p>如果用来补全的字符串和原字符串，两者的长度超过最大长度，那么则会截出超出位数的补全字符串；</p>
</li>
<li><p>如果省略第二个参数，则会用空格来表示。</p>
<p><code>padStart()</code> 的用途：</p>
</li>
<li><p>为数值补全指定位数；</p>
</li>
<li><p>提示字符串格式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>matchAll()</code>：返回一个正则表达式在字符串中的所有匹配。</p>
<h3 id="3、String-对象提供的方法"><a href="#3、String-对象提供的方法" class="headerlink" title="3、String 对象提供的方法"></a>3、String 对象提供的方法</h3><p><code>String.raw()</code>：充当字符串模板的处理函数，返回一个斜杆都被转义的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 返回 "Hi\\u000A!"</span></div></pre></td></tr></table></figure>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://es6.ruanyifeng.com/#docs/string" target="_blank" rel="external">字符串的扩展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、字符串的遍历接口&quot;&gt;&lt;a href=&quot;#1、字符串的遍历接口&quot; class=&quot;headerlink&quot; title=&quot;1、字符串的遍历接口&quot;&gt;&lt;/a&gt;1、字符串的遍历接口&lt;/h3&gt;&lt;p&gt;&lt;code&gt;for...of&lt;/code&gt; 不仅能遍历字符串，还能识别大于 
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="http://panzeyong.com/2019/02/20/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://panzeyong.com/2019/02/20/变量的解构赋值/</id>
    <published>2019-02-20T14:41:08.000Z</published>
    <updated>2020-08-29T09:40:58.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、理解解构（Destructuring）"><a href="#一、理解解构（Destructuring）" class="headerlink" title="一、理解解构（Destructuring）"></a>一、理解解构（Destructuring）</h1><p>ES6 允许按照一定的模式，从对象和数组提取值，相应地赋值给对应的变量，简单来说，只要等号两边的模式相匹配，变量就会被赋予相应的值，我们把它称为<strong>解构</strong>赋值。</p>
<h1 id="二、支持变量解构的数据类型"><a href="#二、支持变量解构的数据类型" class="headerlink" title="二、支持变量解构的数据类型"></a>二、支持变量解构的数据类型</h1><h2 id="1、数组的解构赋值"><a href="#1、数组的解构赋值" class="headerlink" title="1、数组的解构赋值"></a>1、数组的解构赋值</h2><h3 id="解构赋值类型"><a href="#解构赋值类型" class="headerlink" title="解构赋值类型"></a>解构赋值类型</h3><ul>
<li>完全解构：等号左右两边的模式相匹配，变量被赋予相应的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<ul>
<li>不完全解构：等号左边的模式只匹配等号右边数组的一部分，这种情况解构是成功的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<h3 id="解构满足的条件"><a href="#解构满足的条件" class="headerlink" title="解构满足的条件"></a>解构满足的条件</h3><ul>
<li><p>等号右边的数据结构具有 Iterator 接口，否则会报错；</p>
</li>
<li><p>Set 结构也可以使用数组解构赋值。</p>
</li>
</ul>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值，默认值生效的条件：ES6 内部使用严格相等运算符 <code>===</code> 来判断一个位置是否有值，因此，只有当数组中的成员严格等于 <code>undefined</code>，默认值才会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]    <span class="comment">// x: 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]    <span class="comment">// x: null</span></div></pre></td></tr></table></figure>
<p>默认值可以是一个<strong>表达式</strong>，但是该表达式是<strong>惰性</strong>求值的，只有当用到</p>
<p>的时候，才会使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"默认值可是一个表达式"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = example()] = [<span class="number">1</span>];    <span class="comment">// 此时因为变量 x 能取到值 1，使得函数 example 不会被执行。</span></div></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其它变量，前提是这些变量被声明。</p>
<h2 id="2、对象的解构赋值"><a href="#2、对象的解构赋值" class="headerlink" title="2、对象的解构赋值"></a>2、对象的解构赋值</h2><p>与数组的解构赋值相比，有一点明显不同的是与对象属性的顺序没有关系，变量必须与属性名相同，才能获取相应的值。对象的解构赋值的真正形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;a: b, c: d&#125; = &#123;a: <span class="string">"test"</span>, c: <span class="string">"str"</span>&#125;</div></pre></td></tr></table></figure>
<p>a，b 是匹配模式，而 b，d 才是变量，被赋值的是后者，而不是前者。对象的解构赋值有简洁的表达形式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;a, c&#125; = &#123;a: <span class="string">"test"</span>, c: <span class="string">"str"</span>&#125;</div></pre></td></tr></table></figure>
<p>这种表达形式必须满足的条件是变量名与属性名必须相同。</p>
<p>解构也可以用于嵌套结构的对象</p>
<p>对象的解构也可以指定默认值，与数组的解构一样，默认值生效的条件是对象的属性值严格等于 <code>undefined</code>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>如果解构模式是嵌套的对象，并且子对象所在的父属性不存在，这种情况下会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>如果将一个已经声明的变量用于解构赋值，那么此时就得小心，有可能会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</div><div class="line">&#123;x&#125; = &#123;x: <span class="number">8</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line">(&#123;x&#125; = &#123;x:<span class="number">8</span>&#125;)</div></pre></td></tr></table></figure>
<p>JavaScript 引擎会将以大括号开头的代码解析成代码块，从而造成语法错误。要避免此错误的发生，则将其放在圆括号里面。</p>
<h2 id="3、字符串的解构赋值"><a href="#3、字符串的解构赋值" class="headerlink" title="3、字符串的解构赋值"></a>3、字符串的解构赋值</h2><p>字符串解构赋值时，会被转换成一个类似字数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c, d, e, f] = [<span class="string">"script"</span>];</div></pre></td></tr></table></figure>
<h2 id="4、数值和布尔值的解构赋值"><a href="#4、数值和布尔值的解构赋值" class="headerlink" title="4、数值和布尔值的解构赋值"></a>4、数值和布尔值的解构赋值</h2><p>如果等号右边的值不是数组或者对象时，在解构时，会将其先转换为对象。但是有比较特殊的情况是无法转换为对象，即 <code>null</code> 和 <code>undefined</code>，因此对它们解构赋值时是会报错的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;s: toString &#125; = <span class="number">123</span>;</div><div class="line"></div><div class="line">=&gt;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = <span class="number">123</span>,</div><div class="line">    s = _.toString;</div></pre></td></tr></table></figure>
<h2 id="5、函数参数的解构赋值"><a href="#5、函数参数的解构赋值" class="headerlink" title="5、函数参数的解构赋值"></a>5、函数参数的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为 x、y 指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;&#125;)    <span class="comment">// [0, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// 为 move 参数指定默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;&#125;)    <span class="comment">// [undefined, undefined]</span></div></pre></td></tr></table></figure>
<h1 id="三、圆括号问题"><a href="#三、圆括号问题" class="headerlink" title="三、圆括号问题"></a>三、圆括号问题</h1><h2 id="1、不能使用圆括号的情况"><a href="#1、不能使用圆括号的情况" class="headerlink" title="1、不能使用圆括号的情况"></a>1、不能使用圆括号的情况</h2><ul>
<li><p>变量声明语句；</p>
</li>
<li><p>函数参数；</p>
</li>
<li><p>赋值语句的模式。</p>
</li>
</ul>
<h2 id="2、可以使用圆括号的情况"><a href="#2、可以使用圆括号的情况" class="headerlink" title="2、可以使用圆括号的情况"></a>2、可以使用圆括号的情况</h2><p>赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(a)] = [<span class="number">8</span>]; <span class="comment">// 正确</span></div><div class="line">(&#123; p: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></div><div class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div></pre></td></tr></table></figure>
<h1 id="四、用途"><a href="#四、用途" class="headerlink" title="四、用途"></a>四、用途</h1><ul>
<li><p>交换变量；</p>
</li>
<li><p>从函数返回多个值；</p>
</li>
<li><p>函数参数的定义；</p>
</li>
<li><p>提取 JSON 数据；</p>
</li>
<li><p>函数参数的默认值；</p>
</li>
<li><p>遍历 Map 结构；</p>
</li>
<li><p>输入模块的指定方法。</p>
</li>
</ul>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="external">变量的解构赋值</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、理解解构（Destructuring）&quot;&gt;&lt;a href=&quot;#一、理解解构（Destructuring）&quot; class=&quot;headerlink&quot; title=&quot;一、理解解构（Destructuring）&quot;&gt;&lt;/a&gt;一、理解解构（Destructuring）&lt;/
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>let 和 const 命令</title>
    <link href="http://panzeyong.com/2019/02/12/let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/"/>
    <id>http://panzeyong.com/2019/02/12/let-和-const-命令/</id>
    <published>2019-02-12T04:34:36.000Z</published>
    <updated>2020-08-29T09:34:50.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、let-命令"><a href="#一、let-命令" class="headerlink" title="一、let 命令"></a>一、let 命令</h1><h3 id="1、let-的特点"><a href="#1、let-的特点" class="headerlink" title="1、let 的特点"></a>1、let 的特点</h3><ul>
<li><p><strong>只在声明的代码块生效</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>不存在变量提升</strong>：变量必须在声明之后才能使用，否则会报错；</p>
</li>
<li><p><strong>暂时性死区</strong>：在块级作用域内，使用 let 命令声明的变量，该变量就绑定了该作用域，形成一个封闭的作用域，这时如果在未声明变量前使用该变量，就会报错；也就是说，变量未声明时，是不能使用该变量的，把这种现象称为 “暂时性死区”。</p>
</li>
<li><p><strong>不允许重复</strong>：在相同作用域内，不允许声明相同的变量；</p>
</li>
<li><p><strong>块级作用域</strong>：内部作用域可以访问外部作用域的变量，但是外部作用域无法访问内部作用域的变量。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错：在相同作用域内声明相同变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> a = <span class="number">8</span>;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">9</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不会报错：因为 arg 处于不同作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">let</span> arg = <span class="number">8</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="number">8</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">	<span class="built_in">console</span>.log(test);    <span class="comment">// 报错</span></div><div class="line">	<span class="keyword">let</span> test = <span class="number">9</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、let-应用场景"><a href="#2、let-应用场景" class="headerlink" title="2、let 应用场景"></a>2、let 应用场景</h3><ul>
<li><p>for 循环计数器很适合使用 let 命令；</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">	b[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'Function: '</span> + i);</div><div class="line">   	&#125;;</div><div class="line">   	<span class="built_in">console</span>.log(b[i]);</div><div class="line">&#125;</div><div class="line">b[<span class="number">6</span>]();    <span class="comment">// 6（如果上述 i 使用 var 声明的话，那么输出的结果则为 10）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、const-命令"><a href="#二、const-命令" class="headerlink" title="二、const 命令"></a>二、const 命令</h1><h3 id="1、const-特点"><a href="#1、const-特点" class="headerlink" title="1、const 特点"></a>1、const 特点</h3><ul>
<li><p>声明只读常量，一旦声明之后，其值是不能修改的；</p>
</li>
<li><p>声明变量时，必须初始化，否则会报错；</p>
</li>
<li><p>只在所声明的块级作用域内有效；</p>
</li>
<li><p>不存在变量提升；</p>
</li>
<li><p>暂时性死区；</p>
</li>
<li><p>不允许重复。</p>
</li>
</ul>
<h3 id="2、本质"><a href="#2、本质" class="headerlink" title="2、本质"></a>2、本质</h3><p><code>const</code> 命令声明的变量的值不变，是指其变量所指向的内存地址保存的值是不变的，这对于基本数据类型（字符串、整型）来说是生效的；但是对于复合类型（数组和对象）来说就有区别了，比如一个变量保存一个对象，此时该变量是存储在栈中，保存的是对象的内存地址，而对象的数据结构是存储在堆中，也就是说，变量指向的是对象在堆中的内存地址，对于 <code>const</code> 命令来说，不变的是其内存地址，至于对象的数据结构变或者不变，<code>const</code> 就无法控制了。</p>
<p>如果想让对象及对象的属性不变，可以将对象<strong>冻结</strong>，及采用方法 <code>Object.freeze(obj)</code></p>
<h1 id="三、ES6-规定要点"><a href="#三、ES6-规定要点" class="headerlink" title="三、ES6 规定要点"></a>三、ES6 规定要点</h1><ul>
<li><p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
</li>
<li><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p>
</li>
<li><p>var 命令和 function 命令声明的全局变量，依然属于顶层对象 <code>window</code>（这里的环境是指浏览器）的属性，兼容 ES5；而使用 let 和 const 命令声明的全局变量，不再属于顶层对象 <code>window</code> 的属性，即在 ES6 中，顶层对象的属性与全局变量脱钩。</p>
</li>
</ul>
<h1 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h1><ul>
<li><p>for 循环包含两个独立的作用域，循环变量包含的部分是一个<strong>父作用域</strong>，而循环体内包含的部分是一个<strong>子作用域</strong>。因此，即使循环变量和循环体内声明的变量的名字是相同，但是其实它们是处在两个独立的作用域内，互不影响。</p>
</li>
<li><p>不同环境顶层对象不一样，表现在：</p>
<ul>
<li><p>浏览器的顶层对象指向的是 <code>window</code>、<code>self</code>；</p>
</li>
<li><p>Web Worker 的顶层对象指向的是 <code>self</code>；</p>
</li>
<li><p>Node 的顶层对象指向的是 <code>global</code>。</p>
</li>
</ul>
</li>
</ul>
<h1 id="五、ES6-声明变量的六种方法"><a href="#五、ES6-声明变量的六种方法" class="headerlink" title="五、ES6 声明变量的六种方法"></a>五、ES6 声明变量的六种方法</h1><ul>
<li><p>var</p>
</li>
<li><p>function</p>
</li>
<li><p>let</p>
</li>
<li><p>const</p>
</li>
<li><p>import</p>
</li>
<li><p>class</p>
</li>
</ul>
<p>以上是在学习 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="external">《ECMAScript 6 入门》</a> 一书时整理的学习笔记，方便日后查阅。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://es6.ruanyifeng.com/#docs/let" target="_blank" rel="external">let 和 const 命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、let-命令&quot;&gt;&lt;a href=&quot;#一、let-命令&quot; class=&quot;headerlink&quot; title=&quot;一、let 命令&quot;&gt;&lt;/a&gt;一、let 命令&lt;/h1&gt;&lt;h3 id=&quot;1、let-的特点&quot;&gt;&lt;a href=&quot;#1、let-的特点&quot; class=&quot;he
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="http://panzeyong.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 源码目录结构</title>
    <link href="http://panzeyong.com/2018/12/19/Vue%20%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://panzeyong.com/2018/12/19/Vue 源码目录结构/</id>
    <published>2018-12-19T14:33:04.000Z</published>
    <updated>2020-08-29T08:48:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>今年 4 月份开始使用 Vue.js，到现在差不多有 8 个月了，参与了两三个项目，对 Vue.js 的用法有了一定的了解。但是我觉得会使用是学习框架的第一步，第二步是研究框架是怎么实现的，学习其设计思想。所以给自己制定了计划来学习 Vue.js 框架源码，打算把自己学习到的知识作为一个系列记录下来。</p>
<p>在学习源码之前，先来学习下 Vue.js 目录结构设计，从整体上了解 Vue.js 的结构。</p>
<p>注：Vue.js 的版本为 2.6.11</p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul>
<li><p><code>.circleci</code>：Vue.js 使用了持续集成工具 CircleCI，要在项目中使用该工具，需要在项目根目录创建文件夹 <code>.circleci</code>，并在其目录下创建文件 <code>config.yml</code> 编写构建脚本。</p>
<ul>
<li><code>config.yml</code>：编写 CircleCI 构建脚本。</li>
</ul>
</li>
<li><p><code>.github</code>：项目相关说明文档，比如开发者参与项目的规则、要求之类的。</p>
<p>  <code>CODE_OF_CONDUCT.md</code>：贡献代码的行为准则。</p>
<p>  <code>COMMIT_CONVENTION.md</code>：git 提交代码时添加提交信息的约定。</p>
<p>  <code>CONTRIBUTING.md</code>：参与项目指南。</p>
<p>  <code>ISSUE_TEMPLATE.md</code>：提交 issue 的模板。</p>
<p>  <code>PULL_REQUEST_TEMPLATE.md</code>：拉取代码指南。</p>
</li>
<li><p><code>benchmarks</code>：性能测试相关文件。</p>
</li>
<li><p><code>dist</code>：包含不同分发版本的构建文件。要注意的是，这个目录只有在发布新版本时才会更新，开发分支更新的新特性不会影响到该目录。</p>
</li>
<li><p><code>example</code>：官方提供的示例。</p>
</li>
<li><p><code>flow</code>：包含使用Flow（静态类型检查工具）声明的类型，供全局使用。</p>
<ul>
<li><p><code>compiler.js</code>：编译相关。</p>
</li>
<li><p><code>component.js</code>：组件数据结构。</p>
</li>
<li><p><code>global-api.js</code>：Global API 结构。</p>
</li>
<li><p><code>modules.js</code>：第三方库定义。</p>
</li>
<li><p><code>options.js</code>：选项相关。</p>
</li>
<li><p><code>ssr.js</code>：服务端渲染相关。</p>
</li>
<li><p><code>vnode.js</code>：虚拟 node 相关。</p>
</li>
<li><p><code>weex.js</code>：weex 平台相关。</p>
</li>
</ul>
</li>
<li><p><code>packages</code>：包含服务端渲染和模板编译器两种不同 NPM 包，供不同场景使用。</p>
<ul>
<li><p><code>vue-server-render</code>：服务端渲染。</p>
</li>
<li><p><code>vue-template-compiler</code>：vue 模板编译器。</p>
</li>
<li><p><code>weex-template-compiler</code>：weex 模板编译器。</p>
</li>
<li><p><code>weex-vue-framework</code>：weex vue 框架。</p>
</li>
</ul>
</li>
<li><p><code>scripts</code>：包含构建相关脚本和配置文件，大多数情况下不需要关注该目录。</p>
<ul>
<li><p><code>alias.js</code>：所有源代码和测试中使用的模块导入别名。</p>
</li>
<li><p><code>config</code>：包含 <code>dist</code> 目录下所有文件的配置信息。</p>
</li>
</ul>
</li>
<li><p><code>src</code>：vue.js 源代码，代码用 ES6 实现的并采用 JavaScript 静态类型检查工具。</p>
<ul>
<li><p><code>compiler</code>：该目录包含 Vue.js 编译的相关代码，包括将模板字符串解析成 AST 语法树的<strong>解析器</strong>、检测用于 vdom 渲染优化的静态树的<strong>优化器</strong>和将 AST 语法树生成渲染函数的<strong>代码生成器</strong>。</p>
</li>
<li><p><code>core</code>：Vue.js 核心代码，包含通用、跨平台的代码。主要有观察者、虚拟 dom、vue 实例化、全局 api 和内置组件。</p>
</li>
<li><p><code>server</code>：包含与服务端渲染相关的代码。</p>
</li>
<li><p><code>platform</code>：Vue.js 是一个跨平台的 MVVM 框架，可以在 web 上运行，也可以配合 weex 在 native 客户端上运行。每个平台都有一个入口，都位于该目录下。</p>
</li>
<li><p><code>sfc</code>：包含将 .vue 单文件解析为 JavaScript 对象的代码，用于 <code>vue-template-compiler</code> 包。</p>
</li>
<li><p><code>shared</code>：包含通用的工具方法，用于浏览器端的 vue.js 和服务器端的 vue.js。</p>
</li>
</ul>
</li>
<li><p><code>tests</code>：所有测试代码，单元测试代码是用 <a href="https://jasmine.github.io/2.3/introduction.html" target="_blank" rel="external">Jasmine</a> 实现并与 <a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="external">Karma</a> 一起运行。e2e 测试是为 <a href="http://nightwatchjs.org/" target="_blank" rel="external">Nightwatch.js</a> 编写并与之一起运行。</p>
</li>
<li><p><code>types</code>：使用 TypeScript 类型注释，并且包含了测试代码。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#project-structure" target="_blank" rel="external">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#project-structure</a></p>
<p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html#compiler" target="_blank" rel="external">https://ustbhuangyi.github.io/vue-analysis/prepare/directory.html#compiler</a></p>
<p><a href="https://segmentfault.com/a/1190000016426470" target="_blank" rel="external">https://segmentfault.com/a/1190000016426470</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年 4 月份开始使用 Vue.js，到现在差不多有 8 个月了，参与了两三个项目，对 Vue.js 的用法有了一定的了解。但是我觉得会使用是学习框架的第一步，第二步是研究框架是怎么实现的，学习其设计思想。所以给自己制定了计划来学习 Vue.js 框架源码，打算把自己学习到
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 静态类型检查工具：Flow</title>
    <link href="http://panzeyong.com/2018/12/04/JavaScript-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%EF%BC%9AFlow/"/>
    <id>http://panzeyong.com/2018/12/04/JavaScript-静态类型检查工具：Flow/</id>
    <published>2018-12-04T15:01:32.000Z</published>
    <updated>2020-08-29T08:48:13.372Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flow.org/en/" target="_blank" rel="external">Flow</a> 是 Facebook 开源的 JavaScript 静态类型检查工具，它可以帮助提高我们的工作效率，使我们的代码更快、更智能、更自信和更大规模。</p>
<p>在学习 Flow 的用法之前，我们先来学习如何在项目中使用 Flow。</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h3 id="1、安装编译器"><a href="#1、安装编译器" class="headerlink" title="1、安装编译器"></a>1、安装编译器</h3><p>在 Flow 官方文档可以了解到，安装 Flow 的方式多种，主要取决于项目使用什么工具。Flow 可以通过包管理器来安装，即 npm 或 yarn，而在安装 Flow 时，需要设置编译器，有两种编译器：Babel 和 flow-remove-types，所以总共有 4 种安装方式。这里包管理器为 npm 和 编译器为 Babel 为例子来说。</p>
<ul>
<li><p>设置编译器</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-cli babel-preset-flow</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在项目根目录创建 <code>.babelrc</code> 文件，并添加以下代码</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> <span class="attr">"presets"</span>: [<span class="string">"flow"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果所有源文件都存储在 <code>src</code> 目录下，那么可以通过运行以下命令，把它们编译到另外一个目录</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/babel src/ -d lib/</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在 <code>package.json</code> 文件 <code>script</code> 添加代码</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"my-project"</span>,</div><div class="line">	<span class="attr">"main"</span>: <span class="string">"lib/index.js"</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">  		<span class="attr">"build"</span>: <span class="string">"babel src/ -d lib/"</span>,</div><div class="line">    	<span class="attr">"prepublish"</span>: <span class="string">"npm run build"</span></div><div class="line">  	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、安装-Flow"><a href="#2、安装-Flow" class="headerlink" title="2、安装 Flow"></a>2、安装 Flow</h3><ul>
<li><p>安装 flow-bin</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">	npm install --save-dev flow-bin</div><div class="line">	``` </div><div class="line">	</div><div class="line">- 在 `package.json` 文件 `script` 添加 Flow</div><div class="line"></div><div class="line">	```json</div><div class="line">	&#123;</div><div class="line">  &quot;name&quot;: &quot;my-flow-project&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    	&quot;flow-bin&quot;: &quot;^0.87.0&quot;</div><div class="line">  	 &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    	&quot;flow&quot;: &quot;flow&quot;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>初始化 Flow，会生成文件 <code>.flowconfig</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run flow init</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>运行 Flow</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run flow</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二、Flow-的工作方式"><a href="#二、Flow-的工作方式" class="headerlink" title="二、Flow 的工作方式"></a>二、Flow 的工作方式</h1><p>Flow 类型检查有两种方式：</p>
<ul>
<li><p>类型推断：结合变量的上下文语境推断出变量的数据类型，然后根据推断出的数据类型进行类型检查。</p>
</li>
<li><p>类型注释：在定义变量时声明其数据类型，Flow 会基于声明的数据类型作出判断。</p>
</li>
</ul>
<h3 id="1、类型推断"><a href="#1、类型推断" class="headerlink" title="1、类型推断"></a>1、类型推断</h3><p>类型推断这种类型检查方式对于开发者来说工作量几乎为零，基本不需要对代码作任何改造，Flow 会根据变量的上下文推断出类型，进而作出判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n * n; </div><div class="line">&#125;</div><div class="line"></div><div class="line">square(<span class="string">"2"</span>);    <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>Flow 检查上述代码会报错，因为函数 square 期待输入的参数是整型，而我们输入的是字符串。</p>
<h3 id="2、类型注释"><a href="#2、类型注释" class="headerlink" title="2、类型注释"></a>2、类型注释</h3><p>在某些场景下，通过类型推断是检查不出类型错误的，这时就需要通过其它方式来检查类型，也就是这部分要说的类型注释。类型注释是说在定义变量时声明其数据类型，有点类似静态语言，比如 Java，Flow 会基于此作出判断。</p>
<p>先来看一个通过类型推断检查不出错误的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*@flow*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="string">'Hello'</span>, <span class="number">222</span>)</div></pre></td></tr></table></figure>
<p>以上代码，从语法上看没有错误，<code>+</code> 既可以用在字符串上，也可以用在整型上，而且我们并没有指出函数 <code>add</code> 参数必须为整型，其实我们期望的是两个整型相加，为了达到这目的，我们可以指定变量的类型，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="string">'Hello'</span>, <span class="number">222</span>)    <span class="comment">// Error</span></div></pre></td></tr></table></figure>
<p>此时，我们指定变量 <code>x</code> 和 <code>y</code> 的数据类型为整型，而我们传递的参数中有一个是字符串，那么 Flow 检查类型就会报错。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="external">https://flow.org/en/docs/getting-started/</a></p>
</li>
<li><p><a href="https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F" target="_blank" rel="external">https://ustbhuangyi.github.io/vue-analysis/prepare/flow.html#flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://flow.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flow&lt;/a&gt; 是 Facebook 开源的 JavaScript 静态类型检查工具，它可以帮助提高我们的工作效率，使我们的代码更快、更智能、更自信
    
    </summary>
    
      <category term="Vue" scheme="http://panzeyong.com/categories/Vue/"/>
    
    
      <category term="Vue.js 源码解析" scheme="http://panzeyong.com/tags/Vue-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《Python3 网络爬虫开发实战》问题汇总（持续更新......）</title>
    <link href="http://panzeyong.com/2018/12/04/%E3%80%8APython3-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://panzeyong.com/2018/12/04/《Python3-网络爬虫开发实战》问题汇总/</id>
    <published>2018-12-04T14:52:32.000Z</published>
    <updated>2018-12-04T14:57:14.049Z</updated>
    
    <content type="html"><![CDATA[<p>mac 系统版本信息：</p>
<ul>
<li>macOS High Sierra </li>
<li>Version 10.13.4</li>
</ul>
<h3 id="1、安装-ChromeDriver"><a href="#1、安装-ChromeDriver" class="headerlink" title="1、安装 ChromeDriver"></a>1、安装 ChromeDriver</h3><p>mv: rename chromedriver to /usr/bin/chromedriver: Operation not permitted</p>
<p><a href="https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled" target="_blank" rel="external">解决方案</a></p>
<h3 id="2、安装-Geckodriver"><a href="#2、安装-Geckodriver" class="headerlink" title="2、安装 Geckodriver"></a>2、安装 Geckodriver</h3><p>Permission denied: ‘geckodriver.log’ while running selenium webdriver in python</p>
<p>[解决方案(<a href="https://stackoverflow.com/questions/40466809/permission-denied-geckodriver-log-while-running-selenium-webdriver-in-python" target="_blank" rel="external">https://stackoverflow.com/questions/40466809/permission-denied-geckodriver-log-while-running-selenium-webdriver-in-python</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac 系统版本信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS High Sierra &lt;/li&gt;
&lt;li&gt;Version 10.13.4&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1、安装-ChromeDriver&quot;&gt;&lt;a href=&quot;#1、安装-ChromeDriver&quot; c
    
    </summary>
    
      <category term="Python" scheme="http://panzeyong.com/categories/Python/"/>
    
    
      <category term="question" scheme="http://panzeyong.com/tags/question/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 问题</title>
    <link href="http://panzeyong.com/2018/03/08/JavaScript-%E9%97%AE%E9%A2%98/"/>
    <id>http://panzeyong.com/2018/03/08/JavaScript-问题/</id>
    <published>2018-03-08T09:25:35.000Z</published>
    <updated>2020-08-29T09:07:54.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JavaScript-数组（包括元素和对象）去重"><a href="#一、JavaScript-数组（包括元素和对象）去重" class="headerlink" title="一、JavaScript 数组（包括元素和对象）去重"></a>一、JavaScript 数组（包括元素和对象）去重</h1><h3 id="1、for-循环"><a href="#1、for-循环" class="headerlink" title="1、for 循环"></a>1、for 循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [array[<span class="number">0</span>]];</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, resultLen = result.length; j &lt; resultLen; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (array[i] === result[j]) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (j === resultLen) &#123;</div><div class="line">			result.push(array[i]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、indexOf"><a href="#2、indexOf" class="headerlink" title="2、indexOf"></a>2、indexOf</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> res = [];</div><div class="line">	</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">		<span class="keyword">var</span> current = array[i];</div><div class="line">		<span class="keyword">if</span> (res.indexOf(current) === <span class="number">-1</span>) &#123;</div><div class="line">			res.push(current);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、排序后去重"><a href="#3、排序后去重" class="headerlink" title="3、排序后去重"></a>3、排序后去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> res = [];</div><div class="line">    <span class="keyword">var</span> sortedArray = array.concat().sort();</div><div class="line">    <span class="keyword">var</span> seen;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = sortedArray.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="comment">// 如果是第一个元素或者相邻的元素不相同</span></div><div class="line">        <span class="keyword">if</span> (!i || seen !== sortedArray[i]) &#123;</div><div class="line">            res.push(sortedArray[i])</div><div class="line">        &#125;</div><div class="line">        seen = sortedArray[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4、ES6-Set"><a href="#4、ES6-Set" class="headerlink" title="4、ES6 Set"></a>4、ES6 Set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、根据对象属性的唯一值（针对数组元素是对象）"><a href="#5、根据对象属性的唯一值（针对数组元素是对象）" class="headerlink" title="5、根据对象属性的唯一值（针对数组元素是对象）"></a>5、根据对象属性的唯一值（针对数组元素是对象）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">unique(score: Score) &#123;</div><div class="line">    <span class="keyword">this</span>.changedScore.some((item, index) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (item.questionId === score.questionId) &#123;</div><div class="line">        <span class="keyword">this</span>.changedScore.splice(index, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.changedScore = <span class="keyword">this</span>.changedScore.concat(score);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h1 id="二、如何防止频繁操作"><a href="#二、如何防止频繁操作" class="headerlink" title="二、如何防止频繁操作"></a>二、如何防止频繁操作</h1><h3 id="1、防抖动"><a href="#1、防抖动" class="headerlink" title="1、防抖动"></a>1、防抖动</h3><ul>
<li><p>原理：当触发事件时，事件必须在 n 秒后才执行，但是当在这 n 秒内又触发事件，事件执行是以最新触发事件的事件为起点，直到这 n 秒内不再触发事件为止，事件才在 n 秒后被执行。</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</div><div class="line">	    <span class="keyword">var</span> timeout;</div><div class="line">	    </div><div class="line">	    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	        <span class="keyword">var</span> context = <span class="keyword">this</span>;</div><div class="line">	        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">	        </div><div class="line">	        clearTimeout(timeout)</div><div class="line">	        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	            func.apply(context, args)</div><div class="line">	        &#125;, wait);</div><div class="line">	    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、节流"><a href="#2、节流" class="headerlink" title="2、节流"></a>2、节流</h3><p>允许一个函数在规定的时间内只执行一次。</p>
<p>实现方法：</p>
<ul>
<li><p>时间戳</p>
</li>
<li><p>定时器</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、JavaScript-数组（包括元素和对象）去重&quot;&gt;&lt;a href=&quot;#一、JavaScript-数组（包括元素和对象）去重&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript 数组（包括元素和对象）去重&quot;&gt;&lt;/a&gt;一、JavaSc
    
    </summary>
    
      <category term="JavaScript" scheme="http://panzeyong.com/categories/JavaScript/"/>
    
    
      <category term="知识点整理" scheme="http://panzeyong.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>插入排序：直接插入排序</title>
    <link href="http://panzeyong.com/2018/01/22/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://panzeyong.com/2018/01/22/插入排序：直接插入排序/</id>
    <published>2018-01-22T14:23:30.000Z</published>
    <updated>2018-01-22T15:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发工作中，不管是前端开发还是后端开发，在处理数据时，有时根据业务需求需要对数据进行排序，这就涉及到排序算法的选择。然而排序算法有很多种，对于算法的选择需要根据业务的需求，除此之外，还需要扎实的基本功。最近刚好在学习排序算法，把它记录下来，当作学习笔记。这篇文章要讲的是插入排序中一种：直接插入排序。</p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>排序，简单来说就是把一组无序的元素以正序或者逆序的方式排序，那么至于采取什么方式排序，即是接下来要讲的。<strong>插入排序</strong>的主要思想是将一组元素的第一个元素看作是有序序列，从第二个元素起将待排序的元素插入到有序序列中，使有序序列逐渐扩大，直至所有元素都插入到有序序列中。<strong>直接插入排序</strong>是插入排序的一种，也是比较简单的一种排序方法，以下通过类比的例子来说明直接插入排序的思想。</p>
<p>这里小学上体育课为例子。回想下我们当时上第一节体育课的情景，老师会说：“同学们，先排好队伍，我们再开始上课”。那么此时老师会根据同学们的身高来排队伍，先按身高从低到高排成一排（从左到右站队），再分成 n 行 n 列。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发工作中，不管是前端开发还是后端开发，在处理数据时，有时根据业务需求需要对数据进行排序，这就涉及到排序算法的选择。然而排序算法有很多种，对于算法的选择需要根据业务的需求，除此之外，还需要扎实的基本功。最近刚好在学习排序算法，把它记录下来，当作学习笔记。这篇文章要讲的
    
    </summary>
    
    
  </entry>
  
</feed>
